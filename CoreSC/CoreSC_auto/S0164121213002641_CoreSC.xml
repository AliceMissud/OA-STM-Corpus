<?xml version="1.0" ?><PAPER><mode2 hasDoc="yes" name="S0164121213002641.tmf1" version="elsevier"/>
<TITLE>Using SPIN for automated debugging of infinite executions of Java programs
</TITLE>
<ABSTRACT>

Highlights
•
<s sid="1"><CoreSc1 advantage="None" conceptID="Met1" novelty="None" type="Met"/><text>We use linear time temporal logic to represent both failures and desirable behaviors regarding a temporally ordered sequence of events and/or conditions to be checked along one execution.</text></s>
•
<s sid="2"><CoreSc1 advantage="None" conceptID="Met2" novelty="None" type="Met"/><text>We use model checking algorithms record the history of the failed execution, which we use to implement a controlled replay to locate the bugs.</text></s>
•
<s sid="3"><CoreSc1 advantage="None" conceptID="Obj1" novelty="None" type="Obj"/><text>We support the analysis of potentially infinite executions.</text></s>
•
<s sid="4"><CoreSc1 advantage="None" conceptID="Obj2" novelty="None" type="Obj"/><text>We use runtime techniques to start the debugging work directly on the programmer's code.</text></s>
Abstract
<s sid="5"><CoreSc1 advantage="None" conceptID="Obj3" novelty="None" type="Obj"/><text>This paper presents an approach for the automated debugging of reactive and concurrent Java programs, combining model checking and runtime monitoring.</text></s>
<s sid="6"><CoreSc1 advantage="None" conceptID="Obj4" novelty="None" type="Obj"/><text>Runtime monitoring is used to transform the Java execution traces into the input for the model checker, the purpose of which is twofold.</text></s>
<s sid="7"><CoreSc1 advantage="None" conceptID="Obj5" novelty="None" type="Obj"/><text>First, it checks these execution traces against properties written in linear temporal logic (LTL), which represent desirable or undesirable behaviors.</text></s>
<s sid="8"><CoreSc1 advantage="None" conceptID="Goa1" novelty="None" type="Goa"/><text>Second, it produces several execution traces for a single Java program by generating test inputs and exploring different schedulings in multithreaded programs.</text></s>
<s sid="9"><CoreSc1 advantage="None" conceptID="Goa2" novelty="None" type="Goa"/><text>As state explosion is the main drawback to model checking, we propose two abstraction approaches to reduce the memory requirements when storing Java states.</text></s>
<s sid="10"><CoreSc1 advantage="None" conceptID="Goa3" novelty="None" type="Goa"/><text>We also present the formal framework to clarify which kinds of LTL safety and liveness formulas can be correctly analysed with each abstraction for both finite and infinite program executions.</text></s>
<s sid="11"><CoreSc1 advantage="None" conceptID="Met3" novelty="None" type="Met"/><text>A major advantage of our approach comes from the model checker, which stores the trace of each failed execution, allowing the programmer to replay these executions to locate the bugs.</text></s>
<s sid="12"><CoreSc1 advantage="None" conceptID="Met4" novelty="None" type="Met"/><text>Our current implementation, the tool TJT, uses Spin as the model checker and the Java Debug Interface (JDI) for runtime monitoring.</text></s>
<s sid="13"><CoreSc1 advantage="None" conceptID="Met5" novelty="None" type="Met"/><text>TJT is presented as an Eclipse plug-in and it has been successfully applied to debug complex public Java programs.</text></s>
</ABSTRACT>
<BODY>

Introduction
<s sid="14"><CoreSc1 advantage="None" conceptID="Met6" novelty="None" type="Met"/><text>The complexity of current software development is pushing programmers towards more automated analysis techniques, instead of the traditional interactive or postmortem debuggers.</text></s>
<s sid="15"><CoreSc1 advantage="None" conceptID="Met7" novelty="None" type="Met"/><text>For instance, unit testing allows the execution of test cases against a program, checking parts of the code such as single methods or classes in isolation (Runeson, 2006; JUnit testing and framework, xxxx; Beust and Suleiman, 2007; CppUnit framework, xxxx).</text></s>
<s sid="16"><CoreSc1 advantage="None" conceptID="Met8" novelty="None" type="Met"/><text>Runtime monitoring tools usually carry out some controlled executions of instrumented code on real or emulated target platforms (Run-time Monitoring and Checking, (MaC), xxxx; Kraft et al., 2010).</text></s>
<s sid="17"><CoreSc1 advantage="None" conceptID="Met9" novelty="None" type="Met"/><text>Model checking can produce and inspect all possible execution traces of a program, checking the presence or absence of failures along each trace (Clarke et al., 1999; Havelund and Pressburger, 2000; Beyer et al., 2007).</text></s>
<s sid="18"><CoreSc1 advantage="None" conceptID="Met10" novelty="None" type="Met"/><text>In the case of a failure, this technique records a trace to replay the failed execution.</text></s>
<s sid="19"><CoreSc1 advantage="None" conceptID="Bac1" novelty="None" type="Bac"/><text>To overcome some of the shortcomings of these automatic methods when used in isolation and to extend their domain of application, there have been several proposals that combine a few of them (Peled, 2003; Artho et al., 2003; Havelund and Roşu, 2004).</text></s>
<s sid="20"><CoreSc1 advantage="None" conceptID="Obj6" novelty="None" type="Obj"/><text>This paper discusses an approach to automated software debugging by the combination of model checking and runtime monitoring.</text></s>
<s sid="21"><CoreSc1 advantage="None" conceptID="Obj7" novelty="None" type="Obj"/><text>We focus on its application to analyze the (infinite) executions of a given reactive and/or concurrent Java program.</text></s>
<s sid="22"><CoreSc1 advantage="None" conceptID="Mod1" novelty="None" type="Mod"/><text>Model checking allows the software developer to describe correctness properties with specification languages such as Temporal Logic (Manna and Pnueli, 1992).</text></s>
<s sid="23"><CoreSc1 advantage="None" conceptID="Mod2" novelty="None" type="Mod"/><text>The properties could represent safety requirements, like □p (&quot;p is always true&quot;) and p U q (&quot;q will be true, and p will be true in all previous states&quot;), or liveness properties expressed with formulas such as ◊p (&quot;eventually p will be true&quot;), ◊□p (&quot;eventually p will be true forever&quot;), and □(p→◊q) (&quot;p will always be followed by q&quot;), p and p being any kind of proposition or even temporal formulas.</text></s>
<s sid="24"><CoreSc1 advantage="None" conceptID="Met11" novelty="None" type="Met"/><text>The most common use of LTL is to express complex liveness behaviors of infinite traces, which are the traces produced by reactive and/or concurrent software (Manna and Pnueli, 1992).</text></s>
<s sid="25"><CoreSc1 advantage="None" conceptID="Met12" novelty="None" type="Met"/><text>In order to check whether or not a program satisfies an LTL formula, model checking algorithms were designed to produce the whole execution graph in a concurrent program and to efficiently detect execution traces violating a formula, presenting these traces as counter-examples.</text></s>
<s sid="26"><CoreSc1 advantage="None" conceptID="Met13" novelty="None" type="Met"/><text>Counter-examples provide the sequence of instructions to the error, and they are the main source of information used to debug the program.</text></s>
<s sid="27"><CoreSc1 advantage="None" conceptID="Met14" novelty="None" type="Met"/><text>When we do not wish to produce all traces or check liveness properties, other less-expensive approaches, like the use of runtime monitors can be used to check only the subset of LTL representing safety properties.</text></s>
<s sid="28"><CoreSc1 advantage="None" conceptID="Bac2" novelty="None" type="Bac"/><text>Other monitor based approaches adapt the semantics of full LTL to finite executions, as done by Java PathExplorer (Havelund and Roşu, 2004).</text></s>
<s sid="29"><CoreSc1 advantage="None" conceptID="Mot1" novelty="None" type="Mot"/><text>The original design of Java PathExplorer only considered finite executions, and to the best of our knowledge, the extension for infinite traces is still not available.</text></s>
<s sid="30"><CoreSc1 advantage="None" conceptID="Mot2" novelty="None" type="Mot"/><text>Tools such as Verisoft (Godefroid, 1997) and CMC (Stoller, 2002) avoid storing the states of the program during monitoring, so they can perform a partial analysis of very large systems with little memory consumption.</text></s>
<s sid="31"><CoreSc1 advantage="None" conceptID="Met15" novelty="None" type="Met"/><text>Unfortunately, this stateless approach does not permit the analysis of LTL for infinite traces.</text></s>
<s sid="32"><CoreSc1 advantage="None" conceptID="Met16" novelty="None" type="Met"/><text>The analysis of an LTL formula along one or several potential infinite execution paths cannot be carried out with standard monitors, but requires storing the states of the program and the use of algorithms based on automata to recognize special cycles, like Büchi automata (Clarke et al., 1999).</text></s>
<s sid="33"><CoreSc1 advantage="None" conceptID="Met17" novelty="None" type="Met"/><text>Stateful approaches, like the one implemented in Java PathFinder (Visser et al., 2003) (JPF) keep a stack with the current execution trace to control backtracking, to produce counter-examples and to check cycles, so they could check LTL on infinite traces.</text></s>
<s sid="34"><CoreSc1 advantage="None" conceptID="Obj8" novelty="None" type="Obj"/><text>However, at the time of writing this paper, the extension for checking LTL formulas can only detect a few program events.</text></s>
<s sid="35"><CoreSc1 advantage="None" conceptID="Obj9" novelty="None" type="Obj"/><text>In the following sections we expand on the current status of LTL verification with JPF in a comparison with our proposal.</text></s>
<s sid="36"><CoreSc1 advantage="None" conceptID="Obj10" novelty="None" type="Obj"/><text>In this paper we propose a method to convert a Java execution trace into a sequence of states that can be analyzed by the model checker Spin (Holzmann, 2003).</text></s>
<s sid="37"><CoreSc1 advantage="None" conceptID="Obj11" novelty="None" type="Obj"/><text>We use runtime monitoring to generate just the Spin oriented execution paths from real software, thereby allowing the formulas to be evaluated by Spin.</text></s>
<s sid="38"><CoreSc1 advantage="None" conceptID="Obj12" novelty="None" type="Obj"/><text>Our work focuses on two major issues of software model checking, analysis of infinite executions and efficient abstraction of execution paths.</text></s>
<s sid="39"><CoreSc1 advantage="None" conceptID="Obj13" novelty="None" type="Obj"/><text>As Spin implements the analysis of LTL formulas by translation to Büchi automata, thanks to our method to feed Java executions to Spin as input, we can check the formulas on Java programs with infinite cycles.</text></s>
<s sid="40"><CoreSc1 advantage="None" conceptID="Obj14" novelty="None" type="Obj"/><text>Furthermore, the Spin stuttering mechanism for dealing with finite execution traces allows us to deal with any kind of program without redefining the original LTL semantics.</text></s>
<s sid="41"><CoreSc1 advantage="None" conceptID="Obj15" novelty="None" type="Obj"/><text>In order to address the second issue, the abstraction of execution paths, our conversion of Java traces into Spin oriented traces is based on two efficient abstraction methods of the full state of the program.</text></s>
<s sid="42"><CoreSc1 advantage="None" conceptID="Mod3" novelty="None" type="Mod"/><text>The counter projection abstracts the Java state by preserving the variables which appear in the LTL formula and adding a counter to distinguish the rest of the state.</text></s>
<s sid="43"><CoreSc1 advantage="None" conceptID="Mod4" novelty="None" type="Mod"/><text>As we do not keep all the information, the counter projection is very efficient at the cost of being useful only for finite executions.</text></s>
<s sid="44"><CoreSc1 advantage="None" conceptID="Mod5" novelty="None" type="Mod"/><text>The hash projection abstracts each Java state with the variables in the formula plus a hash of the whole state.</text></s>
<s sid="45"><CoreSc1 advantage="None" conceptID="Obj16" novelty="None" type="Obj"/><text>The way of constructing the hash makes the probability of conflict for two different states negligible, so we can rely on the Spin algorithm to check LTL based on cycle detection.</text></s>
<s sid="46"><CoreSc1 advantage="None" conceptID="Obj17" novelty="None" type="Obj"/><text>The paper provides a formal study of the correctness of both abstraction methods.</text></s>
<s sid="47"><CoreSc1 advantage="None" conceptID="Met18" novelty="None" type="Met"/><text>We have implemented the proposed approach in TJT, a tool that combines runtime monitoring and model checking and allows Java application developers to debug programs by checking complex requirements represented with temporal logic in a transparent way: the actual Java program is analyzed on the final target platform without additional modifications by the user, while the test execution is managed in the usual integrated development environment.</text></s>
<s sid="48"><CoreSc1 advantage="None" conceptID="Obj18" novelty="None" type="Obj"/><text>Specifically, we combine the Spin model checker (Holzmann, 2003) and the runtime debugging API Java Debug Interface (JDI) (Java Platform Debugger Architecture, xxxx).</text></s>
<s sid="49"><CoreSc1 advantage="None" conceptID="Obj19" novelty="None" type="Obj"/><text>Checking each execution means evaluating a temporal formula representing a failure, over the observable states in the program.</text></s>
<s sid="50"><CoreSc1 advantage="None" conceptID="Obj20" novelty="None" type="Obj"/><text>Such observable states are provided for Spin by a runtime monitoring module built on top of the JDI support in the Java virtual machine.</text></s>
<s sid="51"><CoreSc1 advantage="None" conceptID="Obj21" novelty="None" type="Obj"/><text>Both modules are integrated as a new Eclipse (Eclipse development environment, xxxx) plug-in for automatic debugging.</text></s>
<s sid="52"><CoreSc1 advantage="None" conceptID="Met19" novelty="None" type="Met"/><text>TJT stores the failed executions, so that the programmer can later replay them in Eclipse to locate and fix the bugs.</text></s>
<s sid="53"><CoreSc1 advantage="None" conceptID="Met20" novelty="None" type="Met"/><text>In summary, our method for combining Spin with runtime monitoring offers several advantages to Java developers:•</text></s>
<s sid="54"><CoreSc1 advantage="None" conceptID="Met21" novelty="None" type="Met"/><text>Linear time temporal logic (LTL) is a compact and rich formalism to represent both failures and desirable behaviors regarding a temporally ordered sequence of events and/or conditions to be checked along one execution.</text></s>
<s sid="55"><CoreSc1 advantage="None" conceptID="Met22" novelty="None" type="Met"/><text>Checking the LTL formula naturally considers the history of the execution, providing clear advantages compared with the isolated evaluation of invariants, assertions or just the values returned by methods.</text></s>
•
<s sid="56"><CoreSc1 advantage="None" conceptID="Met23" novelty="None" type="Met"/><text>Model checking algorithms record the history of the failed execution, which we then use to implement a controlled replay to locate and fix the bugs.</text></s>
•
<s sid="57"><CoreSc1 advantage="None" conceptID="Met24" novelty="None" type="Met"/><text>The support for model checking permits the analysis of potentially infinite executions, which may have two origins.</text></s>
<s sid="58"><CoreSc1 advantage="None" conceptID="Met25" novelty="None" type="Met"/><text>On the one hand, they are produced by reactive software like servers or daemons (e.g. FTP servers and web proxies) which are always in execution responding to interactions with an environment (for instance, client processes).</text></s>
<s sid="59"><CoreSc1 advantage="None" conceptID="Met26" novelty="None" type="Met"/><text>On the other hand, bugs may introduce infinite loops that should not happen.</text></s>
<s sid="60"><CoreSc1 advantage="None" conceptID="Met27" novelty="None" type="Met"/><text>In both situations, model checking can be used to locate the cycles and to decide whether they should be considered as failures.</text></s>
•
<s sid="61"><CoreSc1 advantage="None" conceptID="Met28" novelty="None" type="Met"/><text>The use of runtime techniques removes the extra work required to produce model checking oriented models and makes it possible to start the debugging work directly on the programmer's code.</text></s>
<s sid="62"><CoreSc1 advantage="None" conceptID="Met29" novelty="None" type="Met"/><text>We do not intend to perform &quot;full&quot; model checking of Java programs, like Java PathFinder.</text></s>
<s sid="63"><CoreSc1 advantage="None" conceptID="Met30" novelty="None" type="Met"/><text>Full model checking requires a specific virtual machine to control the Java execution in order to carry out the exploration of all possible execution paths, which is time- and memory-consuming.</text></s>
<s sid="64"><CoreSc1 advantage="None" conceptID="Met31" novelty="None" type="Met"/><text>Our approach consists of using only some features of model checking to have a light automated debugging method that helps the programmer to locate errors.</text></s>
<s sid="65"><CoreSc1 advantage="None" conceptID="Met32" novelty="None" type="Met"/><text>Potential errors are described with temporal logic and we use the capability of model checking to check the temporal logic formula in &quot;one execution path&quot;, even if the execution path corresponds to the infinite behavior of a reactive program.</text></s>
<s sid="66"><CoreSc1 advantage="None" conceptID="Met33" novelty="None" type="Met"/><text>This execution path is naturally produced by the execution of the program in the real environment, with the standard Java virtual machine.</text></s>
<s sid="67"><CoreSc1 advantage="None" conceptID="Mot3" novelty="None" type="Mot"/><text>This is a cost-effective application of model checking to program traces that is nevertheless useful for finding faults in concurrent programs and debugging their causes.</text></s>
<s sid="68"><CoreSc1 advantage="None" conceptID="Bac3" novelty="None" type="Bac"/><text>The use of LTL formulas and a reduced set of variables of interest produces traces as counterexamples, which are very valuable when locating bugs (Clarke et al., 2009).</text></s>
<s sid="69"><CoreSc1 advantage="None" conceptID="Bac4" novelty="None" type="Bac"/><text>This is specially relevant in concurrent programs where it is usually more important and difficult to find interleaving of actions that produce faults, than failure-inducing test inputs (Baiardi et al., 1986).</text></s>
<s sid="70"><CoreSc1 advantage="None" conceptID="Obj22" novelty="None" type="Obj"/><text>While the analysis of the traces for finding the root cause is still a manual process, the formulas and the selected variables of interest significantly reduce the size of the traces to analyze (Alipour, 2012).</text></s>
<s sid="71"><CoreSc1 advantage="None" conceptID="Obj23" novelty="None" type="Obj"/><text>This paper is an extension of previous work of ours presented in (Adalid et al., 2012).</text></s>
<s sid="72"><CoreSc1 advantage="None" conceptID="Obj24" novelty="None" type="Obj"/><text>In particular, the description of our approach, its implementation, the experimental results and comparison with related work have been significantly expanded.</text></s>
<s sid="73"><CoreSc1 advantage="None" conceptID="Bac5" novelty="None" type="Bac"/><text>The rest of the paper is organized as follows.</text></s>
<s sid="74"><CoreSc1 advantage="None" conceptID="Met34" novelty="None" type="Met"/><text>Section 2 introduces the use of model checking for debugging Java programs using a real example.</text></s>
<s sid="75"><CoreSc1 advantage="None" conceptID="Obs1" novelty="None" type="Obs"/><text>Section 3 presents the architecture of TJT for combining model checking and Java runtime monitoring.</text></s>
<s sid="76"><CoreSc1 advantage="None" conceptID="Res1" novelty="None" type="Res"/><text>The formalization of the abstraction approach and the preservation results are presented in Section 4.</text></s>
<s sid="77"><CoreSc1 advantage="None" conceptID="Res2" novelty="None" type="Res"/><text>Experimental results of the case studies are summarized in Section 5.</text></s>
<s sid="78"><CoreSc1 advantage="None" conceptID="Goa4" novelty="None" type="Goa"/><text>In Section 6 we compare our tool with related proposals.</text></s>
<s sid="79"><CoreSc1 advantage="None" conceptID="Goa5" novelty="None" type="Goa"/><text>Finally, Section 7 presents some conclusions and points of interest for future work.</text></s>
Model checking for debugging
<s sid="80"><CoreSc1 advantage="None" conceptID="Goa6" novelty="None" type="Goa"/><text>In this section we outline how model checking can be applied for the debugging of real Java programs, as the motivation for the development of our tool.</text></s>
<s sid="81"><CoreSc1 advantage="None" conceptID="Obj25" novelty="None" type="Obj"/><text>We introduce a real example (an open source FTP server) and show several tests where the use of LTL formulas would be useful.</text></s>
<s sid="82"><CoreSc1 advantage="None" conceptID="Obj26" novelty="None" type="Obj"/><text>Then we introduce the semantics of the LTL formulas that we consider in our approach, i.e. the usual one for infinite traces.</text></s>
<s sid="83"><CoreSc1 advantage="None" conceptID="Obj27" novelty="None" type="Obj"/><text>Finally, we discuss how Spin performs the analysis of LTL formulas, translated into Büchi automata.</text></s>
Motivating example
<s sid="84"><CoreSc1 advantage="None" conceptID="Goa7" novelty="None" type="Goa"/><text>To illustrate our proposal we use an FTP server (Sorotokin, xxxx).</text></s>
<s sid="85"><CoreSc1 advantage="None" conceptID="Goa8" novelty="None" type="Goa"/><text>This server understands the usual commands and can handle several concurrent user connections.</text></s>
<s sid="86"><CoreSc1 advantage="None" conceptID="Goa9" novelty="None" type="Goa"/><text>We show several tests that a programmer may want to perform on the code of the server, using LTL formulas where the variables and events of the program can be referenced.</text></s>
<s sid="87"><CoreSc1 advantage="None" conceptID="Met35" novelty="None" type="Met"/><text>The formulas are presented in a formal notation, but using helper functions, such as &quot;loc()&quot; for checking the program counter location, that are available in our tool.</text></s>
<s sid="88"><CoreSc1 advantage="None" conceptID="Res3" novelty="None" type="Res"/><text>It is worth noting that the following three formulas represent liveness properties to be evaluated on potentially infinite executions, and they cannot be handled by other runtime checkers cited in Sections 1 and 6.</text></s>
<s sid="89"><CoreSc1 advantage="None" conceptID="Res4" novelty="None" type="Res"/><text>The code in Fig. 1 corresponds to the main loop in the server.</text></s>
<s sid="90"><CoreSc1 advantage="None" conceptID="Met36" novelty="None" type="Met"/><text>The programmer may want check if the program variables in the loop are correctly cleared between client connections.</text></s>
<s sid="91"><CoreSc1 advantage="None" conceptID="Met37" novelty="None" type="Met"/><text>For instance, to check that the incoming variable is set to null after each iteration we could use the following formula:</text></s>
(1)□ (loc(&quot;FTPServer:285″)→◊(incoming=null))
<s sid="92"><CoreSc1 advantage="None" conceptID="Obs2" novelty="None" type="Obs"/><text>This formula states that, after reaching line 285 of the FTPServer.java file in Fig. 1), the incoming variable should be null at some point in the future.</text></s>
<s sid="93"><CoreSc1 advantage="None" conceptID="Obs3" novelty="None" type="Obs"/><text>Fig. 2 shows the method that handles CWD (change directory) commands.</text></s>
<s sid="94"><CoreSc1 advantage="None" conceptID="Res5" novelty="None" type="Res"/><text>If a client performs an erroneous request the operation should fail, but the server should recover from the exception and return the appropriate error code (line 471).</text></s>
<s sid="95"><CoreSc1 advantage="None" conceptID="Goa10" novelty="None" type="Goa"/><text>The programmer may want to check if this code is reachable when a client misbehaves, using the following formula:</text></s>
(2)□◊(streq(FTPDConnection.status,&quot;CDUP″)→◊(loc(&quot;FTPDConnection:470″)))
<s sid="96"><CoreSc1 advantage="None" conceptID="Goa11" novelty="None" type="Goa"/><text>Testing these and other properties requires the use of controlled mock clients as part of the test fixture.</text></s>
<s sid="97"><CoreSc1 advantage="None" conceptID="Met38" novelty="None" type="Met"/><text>In this case, the client tries to send several CDUP commands (change to parent directory), which are executed as CWD commands in the server and should lead to the behavior described above.</text></s>
<s sid="98"><CoreSc1 advantage="None" conceptID="Met39" novelty="None" type="Met"/><text>The final condition that we want to check deals with thread scheduling and fairness.</text></s>
<s sid="99"><CoreSc1 advantage="None" conceptID="Met40" novelty="None" type="Met"/><text>In addition to synchronization problems, multithreaded programs are prone to fairness issues: some of the threads may take all the CPU time, leaving others starving.</text></s>
<s sid="100"><CoreSc1 advantage="None" conceptID="Met41" novelty="None" type="Met"/><text>The programmer may want to check whether this is a possible outcome under the default scheduling employed by the JVM or under other schedulings that may be forced in the execution.</text></s>
<s sid="101"><CoreSc1 advantage="None" conceptID="Met42" novelty="None" type="Met"/><text>For instance, we can check the fairness between two clients that compete with each other to interact with the FTP server in a loop.</text></s>
(3)□ ((req1→◊resp1) ∧(req2→◊resp2))
<s sid="102"><CoreSc1 advantage="None" conceptID="Met43" novelty="None" type="Met"/><text>For clarity, in the previous formula we used boolean propositions, such as req1, instead of referencing program variables like in the first two formulas.</text></s>
<s sid="103"><CoreSc1 advantage="None" conceptID="Obj28" novelty="None" type="Obj"/><text>These propositions refer to auxiliary boolean variables in the FTP clients, i.e. the clientFTP and clientFTP2 classes.</text></s>
LTL for Java traces
<s sid="104"><CoreSc1 advantage="None" conceptID="Obj29" novelty="None" type="Obj"/><text>In this section, we give a formal characterization of LTL formulas for Java, like the three examples used above.</text></s>
<s sid="105"><CoreSc1 advantage="None" conceptID="Exp1" novelty="None" type="Exp"/><text>Let Prog be a Java program and Var an enumerable set of variable names used by Prog.</text></s>
<s sid="106"><CoreSc1 advantage="None" conceptID="Mod6" novelty="None" type="Mod"/><text>The variables' names may be recursively constructed by appending the name of class members to object identifiers.</text></s>
<s sid="107"><CoreSc1 advantage="None" conceptID="Mod7" novelty="None" type="Mod"/><text>For instance, if o is a reference to an object of class C, and f is an instance variable of C, o.f is the name of the variable recording the value of field f in the object instance o.</text></s>
<s sid="108"><CoreSc1 advantage="None" conceptID="Mod8" novelty="None" type="Mod"/><text>Values of Java variables may belong to a Java primitive data type (int, char, …) or may be a reference if the variable is an object.</text></s>
<s sid="109"><CoreSc1 advantage="None" conceptID="Mod9" novelty="None" type="Mod"/><text>Let A and S be the set of possible memory references and the set of all possible values of Java primitive data types.</text></s>
<s sid="110"><CoreSc1 advantage="None" conceptID="Mod10" novelty="None" type="Mod"/><text>A state of a Java program is a function σ:Var→A∪S that associates each variable with its value.</text></s>
<s sid="111"><CoreSc1 advantage="None" conceptID="Mod11" novelty="None" type="Mod"/><text>Let us denote with States the set of possible states of a Java program Prog.</text></s>
<s sid="112"><CoreSc1 advantage="None" conceptID="Mod12" novelty="None" type="Mod"/><text>Assume that if h is a variable referencing a thread, then σ(h.cp)∈int represents the position of the program counter of h in σ.</text></s>
<s sid="113"><CoreSc1 advantage="None" conceptID="Mod13" novelty="None" type="Mod"/><text>Each possible execution of Prog may be represented as an infinite sequence of states11</text></s>
<s sid="114"><CoreSc1 advantage="None" conceptID="Mod14" novelty="None" type="Mod"/><text>If the sequence is finite, we assume that the last state is infinitely repeated.</text></s>
(4)t=σ0→σ1→σ2→…∈Statesω
<s sid="115"><CoreSc1 advantage="None" conceptID="Mod15" novelty="None" type="Mod"/><text>Statesω being the set of all possible infinite sequences of elements from States, called traces.</text></s>
<s sid="116"><CoreSc1 advantage="None" conceptID="Mod16" novelty="None" type="Mod"/><text>We now recall the syntax and semantics of LTL.</text></s>
<s sid="117"><CoreSc1 advantage="None" conceptID="Mod17" novelty="None" type="Mod"/><text>Let Prop be a set of atomic propositions.</text></s>
<s sid="118"><CoreSc1 advantage="None" conceptID="Mod18" novelty="None" type="Mod"/><text>The set of LTL temporal formulas may be inductively built using the elements of Prop, the standard Boolean operators, and the temporal operators: next &quot;○&quot;, always &quot;□&quot;, eventually &quot;◊&quot;, and until &quot;U&quot;.</text></s>
<s sid="119"><CoreSc1 advantage="None" conceptID="Mod19" novelty="None" type="Mod"/><text>We assume that given a Java state σ, and an atomic proposition p∈Prop, σ⊨p represents the result of evaluating p on σ, that is, σ⊨p holds iff σ satisfies p.</text></s>
<s sid="120"><CoreSc1 advantage="None" conceptID="Mod20" novelty="None" type="Mod"/><text>In what follows, given a (possibly infinite) Java trace t=σ0→σ1⋯, we denote with ti=σi→⋯ the suffix of t starting at state σi.</text></s>
<s sid="121"><CoreSc1 advantage="None" conceptID="Mod21" novelty="None" type="Mod"/><text>Consider p∈Prop, and f and g two LTL formulas.</text></s>
<s sid="122"><CoreSc1 advantage="None" conceptID="Mod22" novelty="None" type="Mod"/><text>We inductively define ⊨ over traces and LTL formulas as follows.1</text></s>
ti⊨p iff σi⊨p.
2
ti⊨¬p iff σi⊭p.
3
<s sid="123"><CoreSc1 advantage="None" conceptID="Obs4" novelty="None" type="Obs"/><text>ti⊨p∨q iff ti⊨p or ti⊨q.</text></s>
4
ti⊨○f iff ti+1⊨f.
5
<s sid="124"><CoreSc1 advantage="None" conceptID="Obs5" novelty="None" type="Obs"/><text>ti⊨□f iff σi⊨f and ti+1⊨□f.</text></s>
6
ti⊨◊f iff ∃j≥i.(tj⊨f).
7
<s sid="125"><CoreSc1 advantage="None" conceptID="Obs6" novelty="None" type="Obs"/><text>ti⊨f U g iff ∃j≥i.(tj⊨g and ∀i≤k&lt;j.[tk⊨f]).</text></s>
<s sid="126"><CoreSc1 advantage="None" conceptID="Obs7" novelty="None" type="Obs"/><text>Note that the operator implies &quot;→&quot; is usually omitted in these rules and transformed into a combination of negation and disjunction.</text></s>
<s sid="127"><CoreSc1 advantage="None" conceptID="Met44" novelty="None" type="Met"/><text>In what follows, we use the same LTL semantics as Spin, without the next operator as usual.</text></s>
<s sid="128"><CoreSc1 advantage="None" conceptID="Met45" novelty="None" type="Met"/><text>Note that in t⊨f, t may be a prefix of a complete Java trace, i.e. it may not be necessary to generate the whole trace in order to check the satisfaction of a property.</text></s>
Checking LTL with SPIN
<s sid="129"><CoreSc1 advantage="None" conceptID="Met46" novelty="None" type="Met"/><text>Spin is a well known model checker for analyzing models of software and other complex systems, defined with the Promela language.</text></s>
<s sid="130"><CoreSc1 advantage="None" conceptID="Met47" novelty="None" type="Met"/><text>Promela contains constructions for describing concurrent and non-deterministic behavior which, combined with the right tool, makes it easier to discover unexpected events or interactions which could be difficult to find in the traditional debugging tools available for programming languages.</text></s>
<s sid="131"><CoreSc1 advantage="None" conceptID="Met48" novelty="None" type="Met"/><text>A Promela model produces a set of possible executions called execution traces or paths.</text></s>
<s sid="132"><CoreSc1 advantage="None" conceptID="Met49" novelty="None" type="Met"/><text>The role of Spin is to look for traces that satisfy or violate a given set of properties.</text></s>
<s sid="133"><CoreSc1 advantage="None" conceptID="Met50" novelty="None" type="Met"/><text>Properties include deadlocks, assertions, code reachability or non-progress loops.</text></s>
<s sid="134"><CoreSc1 advantage="None" conceptID="Met51" novelty="None" type="Met"/><text>However, the most interesting set of properties are complex requirements described with linear temporal logic (LTL) (Manna and Pnueli, 1992).</text></s>
<s sid="135"><CoreSc1 advantage="None" conceptID="Met52" novelty="None" type="Met"/><text>Spin implements the algorithms by Vardi and Wolper (1986) to check LTL properties, which are based in the translation of the negated LTL formula into a Büchi automaton.</text></s>
<s sid="136"><CoreSc1 advantage="None" conceptID="Met53" novelty="None" type="Met"/><text>A Büchi automaton is defined as a standard automaton that recognizes states in a programm to be analysed, but with the addition of final states (also called &quot;accepting states&quot;) that restrict the number of executions allowed by the automaton.</text></s>
<s sid="137"><CoreSc1 advantage="None" conceptID="Met54" novelty="None" type="Met"/><text>In particular, we say that one execution of the program violates the original LTL formula if the corresponding Büchi automaton visits, at least, one of the accepting states infinitely often.</text></s>
<s sid="138"><CoreSc1 advantage="None" conceptID="Met55" novelty="None" type="Met"/><text>This method is well suited to check LTL liveness properties in infinite program executions, and has been adapted in Spin to be used for finite executions as well.</text></s>
<s sid="139"><CoreSc1 advantage="None" conceptID="Obs8" novelty="None" type="Obs"/><text>Fig. 4 contains a simplified graphical representation of the Büchi automaton generated from Formula (3), from the examples above.</text></s>
<s sid="140"><CoreSc1 advantage="None" conceptID="Mod23" novelty="None" type="Mod"/><text>This automaton is executed synchronously with the Java trace, inspecting the Java states to decide which transition (or transitions) must be taken, and stopping when no transition is possible.</text></s>
<s sid="141"><CoreSc1 advantage="None" conceptID="Mod24" novelty="None" type="Mod"/><text>A trace is accepted if it contains a finite sequence of states (a cycle) including an accepting state, which repeats infinitely often.</text></s>
<s sid="142"><CoreSc1 advantage="None" conceptID="Mod25" novelty="None" type="Mod"/><text>Accepting states are represented with a double circle in the figure.</text></s>
<s sid="143"><CoreSc1 advantage="None" conceptID="Mod26" novelty="None" type="Mod"/><text>Using this automata to recognize a given Java execution trace, Spin could find a violation of that formula, i.e. an execution where one client makes the other starve.</text></s>
<s sid="144"><CoreSc1 advantage="None" conceptID="Mod27" novelty="None" type="Mod"/><text>The violation would include the instructions executed in the program, up to the point where the error was found.</text></s>
<s sid="145"><CoreSc1 advantage="None" conceptID="Mod28" novelty="None" type="Mod"/><text>For instance, a simplified trace for a violation of this formula, only including the locations where the variables from the formula change their value, is shown in Fig. 3 (cycle between steps 8 and 10).</text></s>
<s sid="146"><CoreSc1 advantage="None" conceptID="Res6" novelty="None" type="Res"/><text>These variables are initialized on line 25 on both files, they change on line 270 to indicate that a request has been issued, and change again in lines 275 and 280 (of classes clientFTP and clientFTP2, respectively), when said request has been satisfied.</text></s>
<s sid="147"><CoreSc1 advantage="None" conceptID="Obs9" novelty="None" type="Obs"/><text>Others variables can be included in the trace if requested, as well.</text></s>
<s sid="148"><CoreSc1 advantage="None" conceptID="Obs10" novelty="None" type="Obs"/><text>Given a Promela model, Spin performs an exhaustive exploration of its state space.</text></s>
<s sid="149"><CoreSc1 advantage="None" conceptID="Obs11" novelty="None" type="Obs"/><text>Full-state on-the-fly explicit model checking, as implemented in Spin, requires two main data structures to manage model states (see Fig. 5): the stack and the hash table.</text></s>
<s sid="150"><CoreSc1 advantage="None" conceptID="Res7" novelty="None" type="Res"/><text>While performing a depth-first search, Spin stores the states of the current path in the stack.</text></s>
<s sid="151"><CoreSc1 advantage="None" conceptID="Res8" novelty="None" type="Res"/><text>This allows Spin to backtrack to a previous state and also to find cycles, both in the model under verification and in the Büchi automaton which represents the temporal property.</text></s>
<s sid="152"><CoreSc1 advantage="None" conceptID="Res9" novelty="None" type="Res"/><text>The hash table is used to store all unique states visited while exploring the model, so that Spin does not explore the same path twice.</text></s>
<s sid="153"><CoreSc1 advantage="None" conceptID="Res10" novelty="None" type="Res"/><text>The model checking algorithm requires the full representation of each state to be included in both data structures (stack and hash table).</text></s>
<s sid="154"><CoreSc1 advantage="None" conceptID="Res11" novelty="None" type="Res"/><text>This might pose a problem for large models, where the number of states to be stored can be higher than 1020.</text></s>
<s sid="155"><CoreSc1 advantage="None" conceptID="Met56" novelty="None" type="Met"/><text>In order to deal with such large models, Spin has been extended with several optimization techniques, some of which can be used in TJT.</text></s>
<s sid="156"><CoreSc1 advantage="None" conceptID="Met57" novelty="None" type="Met"/><text>Hash-compact (Wolper et al., 1993) reduces the use of memory by compressing the representation of the states without losing information.</text></s>
<s sid="157"><CoreSc1 advantage="None" conceptID="Met58" novelty="None" type="Met"/><text>Bit-state hashing (Holzmann, 1995) represents states as single bits in a hash table, which may lead to a partial analysis of the model in some cases.</text></s>
<s sid="158"><CoreSc1 advantage="None" conceptID="Met59" novelty="None" type="Met"/><text>Currently, work is being carried out in order to obtain parallel versions of Spin that preserve most of these optimizations (Holzmann and Bosnacki, 2007).</text></s>
<s sid="159"><CoreSc1 advantage="None" conceptID="Met60" novelty="None" type="Met"/><text>Finally, there are other strategies that deal with scalability, such as the automatic transformation of the models to implement abstraction methods (Gallardo et al., 2004) or the abstract matching proposed in (de la Cámara et al., 2010).</text></s>
<s sid="160"><CoreSc1 advantage="None" conceptID="Met61" novelty="None" type="Met"/><text>TJT approach for debugging Java executions</text></s>
<s sid="161"><CoreSc1 advantage="None" conceptID="Met62" novelty="None" type="Met"/><text>This section gives an overview of our approach for debugging Java programs using model checking and runtime monitoring.</text></s>
<s sid="162"><CoreSc1 advantage="None" conceptID="Res12" novelty="None" type="Res"/><text>The main idea is to make Spin handle the states produced by Java instead of the states produced by a regular Promela model.</text></s>
<s sid="163"><CoreSc1 advantage="None" conceptID="Res13" novelty="None" type="Res"/><text>In the standard use of Spin, states are produced by the execution of Promela specifications.</text></s>
<s sid="164"><CoreSc1 advantage="None" conceptID="Met63" novelty="None" type="Met"/><text>Such states include all the local and global variables in the Promela specification and other information, such as the program counters of the processes or the contents of the communications channels.</text></s>
<s sid="165"><CoreSc1 advantage="None" conceptID="Met64" novelty="None" type="Met"/><text>The entire space state generated from the Promela code is managed with the stack and hash table in order to check properties such as deadlocks and LTL formulas.</text></s>
<s sid="166"><CoreSc1 advantage="None" conceptID="Met65" novelty="None" type="Met"/><text>In our particular use of Spin, states are produced by the execution of Java programs.</text></s>
<s sid="167"><CoreSc1 advantage="None" conceptID="Met66" novelty="None" type="Met"/><text>However, in order to reuse Spin features transparently, we still use a special Promela specification that is able to transform sequences of Java states into sequences of Promela-like states.</text></s>
<s sid="168"><CoreSc1 advantage="None" conceptID="Met67" novelty="None" type="Met"/><text>Thereby, we can check complex correctness requirements, like LTL properties, on the Java execution.</text></s>
<s sid="169"><CoreSc1 advantage="None" conceptID="Obs12" novelty="None" type="Obs"/><text>Fig. 6 shows an overview of the architecture and the workflow of our tool TJT, which is divided into three modules: the model checking module, the runtime monitoring module and the Eclipse plug-in.</text></s>
<s sid="170"><CoreSc1 advantage="None" conceptID="Res14" novelty="None" type="Res"/><text>The programmer must supply two inputs in this workflow (to the left of the figure): the main entrypoint of the Java program being analyzed and an XML file with the test specification.</text></s>
<s sid="171"><CoreSc1 advantage="None" conceptID="Res15" novelty="None" type="Res"/><text>This main entrypoint may be the real one from the program, or a specific main method associated with a particular test scenario.</text></s>
<s sid="172"><CoreSc1 advantage="None" conceptID="Res16" novelty="None" type="Res"/><text>The test specification includes the correctness requirement: a complex behavior described in a formalism supported by Spin, such as an LTL formula.</text></s>
<s sid="173"><CoreSc1 advantage="None" conceptID="Con1" novelty="None" type="Con"/><text>The user must also declare the objective of the formula, i.e. whether it represents a behavior that should be checked for all traces (desired behavior), none (undesired behavior) or if it is enough for any trace to satisfy it (whether that is desired or undesired behavior is up to the programmer).</text></s>
<s sid="174"><CoreSc1 advantage="None" conceptID="Met68" novelty="None" type="Met"/><text>This specification also contains additional information for carrying out the tests, like the program parameters, and their ranges, for generating test inputs.</text></s>
<s sid="175"><CoreSc1 advantage="None" conceptID="Met69" novelty="None" type="Met"/><text>The model checking module, implemented with Spin and a special Promela template, creates a series of Java Virtual Machines (JVMs) to execute the Java program with all the values considered for the configuration variables.</text></s>
<s sid="176"><CoreSc1 advantage="None" conceptID="Met70" novelty="None" type="Met"/><text>The executions are actually launched and monitored by the runtime monitoring module, which detects the events that are relevant for checking the LTL formula.</text></s>
<s sid="177"><CoreSc1 advantage="None" conceptID="Met71" novelty="None" type="Met"/><text>Each event provokes the creation of a Java state that is sent to the model checking module.</text></s>
<s sid="178"><CoreSc1 advantage="None" conceptID="Met72" novelty="None" type="Met"/><text>Spin processes the information reported by the monitoring module for each execution of the program, and checks the LTL formula.</text></s>
<s sid="179"><CoreSc1 advantage="None" conceptID="Met73" novelty="None" type="Met"/><text>When Spin detects that a Java execution does not match an LTL formula and objective (desired/undesired), it sends information to the Eclipse plug-in in order to show the steps that have led to the failed execution.</text></s>
<s sid="180"><CoreSc1 advantage="None" conceptID="Obj30" novelty="None" type="Obj"/><text>In the following section we discuss model checking in detail, focusing on efficient methods for abstracting the Java states.</text></s>
<s sid="181"><CoreSc1 advantage="None" conceptID="Exp2" novelty="None" type="Exp"/><text>Each Java execution is carried out in the target platform under the control of our runtime monitoring module, which has been implemented in Java using JDI (Java Platform Debugger Architecture, xxxx).</text></s>
<s sid="182"><CoreSc1 advantage="None" conceptID="Exp3" novelty="None" type="Exp"/><text>The monitor and the program being tested run in different JVMs.</text></s>
<s sid="183"><CoreSc1 advantage="None" conceptID="Res17" novelty="None" type="Res"/><text>JDI offers an event based framework, where the application can be notified of certain events in a remote JVM, such as breakpoints, exceptions, changes in object fields or thread states.</text></s>
<s sid="184"><CoreSc1 advantage="None" conceptID="Res18" novelty="None" type="Res"/><text>The monitoring module watches the events relevant to the specified property and sends the information to the model checking module.</text></s>
<s sid="185"><CoreSc1 advantage="None" conceptID="Res19" novelty="None" type="Res"/><text>At present, our tool can check LTL properties on finite and infinite traces, asserts, and deadlocks.</text></s>
<s sid="186"><CoreSc1 advantage="None" conceptID="Res20" novelty="None" type="Res"/><text>The LTL property can reference class variables present in the Java program, thrown exceptions or breakpoints set at specific locations in the code.</text></s>
<s sid="187"><CoreSc1 advantage="None" conceptID="Obj31" novelty="None" type="Obj"/><text>When Java executions are finite, we take advantage of the stuttering mechanism implemented in Spin (Holzmann, 2003), and we assume the semantics derived from considering the last state of the trace repeated forever.</text></s>
<s sid="188"><CoreSc1 advantage="None" conceptID="Met74" novelty="None" type="Met"/><text>So, there are no limitations to using the LTL formulas supported by Spin.</text></s>
<s sid="189"><CoreSc1 advantage="None" conceptID="Met75" novelty="None" type="Met"/><text>In addition, deadlocks can be detected by the monitoring module by checking the status of each thread before processing each event.</text></s>
<s sid="190"><CoreSc1 advantage="None" conceptID="Met76" novelty="None" type="Met"/><text>TJT analyzes each program trace independently.</text></s>
<s sid="191"><CoreSc1 advantage="None" conceptID="Met77" novelty="None" type="Met"/><text>Different traces can be generated by providing information about the input parameters of the program, which will generate different test inputs.</text></s>
<s sid="192"><CoreSc1 advantage="None" conceptID="Met78" novelty="None" type="Met"/><text>These test inputs are currently passed on to the main method of the program as command line arguments.</text></s>
<s sid="193"><CoreSc1 advantage="None" conceptID="Met79" novelty="None" type="Met"/><text>A main method developed specifically for a test may use these arguments to set different parameters in the program, or to execute slightly different test scenarios.</text></s>
<s sid="194"><CoreSc1 advantage="None" conceptID="Met80" novelty="None" type="Met"/><text>In addition, the program may be run more than once with the same test input, in order to produce different schedulings for threaded programs.</text></s>
<s sid="195"><CoreSc1 advantage="None" conceptID="Res21" novelty="None" type="Res"/><text>In connection with this, we are experimenting with the automatic insertion of calls to methods that alter thread scheduling, e.g.</text></s>
<s sid="196"><CoreSc1 advantage="None" conceptID="Res22" novelty="None" type="Res"/><text>yield and sleep, to cover a greater range of program schedulings.</text></s>
<s sid="197"><CoreSc1 advantage="None" conceptID="Obj32" novelty="None" type="Obj"/><text>We have also developed an Eclipse plug-in to make executing tests and reviewing their results more user-friendly.</text></s>
<s sid="198"><CoreSc1 advantage="None" conceptID="Res23" novelty="None" type="Res"/><text>The plug-in includes a form-based editor for creating test specification files, instead of writing error prone XML code.</text></s>
<s sid="199"><CoreSc1 advantage="None" conceptID="Res24" novelty="None" type="Res"/><text>This includes selecting fields to be monitored, setting breakpoints, writing the LTL property to be checked and declaring the test input parameters.</text></s>
<s sid="200"><CoreSc1 advantage="None" conceptID="Res25" novelty="None" type="Res"/><text>Once the specification has been finished, it can be executed within Eclipse and its progress tracked in the TJT console.</text></s>
<s sid="201"><CoreSc1 advantage="None" conceptID="Res26" novelty="None" type="Res"/><text>After the test has finished, a dedicated view shows the erroneous traces that were found, i.e. the execution paths that led to a property violation.</text></s>
<s sid="202"><CoreSc1 advantage="None" conceptID="Obs13" novelty="None" type="Obs"/><text>Clicking on a trace line takes the user to the corresponding Java line of code.</text></s>
<s sid="203"><CoreSc1 advantage="None" conceptID="Obs14" novelty="None" type="Obs"/><text>A screenshot of the plug-in is shown in Fig. 7.</text></s>
<s sid="204"><CoreSc1 advantage="None" conceptID="Obs15" novelty="None" type="Obs"/><text>The tool TJT and several examples can be downloaded from (Adalid et al., xxxx).</text></s>
<s sid="205"><CoreSc1 advantage="None" conceptID="Res27" novelty="None" type="Res"/><text>Implementation with Spin and JDI</text></s>
<s sid="206"><CoreSc1 advantage="None" conceptID="Con2" novelty="None" type="Con"/><text>This section explains our approach, which uses Spin as the core of the model checking module of our debugging tool for Java.</text></s>
<s sid="207"><CoreSc1 advantage="None" conceptID="Res28" novelty="None" type="Res"/><text>In addition to the capability to check properties with Büchi automata, Spin also allows embedding C code in the Promela models, using c_code blocks.</text></s>
<s sid="208"><CoreSc1 advantage="None" conceptID="Con3" novelty="None" type="Con"/><text>These blocks are executed atomically by Spin and may interact with global state variables or call external library functions.</text></s>
<s sid="209"><CoreSc1 advantage="None" conceptID="Con4" novelty="None" type="Con"/><text>The c_expr allows the evaluation of a C expression free from side effects, e.g.</text></s>
<s sid="210"><CoreSc1 advantage="None" conceptID="Res29" novelty="None" type="Res"/><text>to use it as a loop condition.</text></s>
<s sid="211"><CoreSc1 advantage="None" conceptID="Res30" novelty="None" type="Res"/><text>Furthermore, C variables can be treated as if they were part of the global state.</text></s>
<s sid="212"><CoreSc1 advantage="None" conceptID="Res31" novelty="None" type="Res"/><text>Using c_track, existing C variables can be tracked and included in the global state, even as unmatched variables, i.e. they are stored in the stack but not in the hash.</text></s>
<s sid="213"><CoreSc1 advantage="None" conceptID="Obs16" novelty="None" type="Obs"/><text>Unmatched variables are restored when backtracking, but they are not taken into account when deciding whether two states are equal (see (Holzmann, 2003) for details).</text></s>
<s sid="214"><CoreSc1 advantage="None" conceptID="Obs17" novelty="None" type="Obs"/><text>Note that states in the stack contain all the information whereas the hash table contains only part of the information.</text></s>
<s sid="215"><CoreSc1 advantage="None" conceptID="Res32" novelty="None" type="Res"/><text>We take advantage of these C oriented features to communicate Spin with the JDI-based monitor, to represent the Java states in Spin, and to implement our abstraction methods for Java states, explained in Section 3.1.3.</text></s>
<s sid="216"><CoreSc1 advantage="None" conceptID="Res33" novelty="None" type="Res"/><text>As explained above, while Spin is generally used to check program specifications written in its own Promela language, TJT uses a special Promela specification, part of which is shown in Fig. 8, to drive all the automatic debugging work.</text></s>
<s sid="217"><CoreSc1 advantage="None" conceptID="Res34" novelty="None" type="Res"/><text>Such Promela code contains the logic to generate the values for the configuration variables that produce different executions, to communicate with the runtime monitoring module and to check whether a Java execution fails.</text></s>
<s sid="218"><CoreSc1 advantage="None" conceptID="Res35" novelty="None" type="Res"/><text>The code is automatically generated using an initial Promela template and the information provided by the user in the correctness specification file (see Fig. 6).</text></s>
<s sid="219"><CoreSc1 advantage="None" conceptID="Res36" novelty="None" type="Res"/><text>When an LTL formula is present in this file, it is translated into a Büchi automaton, and then included in the resulting Promela specification as a never claim definition.</text></s>
<s sid="220"><CoreSc1 advantage="None" conceptID="Res37" novelty="None" type="Res"/><text>If the formula represents a behavior that must be satisfied in all traces, it is negated first, in order to find counterexamples.</text></s>
<s sid="221"><CoreSc1 advantage="None" conceptID="Res38" novelty="None" type="Res"/><text>The execution of this Promela code by Spin is summarized in Algorithm 1.</text></s>
<s sid="222"><CoreSc1 advantage="None" conceptID="Res39" novelty="None" type="Res"/><text>This algorithm shows how Spin produces and inspects several Java traces, depending on the potential values for the configuration variables in the correctness specification file.</text></s>
<s sid="223"><CoreSc1 advantage="None" conceptID="Res40" novelty="None" type="Res"/><text>For each combination of input values, Spin launches a new execution and then enters a loop to collect the sequence of Java states for that execution, checking the LTL formula and reporting failed executions to the Eclipse plug-in.</text></s>
<s sid="224"><CoreSc1 advantage="None" conceptID="Res41" novelty="None" type="Res"/><text>This is described in more detail in the following sections.</text></s>
Algorithm 1
<s sid="225"><CoreSc1 advantage="None" conceptID="Res42" novelty="None" type="Res"/><text>TJT main loop: Spin executing the Promela code in Fig. 8.</text></s>
<s sid="226"><CoreSc1 advantage="None" conceptID="Res43" novelty="None" type="Res"/><text>while !testInputsExhausted doinput ← generateInput()newExecution(input)step ← 0while !error AND !finished do nextState(step) step ← step + 1end whileif error then storeTrace()end ifend while</text></s>
The main loop
<s sid="227"><CoreSc1 advantage="None" conceptID="Res44" novelty="None" type="Res"/><text>The loop represented in Algorithm 1 actually corresponds to the execution (in Spin) of lines 17 to 22 of the code in Fig. 8.</text></s>
<s sid="228"><CoreSc1 advantage="None" conceptID="Res45" novelty="None" type="Res"/><text>The first two functions, initialization() and createSocket() are executed as if they were a single instruction, using the c_code mechanism.</text></s>
<s sid="229"><CoreSc1 advantage="None" conceptID="Res46" novelty="None" type="Res"/><text>They create all the data and communication structures needed to connect the model checking and the runtime monitoring modules.</text></s>
<s sid="230"><CoreSc1 advantage="None" conceptID="Res47" novelty="None" type="Res"/><text>Note that the communication is done with a socket, so if necessary, e.g.</text></s>
<s sid="231"><CoreSc1 advantage="None" conceptID="Con5" novelty="None" type="Con"/><text>to increase performance, they can run in different computers.</text></s>
<s sid="232"><CoreSc1 advantage="None" conceptID="Goa12" novelty="None" type="Goa"/><text>To ensure interoperability of these two modules in different nodes, we also use standard XDR-based encoding for the data transferred in this socket.</text></s>
<s sid="233"><CoreSc1 advantage="None" conceptID="Res48" novelty="None" type="Res"/><text>Each Java execution corresponds to a possible combination of values for configuration variables defined by the user in the correctness requirement (see Fig. 6).</text></s>
<s sid="234"><CoreSc1 advantage="None" conceptID="Res49" novelty="None" type="Res"/><text>The generation of one combination of values is done by generateConfig().</text></s>
<s sid="235"><CoreSc1 advantage="None" conceptID="Res50" novelty="None" type="Res"/><text>The function execute() launches the Java program being tested with the given configuration values as test input under the supervision of the monitoring module.</text></s>
<s sid="236"><CoreSc1 advantage="None" conceptID="Res51" novelty="None" type="Res"/><text>When the current Java execution finishes, Spin backtracks to generateConfig() to select another set of values for the configuration variables.</text></s>
<s sid="237"><CoreSc1 advantage="None" conceptID="Res52" novelty="None" type="Res"/><text>Then, execute() is again called to run the program under the new test input.</text></s>
<s sid="238"><CoreSc1 advantage="None" conceptID="Res53" novelty="None" type="Res"/><text>This backtracking-based process continues until no more combinations are possible.</text></s>
<s sid="239"><CoreSc1 advantage="None" conceptID="Res54" novelty="None" type="Res"/><text>The result is the exploration of all the Java executions defined by the programmer in the test specification file.</text></s>
<s sid="240"><CoreSc1 advantage="None" conceptID="Res55" novelty="None" type="Res"/><text>Getting new Java states and checking failures</text></s>
<s sid="241"><CoreSc1 advantage="None" conceptID="Res56" novelty="None" type="Res"/><text>The current Java execution trace is reconstructed in Spin thanks to the getNextState() function partially shown in Fig. 9.</text></s>
<s sid="242"><CoreSc1 advantage="None" conceptID="Res57" novelty="None" type="Res"/><text>The next state is either read from the socket with the runtime monitoring module (lines 9 to 16) or retrieved from a list of already visited states in the case of backtracking, as will be explained below.</text></s>
<s sid="243"><CoreSc1 advantage="None" conceptID="Met81" novelty="None" type="Met"/><text>For each new state, we check events such as program termination (line 17) or assertion violations (line 21), which are also communicated through the socket.</text></s>
<s sid="244"><CoreSc1 advantage="None" conceptID="Res58" novelty="None" type="Res"/><text>The current list of failure-related events include a dozen cases.</text></s>
<s sid="245"><CoreSc1 advantage="None" conceptID="Res59" novelty="None" type="Res"/><text>The most interesting analysis is checking LTL properties.</text></s>
<s sid="246"><CoreSc1 advantage="None" conceptID="Res60" novelty="None" type="Res"/><text>Spin checks each execution path using a double depth-first search algorithm that maintains a stack of program states (&quot;Spin States&quot; in Fig. 6).</text></s>
<s sid="247"><CoreSc1 advantage="None" conceptID="Res61" novelty="None" type="Res"/><text>The state of the Büchi automaton, which is used to track the satisfaction of an LTL property, is also stored as part of the global state.</text></s>
<s sid="248"><CoreSc1 advantage="None" conceptID="Con6" novelty="None" type="Con"/><text>Each state si handled by Spin is composed of three components 〈j, ρ(σj), bi〉, where bi is the state of the Büchi automata which is executed synchronously with the system, σj is the current Java state provided by the runtime monitoring module, and ρ is a projection function used to simplify the Java states before being analyzed by Spin.</text></s>
<s sid="249"><CoreSc1 advantage="None" conceptID="Con7" novelty="None" type="Con"/><text>The fact that the indexes of si and σj are not necessarily equal will be explained below.</text></s>
<s sid="250"><CoreSc1 advantage="None" conceptID="Con8" novelty="None" type="Con"/><text>Although the execution of a Java program results in a linear sequence of states, the addition of the Büchi automaton representing the LTL formula may result in several branches that must be explored exhaustively.</text></s>
<s sid="251"><CoreSc1 advantage="None" conceptID="Res62" novelty="None" type="Res"/><text>To support this, variable values received from the runtime monitoring module are first stored in a Java trace stack (&quot;Java Trace&quot; in Fig. 6), and then retrieved from there, as needed (as explained above).</text></s>
<s sid="252"><CoreSc1 advantage="None" conceptID="Res63" novelty="None" type="Res"/><text>Therefore, if Spin backtracks during the search, the Büchi automaton will produce new states but the Java states will be a replay of the previously visited states.</text></s>
<s sid="253"><CoreSc1 advantage="None" conceptID="Res64" novelty="None" type="Res"/><text>Note that we have acknowledged this in Fig. 6 by not necessarily showing the same subindex for the whole state si and the corresponding Java part ρ(σj).</text></s>
<s sid="254"><CoreSc1 advantage="None" conceptID="Res65" novelty="None" type="Res"/><text>Representing Java states inside Spin</text></s>
<s sid="255"><CoreSc1 advantage="None" conceptID="Res66" novelty="None" type="Res"/><text>The main drawback that usually has to be taken into consideration when applying model checking to programming languages is state space explosion: states may be too large and too many to be stored in the memory.</text></s>
<s sid="256"><CoreSc1 advantage="None" conceptID="Res67" novelty="None" type="Res"/><text>Apart from taking advantage of some of the Spin optimization methods described in Section 2, our tool TJT deals with these problems with several novel techniques.</text></s>
<s sid="257"><CoreSc1 advantage="None" conceptID="Res68" novelty="None" type="Res"/><text>The first one consists of selecting the Java states to be sent to the model checking module: we only send those states produced after relevant events in the Java execution.</text></s>
<s sid="258"><CoreSc1 advantage="None" conceptID="Res69" novelty="None" type="Res"/><text>These events include exceptions, deadlocks, update of designated variables, method entry and exit, interactions with monitors, breakpoints, and program termination.</text></s>
<s sid="259"><CoreSc1 advantage="None" conceptID="Res70" novelty="None" type="Res"/><text>The second optimization consists of abstracting (projecting) the Java state when it is converted to a Spin state.</text></s>
<s sid="260"><CoreSc1 advantage="None" conceptID="Res71" novelty="None" type="Res"/><text>The simplest abstraction method generates a Spin state with only some (a small number) of the variables of the current Java state.</text></s>
<s sid="261"><CoreSc1 advantage="None" conceptID="Res72" novelty="None" type="Res"/><text>These variables are stored in C variables, which are tracked by Spin and part of the global state.</text></s>
<s sid="262"><CoreSc1 advantage="None" conceptID="Res73" novelty="None" type="Res"/><text>In this case, the runtime monitoring module only sends the ρ(σj) part of the original σj Java state.</text></s>
<s sid="263"><CoreSc1 advantage="None" conceptID="Con9" novelty="None" type="Con"/><text>These selected variables are those that are relevant for checking the user requirements, like the LTL formula.</text></s>
<s sid="264"><CoreSc1 advantage="None" conceptID="Con10" novelty="None" type="Con"/><text>We include one additional variable, the index j, in the Spin state, which is useful to retrieve the appropriate Java state ρ(σj) when backtracking, as shown in Fig. 9.</text></s>
<s sid="265"><CoreSc1 advantage="None" conceptID="Con11" novelty="None" type="Con"/><text>An alternative, and more complex, abstraction method consists of building an optimized Spin state with all the information in the Java state.</text></s>
<s sid="266"><CoreSc1 advantage="None" conceptID="Con12" novelty="None" type="Con"/><text>Note that this information may be huge, and includes all the variables in objects, thread state and static variables (states ρ(σj) and σj Java would be the same).</text></s>
<s sid="267"><CoreSc1 advantage="None" conceptID="Con13" novelty="None" type="Con"/><text>This state is optimized in two steps.</text></s>
<s sid="268"><CoreSc1 advantage="None" conceptID="Con14" novelty="None" type="Con"/><text>First, we collect strings representing the Java hash value for all objects, threads and static variables.</text></s>
<s sid="269"><CoreSc1 advantage="None" conceptID="Con15" novelty="None" type="Con"/><text>Then, we apply the hashing algorithm MD5 to a canonical concatenation of these strings.</text></s>
<s sid="270"><CoreSc1 advantage="None" conceptID="Con16" novelty="None" type="Con"/><text>The result is extremely efficient in both processing time and size of the final state.</text></s>
<s sid="271"><CoreSc1 advantage="None" conceptID="Met82" novelty="None" type="Met"/><text>This abstraction method, called state hashing, is suitable for checking cycles in Spin, and it can be used to detect cycles in the Java program and to check LTL liveness formulas in infinite executions of Java programs.</text></s>
<s sid="272"><CoreSc1 advantage="None" conceptID="Con17" novelty="None" type="Con"/><text>Both abstraction methods are implemented, making use of the Promela features for embedded C code as explained above.</text></s>
<s sid="273"><CoreSc1 advantage="None" conceptID="Con18" novelty="None" type="Con"/><text>The next section is dedicated to describing and proving the correctness of these abstraction methods supported by TJT.</text></s>
Abstraction of Java traces
<s sid="274"><CoreSc1 advantage="None" conceptID="Obj33" novelty="None" type="Obj"/><text>In this section we formalize the Java state abstractions mentioned in previous section and which enable the analysis of infinite Java execution traces.</text></s>
Definitions
<s sid="275"><CoreSc1 advantage="None" conceptID="Res74" novelty="None" type="Res"/><text>A Java trace t, as defined in Section 2.2, represents a possible Java execution of a given program.</text></s>
<s sid="276"><CoreSc1 advantage="None" conceptID="Res75" novelty="None" type="Res"/><text>However, sometimes we do not intend for Spin to analyze complete Java traces.</text></s>
<s sid="277"><CoreSc1 advantage="None" conceptID="Res76" novelty="None" type="Res"/><text>Instead, Spin will be given projections of traces, some Java states are discarded, and the states that are transferred are simplified.</text></s>
<s sid="278"><CoreSc1 advantage="None" conceptID="Res77" novelty="None" type="Res"/><text>Only the part of the state that is involved in the evaluation of the formula is transferred to the model checker.</text></s>
<s sid="279"><CoreSc1 advantage="None" conceptID="Obj34" novelty="None" type="Obj"/><text>We now describe how the projection of Java states is constructed and the correctness relation between the evaluation results regarding the original traces, and the projected ones on Spin.</text></s>
<s sid="280"><CoreSc1 advantage="None" conceptID="Mod29" novelty="None" type="Mod"/><text>In order to simplify the presentation below, we assume that the set of possible data values of program variables, A∪S contains the integer numbers.</text></s>
Definition 1
<s sid="281"><CoreSc1 advantage="None" conceptID="Mod30" novelty="None" type="Mod"/><text>[Projection] Given a subset of variables V⊆Var, we define the projection of a state σ onto V as the function ρV(σ):V→A∪S such that ∀v∈V.ρV(σ)(v)=σ(v).</text></s>
<s sid="282"><CoreSc1 advantage="None" conceptID="Mod31" novelty="None" type="Mod"/><text>Now, given a Java trace t=σ0→σ1→σ2→…, we define the projection of t onto V⊆Var as(5)ρV(t)=ρV(σ0)→ρV(σ1)→ρV(σ2)→…</text></s>
<s sid="283"><CoreSc1 advantage="None" conceptID="Obs18" novelty="None" type="Obs"/><text>Fig. 10 shows the projection ρV of a trace.</text></s>
<s sid="284"><CoreSc1 advantage="None" conceptID="Res78" novelty="None" type="Res"/><text>Observe that V divides each state σi into two parts: the part concerning the variables of V in state i (Vi), and the rest (resti).</text></s>
<s sid="285"><CoreSc1 advantage="None" conceptID="Res79" novelty="None" type="Res"/><text>The projection simply takes the first part from each state and ignores the rest.</text></s>
<s sid="286"><CoreSc1 advantage="None" conceptID="Res80" novelty="None" type="Res"/><text>The effect of this projection is similar to that of the &quot;cone of influence&quot; technique (Clarke et al., 1999).</text></s>
<s sid="287"><CoreSc1 advantage="None" conceptID="Con19" novelty="None" type="Con"/><text>However, while this technique simplifies the code to include only variables which are on the set V (or which influence them) before executing it, we execute the program as is and then simplify (i.e. project) the generated trace.</text></s>
<s sid="288"><CoreSc1 advantage="None" conceptID="Obs19" novelty="None" type="Obs"/><text>We do not automatically include variables not in V, though.</text></s>
<s sid="289"><CoreSc1 advantage="None" conceptID="Res81" novelty="None" type="Res"/><text>As a general result of this definition of projection, if all the variables required for evaluating an LTL formula are present in the projection, the evaluation of the formula is not affected.</text></s>
<s sid="290"><CoreSc1 advantage="None" conceptID="Res82" novelty="None" type="Res"/><text>Let f be an LTL formula and let us denote the set of variables in f as var(f).</text></s>
Proposition 1
<s sid="291"><CoreSc1 advantage="None" conceptID="Res83" novelty="None" type="Res"/><text>Given a Java trace t, a temporal formula f and a subset of program variables V⊆Var, if var(f)⊆V then(6)t⊨f⇔ρV(t)⊨f,</text></s>
<s sid="292"><CoreSc1 advantage="None" conceptID="Res84" novelty="None" type="Res"/><text>As described in Section 3, temporal formulas can be used in debugging with different use cases.</text></s>
<s sid="293"><CoreSc1 advantage="None" conceptID="Res85" novelty="None" type="Res"/><text>In contrast to model checking, testing works with a subset of program traces instead of every possible trace.</text></s>
<s sid="294"><CoreSc1 advantage="None" conceptID="Res86" novelty="None" type="Res"/><text>Test cases may pass when a property is checked in all, some or none of the given traces.</text></s>
<s sid="295"><CoreSc1 advantage="None" conceptID="Res87" novelty="None" type="Res"/><text>Thus we extend ⊨ for sets of traces and the ∀ and ∃ quantifier operators.</text></s>
Definition 2
<s sid="296"><CoreSc1 advantage="None" conceptID="Res88" novelty="None" type="Res"/><text>Given a temporal formula f and a set of traces T,(7)T⊨∀f⇔∀t∈T.t⊨f(8)T⊨∄f⇔∄t∈T.t⊨f(9)T⊨∃f⇔∃t∈T.t⊨f</text></s>
Dealing with cycles
<s sid="297"><CoreSc1 advantage="None" conceptID="Con20" novelty="None" type="Con"/><text>Due to the elimination of most program variables in the projected states, it is very likely that a projected trace ρV(t) contains many consecutive repeated states.</text></s>
<s sid="298"><CoreSc1 advantage="None" conceptID="Con21" novelty="None" type="Con"/><text>This represents a problem for the model checker since it can erroneously deduce that the original trace has a cycle due to the double depth search (DDS) algorithm used by Spin to check properties.</text></s>
<s sid="299"><CoreSc1 advantage="None" conceptID="Con22" novelty="None" type="Con"/><text>Note that this does not contradict Proposition 1, since in this result we do not assume any particular algorithm to evaluate the property on the projected trace.</text></s>
<s sid="300"><CoreSc1 advantage="None" conceptID="Mod32" novelty="None" type="Mod"/><text>In the following sections, we use relation ⊨s to distinguish between the LTL evaluation carried out by Spin through the DDS algorithm, and the satisfaction relation ⊨ defined above.</text></s>
<s sid="301"><CoreSc1 advantage="None" conceptID="Obj35" novelty="None" type="Obj"/><text>To correctly eliminate consecutive repeated states in traces, we propose two different techniques that we discuss in the following subsections, along with the corresponding preservation results.</text></s>
State counting
<s sid="302"><CoreSc1 advantage="None" conceptID="Res89" novelty="None" type="Res"/><text>A simple solution is to add a new counter variable count to the set of visible variables V.</text></s>
<s sid="303"><CoreSc1 advantage="None" conceptID="Res90" novelty="None" type="Res"/><text>This counter is increased for every new state, thus removing the possibility that Spin erroneously finds a non-existing cycle.</text></s>
<s sid="304"><CoreSc1 advantage="None" conceptID="Res91" novelty="None" type="Res"/><text>Observe that this also precludes Spin from detecting real cycles present in the Java program.</text></s>
<s sid="305"><CoreSc1 advantage="None" conceptID="Bac6" novelty="None" type="Bac"/><text>This case will be discussed in the following subsection.</text></s>
<s sid="306"><CoreSc1 advantage="None" conceptID="Res92" novelty="None" type="Res"/><text>We extend the notion of trace projection given in Definition 1, by adding the state counter variable as follows:</text></s>
Definition 3
<s sid="307"><CoreSc1 advantage="None" conceptID="Res93" novelty="None" type="Res"/><text>[Counter projection of states and traces] Given a subset of visible variables V⊆Var and a fresh variable count∉Var, we define the ith counter projection of a state σ:V→A∪S as ρVi(σ):V∪{count}→A∪S defined as ρVi(σ)(v)=ρV(σ)(v), for all v∈V, and ρVi(σ)(count)=i.</text></s>
<s sid="308"><CoreSc1 advantage="None" conceptID="Res94" novelty="None" type="Res"/><text>Variable count is called state counter of ρVi(σ).</text></s>
<s sid="309"><CoreSc1 advantage="None" conceptID="Res95" novelty="None" type="Res"/><text>Sometimes, we will represent function ρVi(σ) as the pair 〈ρV(σ), i〉.</text></s>
<s sid="310"><CoreSc1 advantage="None" conceptID="Res96" novelty="None" type="Res"/><text>Now, given a Java trace t=σ0→σ1⋯ we define the counter projection of t onto V, ρVc, by projecting each state σi with the i-th counter projection, that is, ρVc(t)=ρV0(σ0)→ρV1(σ1)⋯.</text></s>
<s sid="311"><CoreSc1 advantage="None" conceptID="Obs20" novelty="None" type="Obs"/><text>It is worth noting that there is a slight difference in the notation of the counter projection of a trace (ρVc) and the counter projection of a state (ρVi).</text></s>
<s sid="312"><CoreSc1 advantage="None" conceptID="Obs21" novelty="None" type="Obs"/><text>Notice that the former includes a c superscript, while the latter includes the value of the counter itself as a superscript.</text></s>
<s sid="313"><CoreSc1 advantage="None" conceptID="Obs22" novelty="None" type="Obs"/><text>Fig. 11 shows the projection of a trace with the addition of the state counter.</text></s>
State hashing
<s sid="314"><CoreSc1 advantage="None" conceptID="Hyp1" novelty="None" type="Hyp"/><text>In this section, we assume that Java states have a canonical representation, which makes it possible to safely check whether two states are equal.</text></s>
<s sid="315"><CoreSc1 advantage="None" conceptID="Con23" novelty="None" type="Con"/><text>We know that canonical representation of states in languages that make an intensive use of dynamic memory is not trivial.</text></s>
<s sid="316"><CoreSc1 advantage="None" conceptID="Con24" novelty="None" type="Con"/><text>We are currently evaluating an extension of the memory representation described in (Gallardo et al., 2009).</text></s>
<s sid="317"><CoreSc1 advantage="None" conceptID="Con25" novelty="None" type="Con"/><text>But a detailed explanation of this extension would exceed the goals of this paper.</text></s>
<s sid="318"><CoreSc1 advantage="None" conceptID="Con26" novelty="None" type="Con"/><text>Besides, in this section, the actual representation is not relevant for the results obtained.</text></s>
<s sid="319"><CoreSc1 advantage="None" conceptID="Con27" novelty="None" type="Con"/><text>We only need to assume that given two logically equal Java states σ1 and σ2, there exists a matching algorithm able to check that they are equal.</text></s>
<s sid="320"><CoreSc1 advantage="None" conceptID="Con28" novelty="None" type="Con"/><text>We use a proper hash function h:State→int to represent each state in the projected trace.</text></s>
<s sid="321"><CoreSc1 advantage="None" conceptID="Con29" novelty="None" type="Con"/><text>It is worth noting that as not all of the Java states σ have to be stored (we only project the visible part ρV(σ)), we may assume that function h is very precise, producing a minimum number of collisions.</text></s>
<s sid="322"><CoreSc1 advantage="None" conceptID="Con30" novelty="None" type="Con"/><text>That is, h(σ1)=h(σ2)⇒σ1=σ2, with a high degree of probability.</text></s>
<s sid="323"><CoreSc1 advantage="None" conceptID="Con31" novelty="None" type="Con"/><text>To put this into perspective, we present a very brief study of the MD5 hash function, which we used in our implementation.</text></s>
<s sid="324"><CoreSc1 advantage="None" conceptID="Con32" novelty="None" type="Con"/><text>This function transforms the given input (in this case a string representation of the Java state) into a 128-bit digest.</text></s>
<s sid="325"><CoreSc1 advantage="None" conceptID="Con33" novelty="None" type="Con"/><text>Thus, there are 2128 (or about 3.3×1038) possible values of this function.</text></s>
<s sid="326"><CoreSc1 advantage="None" conceptID="Con34" novelty="None" type="Con"/><text>We are interested in the likelyhood of a birthday attack (Schneier, 1995), i.e. the probability of a collision between any two states belonging to the same trace or, conversely, in the number of different states that could be generated before a collision is found with a given probability.</text></s>
<s sid="327"><CoreSc1 advantage="None" conceptID="Con35" novelty="None" type="Con"/><text>For instance, if we assume that a probability 10-12 is enough for our analysis, this number is approximately 2.6×1013.</text></s>
<s sid="328"><CoreSc1 advantage="None" conceptID="Res97" novelty="None" type="Res"/><text>Given a state size of 64 bytes (a reasonable assumption, see Table 2 in Section 5), about 1.5×106 gigabytes of memory would be required to store this number of states.</text></s>
<s sid="329"><CoreSc1 advantage="None" conceptID="Con36" novelty="None" type="Con"/><text>This is well beyond what current computers carry, and therefore computationally unfeasible.</text></s>
<s sid="330"><CoreSc1 advantage="None" conceptID="Con37" novelty="None" type="Con"/><text>Thus, we conclude that such a hash function is adequate for our uses.</text></s>
<s sid="331"><CoreSc1 advantage="None" conceptID="Res98" novelty="None" type="Res"/><text>Now, we extend the notion of state projection given in Definition 1, by adding the codification of the whole state (including the non-visible part) as follows:</text></s>
Definition 4
<s sid="332"><CoreSc1 advantage="None" conceptID="Res99" novelty="None" type="Res"/><text>[Hash projection] Given a subset of visible variables V⊆Var, and a fresh variable hash∉Var, we define the hash projection ρVh(σ) of a state σ onto V using the hash function h as ρVh(σ):V∪{hash}→S∪A as follows.</text></s>
<s sid="333"><CoreSc1 advantage="None" conceptID="Res100" novelty="None" type="Res"/><text>ρVh(σ)(v)=ρV(σ)(v), for all v∈V, and ρVh(σ)(hash)=h(σ).</text></s>
<s sid="334"><CoreSc1 advantage="None" conceptID="Res101" novelty="None" type="Res"/><text>We usually represent function ρVh(σ) as pair 〈ρV(σ), h(σ)〉.</text></s>
<s sid="335"><CoreSc1 advantage="None" conceptID="Obs23" novelty="None" type="Obs"/><text>Now, given a Java trace t=σ0→σ1⋯ we define the hash projection of t onto V, ρVh, by projecting each state σi with the hash projection, that is, ρVh(t)=ρVh(σ0)→ρVh(σ1)⋯.</text></s>
<s sid="336"><CoreSc1 advantage="None" conceptID="Obs24" novelty="None" type="Obs"/><text>Fig. 12 shows the projection of a trace with the addition of the state hash.</text></s>
<s sid="337"><CoreSc1 advantage="None" conceptID="Res102" novelty="None" type="Res"/><text>Only projected states ρVh(σ) are transferred to Spin.</text></s>
<s sid="338"><CoreSc1 advantage="None" conceptID="Res103" novelty="None" type="Res"/><text>If the model checker detects that two states ρVh(σ1) and ρVh(σ2) are equal, then we can infer that the original states σ1 and σ2 are equal with a high degree of probability.</text></s>
Preservation of results
<s sid="339"><CoreSc1 advantage="None" conceptID="Res104" novelty="None" type="Res"/><text>We now discuss how the results are preserved regarding the satisfaction of temporal properties in Java and in the projected traces.</text></s>
<s sid="340"><CoreSc1 advantage="None" conceptID="Mod33" novelty="None" type="Mod"/><text>Here we assume that the algorithm for checking the satisfaction of a property uses the double depth search algorithm as implemented by Spin.</text></s>
<s sid="341"><CoreSc1 advantage="None" conceptID="Met83" novelty="None" type="Met"/><text>We focus on the preservation of results using the counter and hash projections as described in Definitions 3 and 4, respectively, which were introduced to deal with cycles as required by the model checking algorithm implemented by Spin.</text></s>
Proposition 2
<s sid="342"><CoreSc1 advantage="None" conceptID="Res105" novelty="None" type="Res"/><text>Given a temporal formula f using only the eventually &quot;◊&quot; and until &quot;U&quot; temporal operators, if V=var(f)⊆Var then(10)t⊨f⇔ρVc(t)⊨sf.</text></s>
<s sid="343"><CoreSc1 advantage="None" conceptID="Res106" novelty="None" type="Res"/><text>Counter projection ρVc does not permit Spin to detect cycles in the projected trace.</text></s>
<s sid="344"><CoreSc1 advantage="None" conceptID="Res107" novelty="None" type="Res"/><text>Thus, properties that do not require the detection of cycles (i.e. those that use only operators eventually &quot;◊&quot; and until &quot;U&quot;) can be properly checked over this projection.</text></s>
<s sid="345"><CoreSc1 advantage="None" conceptID="Res108" novelty="None" type="Res"/><text>In contrast, since properties that use the always &quot;□&quot; temporal operator are checked by Spin by searching for cycles, they cannot be analyzed over ρVc(t).</text></s>
Proposition 3
<s sid="346"><CoreSc1 advantage="None" conceptID="Res109" novelty="None" type="Res"/><text>Given a temporal formula f and a set of variables V, if V=var(f)⊆Var then(11)ρVh(t)⊨sf⇒t⊨fwith the degree of probability allowed by h, and(12)t⊨f⇒ρVh(t)⊨sf.</text></s>
<s sid="347"><CoreSc1 advantage="None" conceptID="Res110" novelty="None" type="Res"/><text>This theorem asserts that any temporal formula which is satisfied in the original Java trace t, is also satisfied in the hash projection of the trace.</text></s>
<s sid="348"><CoreSc1 advantage="None" conceptID="Res111" novelty="None" type="Res"/><text>The converse, while generally true for practical purposes, is limited by the quality of the hash function h.</text></s>
<s sid="349"><CoreSc1 advantage="None" conceptID="Res112" novelty="None" type="Res"/><text>In addition to projecting the variables in f, as established in Proposition 1, the hash projection includes a variable computed by h that identifies the global state and is used to detect cycles in the trace.</text></s>
Folding consecutive repeated states
<s sid="350"><CoreSc1 advantage="None" conceptID="Hyp2" novelty="None" type="Hyp"/><text>In this section we propose an optimization approach to minimize the number of states of the projected trace that need to be generated and transferred to Spin.</text></s>
<s sid="351"><CoreSc1 advantage="None" conceptID="Mod34" novelty="None" type="Mod"/><text>To do this, we slightly modify transition relation → defined above by labeling transitions as follows.</text></s>
<s sid="352"><CoreSc1 advantage="None" conceptID="Mod35" novelty="None" type="Mod"/><text>A Java trace is now given by a sequence of states</text></s>
<s sid="353"><CoreSc1 advantage="None" conceptID="Mod36" novelty="None" type="Mod"/><text>(13)t=σ0→M1σ1→M2σ2→M3…where each label Mi⊆Var is the set of variables which are modified by the Java sentence that produced the transition.</text></s>
<s sid="354"><CoreSc1 advantage="None" conceptID="Met84" novelty="None" type="Met"/><text>Recall that counter and hash projections of Java traces t (ρVc(t) and ρVh(t)) discard all program variables except the ones in V, which are the only ones needed to check a temporal formula f, (V=var(f)), while the rest of the state is collapsed into a single variable.</text></s>
<s sid="355"><CoreSc1 advantage="None" conceptID="Met85" novelty="None" type="Met"/><text>However, Spin does not need to know about states in which none of the variables in V change as they do not affect the evaluation of temporal formulas as described in Propositions 2 and 3.</text></s>
<s sid="356"><CoreSc1 advantage="None" conceptID="Con38" novelty="None" type="Con"/><text>Thus, we propose removing these states from the final projection given to Spin.</text></s>
<s sid="357"><CoreSc1 advantage="None" conceptID="Res113" novelty="None" type="Res"/><text>We call this removed states folded states.</text></s>
Definition 5
<s sid="358"><CoreSc1 advantage="None" conceptID="Res114" novelty="None" type="Res"/><text>[Folded projection] Given a Java trace t=σ0→M1σ1→M2⋯ as defined in (13), we define the folded counter/hash projection of t onto V⊆Var as(14)ϕVc(t)=ρV0(σi0)→ρV1(σi1)→ρV2(σi2)→…and(15)ϕVh(t)=ρVh(σi0)→ρVh(σi1)→ρVh(σi2)→…such that:1</text></s>
index i0=0,
2
for all k≥0, ik&lt;ik+1
3
for all k≥1, Mik∩V≠∅.
4
<s sid="359"><CoreSc1 advantage="None" conceptID="Res115" novelty="None" type="Res"/><text>if there exists j&gt;0 such that ∀k≥0, ik≠j, then Mj∩V=∅</text></s>
<s sid="360"><CoreSc1 advantage="None" conceptID="Res116" novelty="None" type="Res"/><text>That is, we only project to Spin those states where some visible variable has just been modified.</text></s>
<s sid="361"><CoreSc1 advantage="None" conceptID="Res117" novelty="None" type="Res"/><text>However, this definition of folding is not enough to allow a precise cycle detection, which was the main reason for introducing the hash projection.</text></s>
<s sid="362"><CoreSc1 advantage="None" conceptID="Res118" novelty="None" type="Res"/><text>If an infinite cycle is located in the folded states, Spin will not be informed of any new Java state, and thus Spin will not be aware that the Java program is going to loop endlessly in those states.</text></s>
<s sid="363"><CoreSc1 advantage="None" conceptID="Res119" novelty="None" type="Res"/><text>To avoid this, we define the limited folding of a hash projection, where the word limited means that the folding between two non-folded states is never greater than a given limit.</text></s>
<s sid="364"><CoreSc1 advantage="None" conceptID="Res120" novelty="None" type="Res"/><text>After a specified number of folded Java states, we project the next Java state, even that state did not change any of the variables v∈V.</text></s>
<s sid="365"><CoreSc1 advantage="None" conceptID="Con39" novelty="None" type="Con"/><text>An implementation may choose to use a timer as a limit instead of a state counter, which may be more practical and would not affect the results given below.</text></s>
<s sid="366"><CoreSc1 advantage="None" conceptID="Con40" novelty="None" type="Con"/><text>This projection may be further refined in the implementation with an adaptive limit, e.g.</text></s>
<s sid="367"><CoreSc1 advantage="None" conceptID="Res121" novelty="None" type="Res"/><text>a limit which decreases progressively.</text></s>
Definition 6
<s sid="368"><CoreSc1 advantage="None" conceptID="Res122" novelty="None" type="Res"/><text>[Limited folded hash projection] Given a Java trace t=σ0→M1σ1→M2⋯ as defined in (13) and a limit l&gt;0, we define the limited folded hash projection of t onto V⊆Var as(16)ϕV,lh(t)=ρVh(σj0)→ρVh(σj1)→ρVh(σj2)→…such that:1</text></s>
index j0=0,
2
<s sid="369"><CoreSc1 advantage="None" conceptID="Res123" novelty="None" type="Res"/><text>for all k≥0, jk&lt;jk+1, and</text></s>
3
<s sid="370"><CoreSc1 advantage="None" conceptID="Con41" novelty="None" type="Con"/><text>for all k≥1, either Mjk∩V≠∅, or, the distance between jk and jk-1 is limit l, that is jk-jk-1=l,</text></s>
4
<s sid="371"><CoreSc1 advantage="None" conceptID="Con42" novelty="None" type="Con"/><text>if there exists j&gt;0 such that ∀k≥0, jk≠j, then Mj∩V=∅.</text></s>
<s sid="372"><CoreSc1 advantage="None" conceptID="Con43" novelty="None" type="Con"/><text>Although we could define a limited folded counter projection in a similar fashion, there would be no benefit in doing so, since the counter prevents any kind of cycle from being detected.</text></s>
<s sid="373"><CoreSc1 advantage="None" conceptID="Obs25" novelty="None" type="Obs"/><text>Fig. 13 shows an example of a limited folded hash projection, with limit l=1.</text></s>
<s sid="374"><CoreSc1 advantage="None" conceptID="Res124" novelty="None" type="Res"/><text>This limit ensures that only one state can be folded consecutively.</text></s>
<s sid="375"><CoreSc1 advantage="None" conceptID="Res125" novelty="None" type="Res"/><text>In the figure, a bold Mi label indicates that Mi∩V≠∅, i.e. that transition modifies one or more variables of the set V.</text></s>
<s sid="376"><CoreSc1 advantage="None" conceptID="Res126" novelty="None" type="Res"/><text>In this example, the limit forces the projection of states σ4 and σ6, which should have been folded, resulting in the projected states σi2 and σi3.</text></s>
Preservation of results
<s sid="377"><CoreSc1 advantage="None" conceptID="Res127" novelty="None" type="Res"/><text>We now show how the results are preserved with these projections.</text></s>
Proposition 4
<s sid="378"><CoreSc1 advantage="None" conceptID="Res128" novelty="None" type="Res"/><text>Given a temporal formula f using the eventually &quot;◊&quot; and until &quot;U&quot; temporal operators, and a set of variables V, if var(f)⊆V⊆Var then(17)t⊨f⇔ϕVc(t)⊨sf.</text></s>
<s sid="379"><CoreSc1 advantage="None" conceptID="Res129" novelty="None" type="Res"/><text>This result is not affected by the folding in the projection, because (i) the folded states are not required to evaluate the boolean tests of the temporal formula, and (ii) cycle detection is not affected since it is not supported by the counter projection, as discussed in Section 4.2.3.</text></s>
Proposition 5
<s sid="380"><CoreSc1 advantage="None" conceptID="Res130" novelty="None" type="Res"/><text>Given a temporal formula f and a set of variables V, if var(f)⊆V⊆Var then(18)ϕV,lh(t)⊨sf⇒t⊨fwith the degree of probability allowed by h, and(19)t⊨f⇒ϕV,lh(t)⊨sf.</text></s>
<s sid="381"><CoreSc1 advantage="None" conceptID="Res131" novelty="None" type="Res"/><text>Again, this result is not affected by the folding in the projection thanks to the limit, which covers the detection of cycles in (otherwise) folded states.</text></s>
<s sid="382"><CoreSc1 advantage="None" conceptID="Res132" novelty="None" type="Res"/><text>If there is a cycle in an infinite sequence of states the transition labels of which are Mi∩V=∅, the limited folding only removes a subset of the states.</text></s>
<s sid="383"><CoreSc1 advantage="None" conceptID="Res133" novelty="None" type="Res"/><text>Since a cycle is by definition a finite sequence of states, it is guaranteed that eventually two equal states will be projected, and thus the cycle will be detected.</text></s>
Experimental results
<s sid="384"><CoreSc1 advantage="None" conceptID="Res134" novelty="None" type="Res"/><text>TJT has been successfully used with real Java applications.</text></s>
<s sid="385"><CoreSc1 advantage="None" conceptID="Obj36" novelty="None" type="Obj"/><text>In this section, we show some example properties evaluated on public open source Java projects, some of which were also evaluated in (Fu et al., 2005).</text></s>
<s sid="386"><CoreSc1 advantage="None" conceptID="Res135" novelty="None" type="Res"/><text>These applications include three servers: FTP, NFS and HTTP.</text></s>
<s sid="387"><CoreSc1 advantage="None" conceptID="Obj37" novelty="None" type="Obj"/><text>It is worth noting that, in order to test these servers, we had to implement mock clients to simulate the behavior required by each test.</text></s>
<s sid="388"><CoreSc1 advantage="None" conceptID="Obj38" novelty="None" type="Obj"/><text>In addition, we studied the elevator problem, a typical example of control software.</text></s>
<s sid="389"><CoreSc1 advantage="None" conceptID="Res136" novelty="None" type="Res"/><text>The temporal formulas used in each test have been gathered together in Table 1.</text></s>
<s sid="390"><CoreSc1 advantage="None" conceptID="Res137" novelty="None" type="Res"/><text>Note that all formulas, with the exception of F4 and F6, represent liveness properties, and, in the case of programs with infinite executions, they can only be analyzed with runtime checkers that implement mechanisms like the cycle detection considered in this paper (see Vardi and Wolper (1986)).</text></s>
FTPD server (http://peter.sorotokin.com/ftpd).
<s sid="391"><CoreSc1 advantage="None" conceptID="Res138" novelty="None" type="Res"/><text>The first application is the FTP server described in Section 2.1.</text></s>
<s sid="392"><CoreSc1 advantage="None" conceptID="Res139" novelty="None" type="Res"/><text>We tested the three formulas from Section 2.1, shown in Table 1 as formulas F1, F2 and F3, and two additional ones.</text></s>
<s sid="393"><CoreSc1 advantage="None" conceptID="Res140" novelty="None" type="Res"/><text>Of all these formulas, F2 was prepared to uncover a manually introduced bug, while the rest were analyzed over the normal server.</text></s>
<s sid="394"><CoreSc1 advantage="None" conceptID="Res141" novelty="None" type="Res"/><text>F4 deals with security in the server, checking that no user is able to perform a STOR operation without being authenticated first.</text></s>
<s sid="395"><CoreSc1 advantage="None" conceptID="Res142" novelty="None" type="Res"/><text>Finally, formula F5 is a twist on F1, but using the temporal operator &quot;until&quot;.</text></s>
<s sid="396"><CoreSc1 advantage="None" conceptID="Con44" novelty="None" type="Con"/><text>Using this formula we check that, at some point, the variable incoming, which holds the socket just opened for attending the client, should be non-null until a specific thread is created for attending that client.</text></s>
Elevator problem.
<s sid="397"><CoreSc1 advantage="None" conceptID="Res143" novelty="None" type="Res"/><text>The next application is a typical example of concurrency: a shared resource (an elevator) and several clients trying to use it at the same time.</text></s>
<s sid="398"><CoreSc1 advantage="None" conceptID="Res144" novelty="None" type="Res"/><text>This example has been implemented in Java using locks and conditions.</text></s>
Figs.
<s sid="399"><CoreSc1 advantage="None" conceptID="Res145" novelty="None" type="Res"/><text>14 and 15 show part of the elevator and client code, respectively.</text></s>
<s sid="400"><CoreSc1 advantage="None" conceptID="Res146" novelty="None" type="Res"/><text>We can use a temporal formula to check that the elevator does not wait for clients if it is not free (F6).</text></s>
<s sid="401"><CoreSc1 advantage="None" conceptID="Obj39" novelty="None" type="Obj"/><text>For the sake of illustration, we tested this formula to debug an incorrect implementation, where the wait condition of the server is wrong (line 3 in Fig. 14).</text></s>
<s sid="402"><CoreSc1 advantage="None" conceptID="Met86" novelty="None" type="Met"/><text>We also used this incorrect implementation to test the opposite condition (F7).</text></s>
<s sid="403"><CoreSc1 advantage="None" conceptID="Met87" novelty="None" type="Met"/><text>In both cases, the generated traces led us to this manually introduced error.</text></s>
NFS server (http://www.void.org/ steven/jnfs/).
<s sid="404"><CoreSc1 advantage="None" conceptID="Met88" novelty="None" type="Met"/><text>We have also debugged an NFS server implemented in Java using a client that tries to mount a directory provided by the server.</text></s>
<s sid="405"><CoreSc1 advantage="None" conceptID="Obj40" novelty="None" type="Obj"/><text>We can test some conditions related to an incorrect or unauthorized request, by checking whether some internal error fields are updated (F8) or specific exceptions are thrown (F9, F10).</text></s>
Jibble Web Server (http://www.jibble.org/jibblewebserver.php).
<s sid="406"><CoreSc1 advantage="None" conceptID="Obj41" novelty="None" type="Obj"/><text>Finally, we also studied a Java web server that manages HTTP requests.</text></s>
<s sid="407"><CoreSc1 advantage="None" conceptID="Res147" novelty="None" type="Res"/><text>One possible condition to check would be that the server throws the right exception if it is launched from an incorrect root directory (F11).</text></s>
<s sid="408"><CoreSc1 advantage="None" conceptID="Res148" novelty="None" type="Res"/><text>In addition, we can test whether the server fails to start on any port from a given range, which can be specified as a test input parameter.</text></s>
<s sid="409"><CoreSc1 advantage="None" conceptID="Res149" novelty="None" type="Res"/><text>All executions should thus avoid the location of the exception that would be thrown in this case (F12).</text></s>
Counter projection
<s sid="410"><CoreSc1 advantage="None" conceptID="Res150" novelty="None" type="Res"/><text>We performed some the aforementioned tests using the folded counter projection.</text></s>
<s sid="411"><CoreSc1 advantage="None" conceptID="Con45" novelty="None" type="Con"/><text>It is worth noting that not all of the proposed tests can be carried out using this projection.</text></s>
<s sid="412"><CoreSc1 advantage="None" conceptID="Con46" novelty="None" type="Con"/><text>Formulas that would require cycle detection cannot be checked, as per Proposition 2.</text></s>
<s sid="413"><CoreSc1 advantage="None" conceptID="Met89" novelty="None" type="Met"/><text>However, formulas where the cycle that Spin's stuttering mechanism creates using the last state is enough for detecting every accepting cycle in the never claim automata generated from the formula.</text></s>
<s sid="414"><CoreSc1 advantage="None" conceptID="Met90" novelty="None" type="Met"/><text>Most of the programs we are debugging are infinite, i.e. they are servers with an infinite reactive loop, and this cannot be checked with finite resources and this projection.</text></s>
<s sid="415"><CoreSc1 advantage="None" conceptID="Met91" novelty="None" type="Met"/><text>We modified these programs to produce finite versions that could de checked with both projections, for the purpose of comparison.</text></s>
<s sid="416"><CoreSc1 advantage="None" conceptID="Obs26" novelty="None" type="Obs"/><text>The results are summarized on the left hand side of Table 2, averaged over a series of test executions.</text></s>
<s sid="417"><CoreSc1 advantage="None" conceptID="Obs27" novelty="None" type="Obs"/><text>The third column shows the number of projected Java states, while the fourth column indicates the number of state transitions in Spin.</text></s>
<s sid="418"><CoreSc1 advantage="None" conceptID="Obs28" novelty="None" type="Obs"/><text>The next two columns show the size of a Spin state and the total time of analysis.</text></s>
<s sid="419"><CoreSc1 advantage="None" conceptID="Obs29" novelty="None" type="Obs"/><text>The last column of the table shows an approximation of the size of the Java states, before any projection.</text></s>
<s sid="420"><CoreSc1 advantage="None" conceptID="Obs30" novelty="None" type="Obs"/><text>This number only takes into account the size of objects allocated in the heap.</text></s>
<s sid="421"><CoreSc1 advantage="None" conceptID="Res151" novelty="None" type="Res"/><text>Since the size of the heap changes dynamically, we report the maximum value the we observed during the execution of each program.</text></s>
<s sid="422"><CoreSc1 advantage="None" conceptID="Res152" novelty="None" type="Res"/><text>The size of states in Spin after the projection is influenced by several factors.</text></s>
<s sid="423"><CoreSc1 advantage="None" conceptID="Res153" novelty="None" type="Res"/><text>First, Spin has an overhead of 16B for a Promela specification with a single process, and a Büchi automata adds another 8B.</text></s>
<s sid="424"><CoreSc1 advantage="None" conceptID="Res154" novelty="None" type="Res"/><text>Then, a step integer variable is added to track the Java state that is retrieved in each state (see Section 3.1.3).</text></s>
<s sid="425"><CoreSc1 advantage="None" conceptID="Con47" novelty="None" type="Con"/><text>The variables used for generating test inputs, if any, are added to the global state as well.</text></s>
<s sid="426"><CoreSc1 advantage="None" conceptID="Con48" novelty="None" type="Con"/><text>Furthermore, the counter projection requires an additional variable as described in Section 4.2.1.</text></s>
<s sid="427"><CoreSc1 advantage="None" conceptID="Con49" novelty="None" type="Con"/><text>It is worth noting that the variables being monitored are not part of the global state, but are kept in a separate data structure, in order to support backtracking with minimal impact in the size of Spin states.</text></s>
<s sid="428"><CoreSc1 advantage="None" conceptID="Con50" novelty="None" type="Con"/><text>TJT also has a deadlock detection algorithm.</text></s>
<s sid="429"><CoreSc1 advantage="None" conceptID="Con51" novelty="None" type="Con"/><text>Although the purpose of formula F7 was to detect the incorrect wait condition, it uncovered a deadlock in each execution of the program detected by the monitoring module.</text></s>
<s sid="430"><CoreSc1 advantage="None" conceptID="Con52" novelty="None" type="Con"/><text>Although deadlocks may be detected while using any property, omitting the temporal formula is recommended when specifically searching for them in order to prevent the trace being terminated early due to a specified property.</text></s>
Hash projection
<s sid="431"><CoreSc1 advantage="None" conceptID="Goa13" novelty="None" type="Goa"/><text>We also evaluated the hash projection, using all the properties described above.</text></s>
<s sid="432"><CoreSc1 advantage="None" conceptID="Goa14" novelty="None" type="Goa"/><text>Thanks to its cycle detection capabilities, we could use it for more tests than the counter projection.</text></s>
<s sid="433"><CoreSc1 advantage="None" conceptID="Res155" novelty="None" type="Res"/><text>The right hand side of Table 2 shows these results.</text></s>
<s sid="434"><CoreSc1 advantage="None" conceptID="Res156" novelty="None" type="Res"/><text>The table shows that, compared with the counter projection, the hash projection is generally slower, due to the computation penalty associated with visiting the whole Java program state and computing its hash.</text></s>
<s sid="435"><CoreSc1 advantage="None" conceptID="Con53" novelty="None" type="Con"/><text>As these results suggest the tests with more Java states are the ones where the test time increases the most.</text></s>
<s sid="436"><CoreSc1 advantage="None" conceptID="Con54" novelty="None" type="Con"/><text>Also, the difference between the size of Spin states between the counter and the hash projections is constant: the hash projection adds a variable to store the hash of each state, but removes the counter variable.</text></s>
<s sid="437"><CoreSc1 advantage="None" conceptID="Con55" novelty="None" type="Con"/><text>Although the size of the hash proper is 16B, in our implementation it is stored as a 32B character array, which explains the total difference of 28B.</text></s>
<s sid="438"><CoreSc1 advantage="None" conceptID="Con56" novelty="None" type="Con"/><text>Furthermore, we included some additional tests that required true cycle detection, which is only possible under the hash projection.</text></s>
<s sid="439"><CoreSc1 advantage="None" conceptID="Obj42" novelty="None" type="Obj"/><text>First, we tested Formula 3 from Section 2.1 (F3) on the FTP server.</text></s>
<s sid="440"><CoreSc1 advantage="None" conceptID="Met92" novelty="None" type="Met"/><text>In addition, we also tested a simple Java program that deals with lists in an infinite loop.</text></s>
<s sid="441"><CoreSc1 advantage="None" conceptID="Met93" novelty="None" type="Met"/><text>The program adds elements to the list and then removes them, and we checked that the list ended up with exactly one element an infinite number of times (F13).</text></s>
<s sid="442"><CoreSc1 advantage="None" conceptID="Met94" novelty="None" type="Met"/><text>To end our experiments, we performed a small comparison between TJT and the LTL extension for JPF, using the hash projection.</text></s>
<s sid="443"><CoreSc1 advantage="None" conceptID="Res157" novelty="None" type="Res"/><text>Although both tools are based on model checking and can test LTL properties, their scopes are different.</text></s>
<s sid="444"><CoreSc1 advantage="None" conceptID="Res158" novelty="None" type="Res"/><text>JPF performs an exhaustive search over the complete space state of the program, while TJT analyzes a range of execution traces.</text></s>
<s sid="445"><CoreSc1 advantage="None" conceptID="Res159" novelty="None" type="Res"/><text>We compared both tools with some examples available with JPF-LTL, summarizing the results in Table 3.</text></s>
<s sid="446"><CoreSc1 advantage="None" conceptID="Con57" novelty="None" type="Con"/><text>In this table, the first two columns show the name of the example and the formula being analyzed, &quot;Transitions&quot; are the number of state transitions traversed, and &quot;Time&quot; the total time required to check the formula against the program.</text></s>
<s sid="447"><CoreSc1 advantage="None" conceptID="Res160" novelty="None" type="Res"/><text>It is worth noting the disparity in time and space required for the analysis of the second formula with TJT, compared to the other two.</text></s>
<s sid="448"><CoreSc1 advantage="None" conceptID="Con58" novelty="None" type="Con"/><text>This program deals with random number generators, and the property requires cycle detection.</text></s>
<s sid="449"><CoreSc1 advantage="None" conceptID="Con59" novelty="None" type="Con"/><text>Although checking whether or not a single trace violates the property is relatively quick, the first few traces generated and analyzed by TJT did not violate the property.</text></s>
<s sid="450"><CoreSc1 advantage="None" conceptID="Con60" novelty="None" type="Con"/><text>Thus, when a violating trace was generated, the cost of the analysis had accumulated the analysis of the previous traces.</text></s>
Comparison with related work
<s sid="451"><CoreSc1 advantage="None" conceptID="Met95" novelty="None" type="Met"/><text>The most notable tools for analyzing Java programs using some variant of full-state model checking are Bandera (Corbett et al., 2000) and Java PathFinder (Visser et al., 2003).</text></s>
<s sid="452"><CoreSc1 advantage="None" conceptID="Con61" novelty="None" type="Con"/><text>Bandera is a model extraction based tool that requires the Java program to be transformed into a model composed by pure Promela plus embedded C code.</text></s>
<s sid="453"><CoreSc1 advantage="None" conceptID="Con62" novelty="None" type="Con"/><text>This model is optimized by applying a data abstraction mechanism that provides an approximation of the execution traces.</text></s>
<s sid="454"><CoreSc1 advantage="None" conceptID="Con63" novelty="None" type="Con"/><text>As Bandera uses Spin as the model checker, it can check LTL on infinite traces and preserve correction results according to the approximation of the traces.</text></s>
<s sid="455"><CoreSc1 advantage="None" conceptID="Con64" novelty="None" type="Con"/><text>Compared with Bandera, TJT only checks a set of traces.</text></s>
<s sid="456"><CoreSc1 advantage="None" conceptID="Con65" novelty="None" type="Con"/><text>However the use of runtime monitoring to avoid model transformation, and the two abstraction methods guarantee the correctness of the results.</text></s>
<s sid="457"><CoreSc1 advantage="None" conceptID="Con66" novelty="None" type="Con"/><text>Java PathFinder (Havelund and Pressburger, 2000) (JPF) is a complete model checker for Java programs that performs a complete coverage of a program, while our testing tool does a partial analysis of the program.</text></s>
<s sid="458"><CoreSc1 advantage="None" conceptID="Con67" novelty="None" type="Con"/><text>In addition, thanks to a matching mechanism, JPF does not revisit the same execution path twice, while TJT analyzes each trace in isolation without checking whether several traces share already visited states.</text></s>
<s sid="459"><CoreSc1 advantage="None" conceptID="Con68" novelty="None" type="Con"/><text>However due to our integration approach, we can still gain some advantages from reusing the well known model checker Spin, instead of building a new one from scratch.</text></s>
<s sid="460"><CoreSc1 advantage="None" conceptID="Con69" novelty="None" type="Con"/><text>Some realistic Java examples of reactive software are not suitable for verification by JPF.</text></s>
<s sid="461"><CoreSc1 advantage="None" conceptID="Con70" novelty="None" type="Con"/><text>For instance, we tried analyzing our elevator problem with JPF, but it ran out of memory after 58 minutes.</text></s>
<s sid="462"><CoreSc1 advantage="None" conceptID="Con71" novelty="None" type="Con"/><text>The verification of LTL with JPF-LTL in JPF is still under development and has a limited visibility of the program elements for writing the formula.</text></s>
<s sid="463"><CoreSc1 advantage="None" conceptID="Con72" novelty="None" type="Con"/><text>At the time of writing, JPF-LTL only considers entry to methods in the propositions, and it requires the user to explicitly declare whether the formula should be evaluated for infinite or finite traces.</text></s>
<s sid="464"><CoreSc1 advantage="None" conceptID="Con73" novelty="None" type="Con"/><text>TJT allows a richer set of propositions to be used in the formulas and, due to the stuttering semantics used by Spin, the user does not need to declare whether the trace is finite or not.</text></s>
<s sid="465"><CoreSc1 advantage="None" conceptID="Obj43" novelty="None" type="Obj"/><text>The specification of LTL properties to analyze programming languages at runtime has been proposed by other authors, which we discuss in the rest of this section.</text></s>
<s sid="466"><CoreSc1 advantage="None" conceptID="Res161" novelty="None" type="Res"/><text>Probably, the most complete overview of the approaches can be found in a paper by Bauer et.</text></s>
<s sid="467"><CoreSc1 advantage="None" conceptID="Res162" novelty="None" type="Res"/><text>al (Bauer et al., 2011).</text></s>
Bauer et.
<s sid="468"><CoreSc1 advantage="None" conceptID="Res163" novelty="None" type="Res"/><text>al consider the runtime verification of LTL and tLTL (timed LTL) with a three-valued semantics (with truth values true, false, inconclusive) suitable to check whether or not a partial observation of a running system meets a property.</text></s>
<s sid="469"><CoreSc1 advantage="None" conceptID="Res164" novelty="None" type="Res"/><text>They generate deterministic monitors to decide the satisfaction (or not satisfaction) of a property as early as possible.</text></s>
<s sid="470"><CoreSc1 advantage="None" conceptID="Con74" novelty="None" type="Con"/><text>They use these three-values as a way to adapt the semantics of LTL to the evaluation of finite traces.</text></s>
<s sid="471"><CoreSc1 advantage="None" conceptID="Con75" novelty="None" type="Con"/><text>The authors write that &quot;the set of monitorable properties does not only encompass the safety and cosafety properties but is strictly larger&quot;.</text></s>
<s sid="472"><CoreSc1 advantage="None" conceptID="Con76" novelty="None" type="Con"/><text>However, the general case of liveness properties for infinite traces is not considered.</text></s>
<s sid="473"><CoreSc1 advantage="None" conceptID="Con77" novelty="None" type="Con"/><text>Compared with our work, they develop the foundations to create monitors to support the new semantics of LTL for infinite traces, while our work relies on the already existing algorithms and tools to check Büchi automata for infinite traces.</text></s>
<s sid="474"><CoreSc1 advantage="None" conceptID="Con78" novelty="None" type="Con"/><text>Java PathExplorer, developed by Havelund and Roşu (Havelund and Roşu, 2004), uses the rewriting-logic based model checker Maude to check LTL on finite execution traces of Java programs.</text></s>
<s sid="475"><CoreSc1 advantage="None" conceptID="Con79" novelty="None" type="Con"/><text>The authors provide different semantics for LTL formulas in order to avoid cycle detection.</text></s>
<s sid="476"><CoreSc1 advantage="None" conceptID="Con80" novelty="None" type="Con"/><text>Java PathExplorer also supports the generation of a variant of Büchi automata for finite traces developed by Giannakopoulou and Havelund (Giannakopoulou and Havelund, 2001).</text></s>
<s sid="477"><CoreSc1 advantage="None" conceptID="Con81" novelty="None" type="Con"/><text>We share with Java PathExplorer the idea of using the model checker to process the stream of states produced by Java.</text></s>
<s sid="478"><CoreSc1 advantage="None" conceptID="Con82" novelty="None" type="Con"/><text>However, our use of Spin allows us to check infinite execution traces.</text></s>
<s sid="479"><CoreSc1 advantage="None" conceptID="Con83" novelty="None" type="Con"/><text>The tool Temporal Rover (Drusinsky, 2000) can check temporal logic assertions against reactive systems (with non-terminating loops) at runtime.</text></s>
<s sid="480"><CoreSc1 advantage="None" conceptID="Con84" novelty="None" type="Con"/><text>The author considers that both finite and infinite traces are possible.</text></s>
<s sid="481"><CoreSc1 advantage="None" conceptID="Con85" novelty="None" type="Con"/><text>However, only finite traces are evaluated, and a default fail value is returned for formulas like ◊p when p has not been satisfied at the end of the trace and there is no evidence that the program has terminated.</text></s>
<s sid="482"><CoreSc1 advantage="None" conceptID="Con86" novelty="None" type="Con"/><text>TJT can provide a conclusive verdict when inspecting the infinite trace.</text></s>
<s sid="483"><CoreSc1 advantage="None" conceptID="Con87" novelty="None" type="Con"/><text>Bodden (Bodden, 2004) uses AspectJ to implement a method to evaluate LTL, inserting pieces of Java code to be executed at points where the behavior specified by the formula is relevant and must be evaluated.</text></s>
<s sid="484"><CoreSc1 advantage="None" conceptID="Con88" novelty="None" type="Con"/><text>This method is useful to check only safety properties.</text></s>
<s sid="485"><CoreSc1 advantage="None" conceptID="Con89" novelty="None" type="Con"/><text>d'Amorim and Havelund (d'Amorim and Havelund, 2005) have developed the tool HAWK for the runtime verification of Java programs, which allows the definition of temporal properties with the logic EAGLE.</text></s>
<s sid="486"><CoreSc1 advantage="None" conceptID="Con90" novelty="None" type="Con"/><text>In addition, the user must supply a method that must be called when the program terminates in order to produce a finite trace.</text></s>
<s sid="487"><CoreSc1 advantage="None" conceptID="Con91" novelty="None" type="Con"/><text>FiLM (Finite LTL runtime Monitor) (Zhang et al., 2009) also gives a specific semantics to LTL to check both safety and liveness in finite traces.</text></s>
<s sid="488"><CoreSc1 advantage="None" conceptID="Con92" novelty="None" type="Con"/><text>However, in the case of liveness, manual inspection is required when the tool reports a potential liveness violation.</text></s>
<s sid="489"><CoreSc1 advantage="None" conceptID="Con93" novelty="None" type="Con"/><text>All these tools for runtime monitoring of LTL are focused on finite traces.</text></s>
<s sid="490"><CoreSc1 advantage="None" conceptID="Con94" novelty="None" type="Con"/><text>The main difference with TJT is the support of cycle detection due to the way in which the states are abstracted and stored, and the use of Büchi automata.</text></s>
<s sid="491"><CoreSc1 advantage="None" conceptID="Con95" novelty="None" type="Con"/><text>Note that we have not included further experimental comparison of TJT with some of these runtime monitoring tools due to the lack of comparable public examples, or of the tools themselves.</text></s>
Conclusions and future work
<s sid="492"><CoreSc1 advantage="None" conceptID="Con96" novelty="None" type="Con"/><text>We have presented the foundations of TJT, a tool for checking temporal logic properties on Java programs.</text></s>
<s sid="493"><CoreSc1 advantage="None" conceptID="Con97" novelty="None" type="Con"/><text>This tool is useful for testing functional properties on both sequential and concurrent programs.</text></s>
<s sid="494"><CoreSc1 advantage="None" conceptID="Con98" novelty="None" type="Con"/><text>In particular, we explained how the use of Büchi automata combined with storing the states from runtime monitoring can be used to check liveness properties in non-terminating executions of reactive programs.</text></s>
<s sid="495"><CoreSc1 advantage="None" conceptID="Con99" novelty="None" type="Con"/><text>Our tool chain includes the model checker Spin and JDI, which are integrated in the well known development environment Eclipse.</text></s>
<s sid="496"><CoreSc1 advantage="None" conceptID="Con100" novelty="None" type="Con"/><text>The use of JDI instead of instrumented code makes it possible to detect deadlocks and provides wider access to events in the execution of the program, while being completely transparent.</text></s>
<s sid="497"><CoreSc1 advantage="None" conceptID="Con101" novelty="None" type="Con"/><text>Our current work follows several paths.</text></s>
<s sid="498"><CoreSc1 advantage="None" conceptID="Met96" novelty="None" type="Met"/><text>One is to apply static influence analysis to automatically select the variables relevant to the given property, as we proposed in (de la Cámara et al., 2006).</text></s>
<s sid="499"><CoreSc1 advantage="None" conceptID="Res165" novelty="None" type="Res"/><text>The second one is to implement methods to produce more schedulling in multithreaded programs for the same initial state.</text></s>
<s sid="500"><CoreSc1 advantage="None" conceptID="Obj44" novelty="None" type="Obj"/><text>Finally, we plan to take advantage of multicore architectures to speed up the analysis, due to the already decoupled interaction between Spin and JDI modules.</text></s>
</BODY>
<OTHER>
Acknowledgements
Work partially supported by projects P11-TIC-07659 (Regional Government of Andalusia), TIN2012-35669 (Spanish Ministry of Economy and Competitiveness) and UMA-806/47.3154-1 (AT4Wireless).
We thank Franco Raimondi and Michelle Lombardi fortheir help regarding JPF-LTL.

</OTHER>
</PAPER>