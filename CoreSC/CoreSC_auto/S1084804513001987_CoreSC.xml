<?xml version="1.0" ?><PAPER><mode2 hasDoc="yes" name="S1084804513001987.tmf1" version="elsevier"/>
<TITLE>Performance analysis of quantization-based approximation algorithms for precomputing the supported QoS
</TITLE>
<ABSTRACT>

Abstract
<s sid="1"><CoreSc1 advantage="None" conceptID="Res1" novelty="None" type="Res"/><text>Precomputation of the supported QoS is very important for internet routing.</text></s>
<s sid="2"><CoreSc1 advantage="None" conceptID="Res2" novelty="None" type="Res"/><text>By constructing routing tables before a request arrives, a packet can be forwarded with a simple table lookup.</text></s>
<s sid="3"><CoreSc1 advantage="None" conceptID="Con1" novelty="None" type="Con"/><text>When the QoS information is provided, a node can immediately know whether a certain request can be supported without launching the path finding process.</text></s>
<s sid="4"><CoreSc1 advantage="None" conceptID="Con2" novelty="None" type="Con"/><text>Unfortunately, as the problem of finding a route satisfying two additive constraints is NP-complete, the supported QoS information can only be approximated using a polynomial time mechanism.</text></s>
<s sid="5"><CoreSc1 advantage="None" conceptID="Res3" novelty="None" type="Res"/><text>A good approximation scheme should reduce the error in estimating the actual supported QoS.</text></s>
<s sid="6"><CoreSc1 advantage="None" conceptID="Con3" novelty="None" type="Con"/><text>Nevertheless, existing approaches which determine this error may not truly reflect the performance on admission control, meaning whether a request can be correctly classified as feasible or infeasible.</text></s>
<s sid="7"><CoreSc1 advantage="None" conceptID="Obj1" novelty="None" type="Obj"/><text>In this paper, we propose using a novel metric, known as distortion area, to evaluate the performance of precomputing the supported QoS.</text></s>
<s sid="8"><CoreSc1 advantage="None" conceptID="Obj2" novelty="None" type="Obj"/><text>We then analyze the performance of the class of algorithms that approximate the supported QoS through discretizing link metrics.</text></s>
<s sid="9"><CoreSc1 advantage="None" conceptID="Con4" novelty="None" type="Con"/><text>We demonstrate how the performance of these schemes can be enhanced without increasing complexity.</text></s>
<s sid="10"><CoreSc1 advantage="None" conceptID="Con5" novelty="None" type="Con"/><text>Our results serve as a guideline on developing discretization-based approximation algorithms.</text></s>
</ABSTRACT>
<BODY>

Introduction
<s sid="11"><CoreSc1 advantage="None" conceptID="Mot1" novelty="None" type="Mot"/><text>As the demand for deploying real-time and multimedia applications over the internet is increasing, providing guaranteed quality-of-service (QoS) for these applications becomes more and more important.</text></s>
<s sid="12"><CoreSc1 advantage="None" conceptID="Obj3" novelty="None" type="Obj"/><text>In general, the QoS requirements can be divided into two categories: bottleneck metric and additive metric.</text></s>
<s sid="13"><CoreSc1 advantage="None" conceptID="Obj4" novelty="None" type="Obj"/><text>The additive metric of a path is the sum of the metrics of the links along the path, while the bottleneck metric of a path is the minimum value of the metrics of the links along the path.</text></s>
<s sid="14"><CoreSc1 advantage="None" conceptID="Obj5" novelty="None" type="Obj"/><text>For example, bandwidth is a bottleneck QoS metric, while delay and delay jitter are additive QoS metrics.</text></s>
<s sid="15"><CoreSc1 advantage="None" conceptID="Obj6" novelty="None" type="Obj"/><text>In this work, we consider connection requests that have two additive QoS requirements or constraints, such as in delay and cost.</text></s>
<s sid="16"><CoreSc1 advantage="None" conceptID="Mod1" novelty="None" type="Mod"/><text>To simplify our discussion, we assume that delay and cost are the two additive metrics under consideration, although our analysis and method can be applied to any additive metrics.</text></s>
<s sid="17"><CoreSc1 advantage="None" conceptID="Bac1" novelty="None" type="Bac"/><text>Many existing works study how to identify a feasible path for a request with two additive constraints, which is an NP-complete problem.</text></s>
<s sid="18"><CoreSc1 advantage="None" conceptID="Bac2" novelty="None" type="Bac"/><text>These works usually assume either the cost or the delay requirement which is known.</text></s>
<s sid="19"><CoreSc1 advantage="None" conceptID="Bac3" novelty="None" type="Bac"/><text>Nevertheless, such reactive routing mechanism, which finds a path after the requirement is known, cannot provide enough information to support efficient admission control.</text></s>
<s sid="20"><CoreSc1 advantage="None" conceptID="Res4" novelty="None" type="Res"/><text>When a request is received, a node cannot immediately tell whether a possible feasible path exists until a path finding process is launched based on the requested cost/delay.</text></s>
<s sid="21"><CoreSc1 advantage="None" conceptID="Res5" novelty="None" type="Res"/><text>On the other hand, by precomputing the supported QoS information, a source can immediately determine whether the connection request can be supported by the network.</text></s>
<s sid="22"><CoreSc1 advantage="None" conceptID="Obj7" novelty="None" type="Obj"/><text>Moreover, accepting a new connection will not violate the service guarantees for the existing traffics, and also the transmission route satisfies the QoS requirement of the new connection.</text></s>
<s sid="23"><CoreSc1 advantage="None" conceptID="Obj8" novelty="None" type="Obj"/><text>The problem of computing the supported QoS between two nodes is more complicated than the extensively studied multi-constrained path (MCP) problem or the delay-constrained least cost (DCLC) path problem.</text></s>
<s sid="24"><CoreSc1 advantage="None" conceptID="Obj9" novelty="None" type="Obj"/><text>The DCLC problem is also called the restricted shortest path (RSP) problem.</text></s>
<s sid="25"><CoreSc1 advantage="None" conceptID="Bac4" novelty="None" type="Bac"/><text>The RSP problem aims at finding the minimum delay path among the paths that satisfy a certain cost constraint.</text></s>
<s sid="26"><CoreSc1 advantage="None" conceptID="Bac5" novelty="None" type="Bac"/><text>The MCP problem studies finding a path satisfying both specified cost and delay constraints.</text></s>
<s sid="27"><CoreSc1 advantage="None" conceptID="Bac6" novelty="None" type="Bac"/><text>Both problems focus on finding a single path between two nodes with a given (cost) constraint.</text></s>
<s sid="28"><CoreSc1 advantage="None" conceptID="Res6" novelty="None" type="Res"/><text>Our problem, also known as the all-costs optimal path (ACOP) problem (Orda and Sprintson, 2003), finds, for each cost c, a c-cost constrained path from a source to a destination with the minimum delay.</text></s>
<s sid="29"><CoreSc1 advantage="None" conceptID="Res7" novelty="None" type="Res"/><text>In other words, instead of finding a single path given a cost constraint, the ACOP problem aims at finding a set of paths representing the supported QoS.</text></s>
<s sid="30"><CoreSc1 advantage="None" conceptID="Res8" novelty="None" type="Res"/><text>Due to the NP-complete nature of the problem, some approximation mechanisms have been developed (Garroppo et al., 2010).</text></s>
<s sid="31"><CoreSc1 advantage="None" conceptID="Res9" novelty="None" type="Res"/><text>They usually identify a path with a cost (or delay) within a certain deviation from the optimal one.</text></s>
<s sid="32"><CoreSc1 advantage="None" conceptID="Res10" novelty="None" type="Res"/><text>Denote c as the estimated optimal cost of all the paths satisfying a given delay constraint d0, which is computed by an algorithm, and copt as the optimal cost of all the paths satisfying the delay constraint d0 in the network.</text></s>
<s sid="33"><CoreSc1 advantage="None" conceptID="Res11" novelty="None" type="Res"/><text>c-copt is thus called the cost deviation at the delay constraint of d0.</text></s>
<s sid="34"><CoreSc1 advantage="None" conceptID="Con6" novelty="None" type="Con"/><text>An algorithm is &quot;better&quot; if the deviation is smaller.</text></s>
<s sid="35"><CoreSc1 advantage="None" conceptID="Con7" novelty="None" type="Con"/><text>While deviation is appropriate for measuring the performance of the DCLC solutions, we believe that it does not directly reflect the performance of the ACOP solutions in supporting admission control.</text></s>
<s sid="36"><CoreSc1 advantage="None" conceptID="Hyp1" novelty="None" type="Hyp"/><text>A good pre-computation mechanism should approximate the supported QoS as precisely as possible.</text></s>
<s sid="37"><CoreSc1 advantage="None" conceptID="Hyp2" novelty="None" type="Hyp"/><text>In other words, the error in estimation should be minimized.</text></s>
<s sid="38"><CoreSc1 advantage="None" conceptID="Obj10" novelty="None" type="Obj"/><text>Since any possible delay constraint is considered, this &quot;error&quot; is not a single cost deviation, but an area on the Cartesian plane.</text></s>
<s sid="39"><CoreSc1 advantage="None" conceptID="Obj11" novelty="None" type="Obj"/><text>To illustrate, consider that there are three paths connecting a source to a destination.</text></s>
<s sid="40"><CoreSc1 advantage="None" conceptID="Obj12" novelty="None" type="Obj"/><text>The QoS parameters of the paths are (1,10), (2,2), and (10,1), where the first element in the tuple reflects the cost of the path while the second element represents the path delay.</text></s>
<s sid="41"><CoreSc1 advantage="None" conceptID="Obj13" novelty="None" type="Obj"/><text>In this paper, we write the QoS parameter of a path and the constraints of a request as (cost,delay).</text></s>
<s sid="42"><CoreSc1 advantage="None" conceptID="Res12" novelty="None" type="Res"/><text>Request (c,d) can be supported by a path with the QoS parameter (c′,d′), where c′≤c and d′≤d.</text></s>
<s sid="43"><CoreSc1 advantage="None" conceptID="Res13" novelty="None" type="Res"/><text>Request (5,5) is feasible because it can be supported by the path with the QoS parameter (2,2).</text></s>
<s sid="44"><CoreSc1 advantage="None" conceptID="Res14" novelty="None" type="Res"/><text>Request (1,15) is also feasible because it can be supported by the path with the QoS parameter (1,10).</text></s>
<s sid="45"><CoreSc1 advantage="None" conceptID="Res15" novelty="None" type="Res"/><text>However, Request (1,1) is not feasible because no path can support it.</text></s>
<s sid="46"><CoreSc1 advantage="None" conceptID="Res16" novelty="None" type="Res"/><text>If we plot the QoS parameters of the path on the cost-delay plane, any request that can be supported by any of the paths can be easily identified.</text></s>
<s sid="47"><CoreSc1 advantage="None" conceptID="Res17" novelty="None" type="Res"/><text>Refer to Fig. 1(a), the shaded area is the optimal supported QoS, in which any request that falls in the region is feasible.</text></s>
<s sid="48"><CoreSc1 advantage="None" conceptID="Con8" novelty="None" type="Con"/><text>Thus, a good pre-computation scheme should approximate this area as precisely as possible.</text></s>
<s sid="49"><CoreSc1 advantage="None" conceptID="Con9" novelty="None" type="Con"/><text>The &quot;error&quot; in approximation is the difference in terms of the area between the region of the optimal supported QoS and that of the approximated supported QoS.</text></s>
<s sid="50"><CoreSc1 advantage="None" conceptID="Con10" novelty="None" type="Con"/><text>While cost deviation is related to the difference in area, it is not sufficient.</text></s>
<s sid="51"><CoreSc1 advantage="None" conceptID="Obs1" novelty="None" type="Obs"/><text>For example, the shaded areas in Fig. 1(a) and (b) represent the optimal and approximate supported QoS regions, respectively.</text></s>
<s sid="52"><CoreSc1 advantage="None" conceptID="Res18" novelty="None" type="Res"/><text>According to Fig. 1(b), when delay is two, the approximate best cost is three.</text></s>
<s sid="53"><CoreSc1 advantage="None" conceptID="Res19" novelty="None" type="Res"/><text>The cost deviation is 3-2=1, as the optimal cost is two.</text></s>
<s sid="54"><CoreSc1 advantage="None" conceptID="Res20" novelty="None" type="Res"/><text>The area of {[2,3]×[2,10]} is the &quot;error&quot; in estimating the supported QoS.</text></s>
<s sid="55"><CoreSc1 advantage="None" conceptID="Res21" novelty="None" type="Res"/><text>Any request with the QoS requirements falling in this area is considered as infeasible but actually they are supported by the network.</text></s>
<s sid="56"><CoreSc1 advantage="None" conceptID="Obs2" novelty="None" type="Obs"/><text>For example, Request (2,5) is in fact feasible but can be rejected by any approximation algorithms based on the approximate QoS in Fig. 1(b).</text></s>
<s sid="57"><CoreSc1 advantage="None" conceptID="Obs3" novelty="None" type="Obs"/><text>On the other hand, in Fig. 1(d), the cost deviation with the delay constraint of two is also one.</text></s>
<s sid="58"><CoreSc1 advantage="None" conceptID="Obs4" novelty="None" type="Obs"/><text>However, we can observe that the &quot;error&quot; in Fig. 1(d) is much smaller than that in Fig. 1(b).</text></s>
<s sid="59"><CoreSc1 advantage="None" conceptID="Obs5" novelty="None" type="Obs"/><text>Request (2,5) would be correctly classified as feasible.</text></s>
<s sid="60"><CoreSc1 advantage="None" conceptID="Res22" novelty="None" type="Res"/><text>Thus, the approximate supported QoS in Fig. 1(d) provides a better network QoS providence than that in Fig. 1(b).</text></s>
<s sid="61"><CoreSc1 advantage="None" conceptID="Res23" novelty="None" type="Res"/><text>The above example illustrates that cost deviation cannot sufficiently reflect the admission control ability of the algorithm, while the &quot;area&quot; does.</text></s>
<s sid="62"><CoreSc1 advantage="None" conceptID="Goa1" novelty="None" type="Goa"/><text>In this work, we propose a new metric, known as distortion area, which is defined as the difference between the approximate supported QoS region and the optimal supported QoS region, to evaluate the accuracy performance of the algorithm for estimating the supported QoS.</text></s>
<s sid="63"><CoreSc1 advantage="None" conceptID="Obj14" novelty="None" type="Obj"/><text>We first analyze the distortion area of the representative algorithms described in Orda and Sprintson (2003) and Xue et al. (2007).</text></s>
<s sid="64"><CoreSc1 advantage="None" conceptID="Goa2" novelty="None" type="Goa"/><text>Then, we illustrate how to improve the algorithm to reduce the error.</text></s>
Related work
<s sid="65"><CoreSc1 advantage="None" conceptID="Obj15" novelty="None" type="Obj"/><text>The MCP problem and RSP (DCLC) problem have been studied extensively (Garroppo et al., 2010).</text></s>
<s sid="66"><CoreSc1 advantage="None" conceptID="Obj16" novelty="None" type="Obj"/><text>The work in Hassin (1992) focuses on the RSP problem and presents two polynomial algorithms.</text></s>
<s sid="67"><CoreSc1 advantage="None" conceptID="Met1" novelty="None" type="Met"/><text>The author first presented an ε-approximation algorithm by using the basic technique of rounding and scaling with the time complexity O(loglog(UBLB)(|E|(n/ε)+loglog(UBLB))), where UB and LB are the cost metrics of the minimum delay path and the minimum cost path, respectively, |E| is the number of links, and n is the number of nodes.</text></s>
<s sid="68"><CoreSc1 advantage="None" conceptID="Met2" novelty="None" type="Met"/><text>Then, the author applied the basic technique of interval partitioning in Sahni (1977) to design a second ε-approximation algorithm with the time complexity of O(|E|(n2/ε)log(n/ε)).</text></s>
<s sid="69"><CoreSc1 advantage="None" conceptID="Met3" novelty="None" type="Met"/><text>Since the time complexity of the first algorithm depends on the upper bound of delay metric of each link, this algorithm is classified in Orda and Sprintson (2003) as a pseudo-polynomial algorithm.</text></s>
<s sid="70"><CoreSc1 advantage="None" conceptID="Met4" novelty="None" type="Met"/><text>To the best of our knowledge, the algorithm in Xue et al. (2007) is currently fastest one for precomputing the supported QoS with two additive constraints, which has the complexity of O(|E|n(loglogn+1/ε)), where ε is the small positive constant.</text></s>
<s sid="71"><CoreSc1 advantage="None" conceptID="Obs6" novelty="None" type="Obs"/><text>The smaller ε, the higher accuracy but the higher computational overhead.</text></s>
<s sid="72"><CoreSc1 advantage="None" conceptID="Met5" novelty="None" type="Met"/><text>Chen et al. (2008) design heuristic techniques to improve the performance computational overhead of the algorithm in Goel et al. (2001).As we know, heuristic algorithm cannot provide performance guarantees and the introduced approximation error is difficult to be bounded.</text></s>
<s sid="73"><CoreSc1 advantage="None" conceptID="Met6" novelty="None" type="Met"/><text>Xue et al. (2008) study the decision version of the problem.</text></s>
<s sid="74"><CoreSc1 advantage="None" conceptID="Res24" novelty="None" type="Res"/><text>Given a connection request with two additive constraints, the proposed algorithm either finds a feasible solution or confirms that there does not exist a source-destination path whose first metric is bounded by the first constraint and whose second weight is bounded by (1-ε) times the second constraint.</text></s>
<s sid="75"><CoreSc1 advantage="None" conceptID="Bac7" novelty="None" type="Bac"/><text>Afterwards, Huang et al. (2012) enhance the algorithm proposed by Xue et al. (2008) by reducing the computational complexity.</text></s>
<s sid="76"><CoreSc1 advantage="None" conceptID="Obj17" novelty="None" type="Obj"/><text>Li and Zhang (2010) study MCP problem in smart grid and propose a simple heuristic algorithm.</text></s>
<s sid="77"><CoreSc1 advantage="None" conceptID="Obj18" novelty="None" type="Obj"/><text>Avallone and Ventre (2012) develop a routing algorithm which searches for a feasible path for a given flow request with multiple additive constraints that requires the least number of nodes and links to be turned on.</text></s>
<s sid="78"><CoreSc1 advantage="None" conceptID="Obj19" novelty="None" type="Obj"/><text>Lu and Zhu (2013) present a genetic algorithm to find a path satisfying a connection request with two additive constraints.</text></s>
<s sid="79"><CoreSc1 advantage="None" conceptID="Obj20" novelty="None" type="Obj"/><text>With the supported QoS region, the decision can be made immediately based on the QoS requirements.</text></s>
<s sid="80"><CoreSc1 advantage="None" conceptID="Met7" novelty="None" type="Met"/><text>In fact, the common technique used for designing approximation algorithms (for solving both RSP and MCP) is to map the cost (or delay) value of each link to an integer.</text></s>
<s sid="81"><CoreSc1 advantage="None" conceptID="Met8" novelty="None" type="Met"/><text>Then, the cost (or delay) of a path becomes a value in a finite set of integers instead of the continuous real number line.</text></s>
<s sid="82"><CoreSc1 advantage="None" conceptID="Met9" novelty="None" type="Met"/><text>We refer this technique as quantization.</text></s>
<s sid="83"><CoreSc1 advantage="None" conceptID="Met10" novelty="None" type="Met"/><text>For example, in the uniform scaling quantization method, a link cost is multiplied by a constant and then round (up or down) to an integer.</text></s>
<s sid="84"><CoreSc1 advantage="None" conceptID="Met11" novelty="None" type="Met"/><text>Moreover, there is another quantization method called logarithmic scaling (Orda and Sprintson, 2003), and we shall describe it in more detail later.</text></s>
<s sid="85"><CoreSc1 advantage="None" conceptID="Met12" novelty="None" type="Met"/><text>After quantizing the link costs (delays), we can apply the approximation algorithm to solve RSP for each possible cost (or delay) constraint to get the ACOP solution (Orda and Sprintson, 2003).</text></s>
<s sid="86"><CoreSc1 advantage="None" conceptID="Met13" novelty="None" type="Met"/><text>Unfortunately, the complexity will be very high, and thus the authors in Orda and Sprintson (2003) developed a less computationally expensive approximation algorithm.</text></s>
<s sid="87"><CoreSc1 advantage="None" conceptID="Met14" novelty="None" type="Met"/><text>Nevertheless, the performance analysis presented in Orda and Sprintson (2003) is based on cost deviation, but not on distortion area.</text></s>
<s sid="88"><CoreSc1 advantage="None" conceptID="Obj21" novelty="None" type="Obj"/><text>In this paper, we shall analyze the upper bound of the distortion area produced by the approximation algorithm in Orda and Sprintson (2003).</text></s>
<s sid="89"><CoreSc1 advantage="None" conceptID="Met15" novelty="None" type="Met"/><text>Nevertheless, the analysis can be generalized for other approximation algorithms based on link metric quantization.</text></s>
<s sid="90"><CoreSc1 advantage="None" conceptID="Met16" novelty="None" type="Met"/><text>Cui et al. (2003, 2005) also study the problem of precomputing the supported QoS.</text></s>
<s sid="91"><CoreSc1 advantage="None" conceptID="Res25" novelty="None" type="Res"/><text>The proposed mechanisms are heuristic and there is no performance guarantee.</text></s>
<s sid="92"><CoreSc1 advantage="None" conceptID="Res26" novelty="None" type="Res"/><text>There are two kinds of errors for admission control in these algorithms.</text></s>
<s sid="93"><CoreSc1 advantage="None" conceptID="Res27" novelty="None" type="Res"/><text>The first one is when an algorithm rejects a feasible connection request, and the second one is whenever an algorithm accepts an infeasible connection request.</text></s>
<s sid="94"><CoreSc1 advantage="None" conceptID="Bac8" novelty="None" type="Bac"/><text>The &quot;error&quot; defined in Cui et al. (2003, 2005) includes both kinds of errors.</text></s>
<s sid="95"><CoreSc1 advantage="None" conceptID="Bac9" novelty="None" type="Bac"/><text>Since the quantization-based algorithms presented in our work will not accept an infeasible connection request, they will not introduce the second kind of error.</text></s>
<s sid="96"><CoreSc1 advantage="None" conceptID="Goa3" novelty="None" type="Goa"/><text>Therefore, the distortion area presented by our work is suitable to reflect the admission control performance of the algorithms.</text></s>
<s sid="97"><CoreSc1 advantage="None" conceptID="Mod2" novelty="None" type="Mod"/><text>Network model and problem formulation</text></s>
<s sid="98"><CoreSc1 advantage="None" conceptID="Mod3" novelty="None" type="Mod"/><text>We model a computer network by a directed graph G=(V,E), where V is the set of n vertices, and E is the set of m edges.</text></s>
<s sid="99"><CoreSc1 advantage="None" conceptID="Mod4" novelty="None" type="Mod"/><text>Each edge l=(u,v) is associated with two additive metrics, namely, cost and delay.</text></s>
<s sid="100"><CoreSc1 advantage="None" conceptID="Mod5" novelty="None" type="Mod"/><text>Let (cl,dl) be the QoS parameter of Edge l, where cl and dl are the cost and delay of l, respectively.</text></s>
<s sid="101"><CoreSc1 advantage="None" conceptID="Mod6" novelty="None" type="Mod"/><text>We assume that all parameters (cost and delay) are positive, bounded, and independent.</text></s>
<s sid="102"><CoreSc1 advantage="None" conceptID="Mod7" novelty="None" type="Mod"/><text>Let A(v) be the node neighbor set of v.</text></s>
<s sid="103"><CoreSc1 advantage="None" conceptID="Mod8" novelty="None" type="Mod"/><text>We define the optimal delay function of Link l, Dlopt(c), to specify the minimum delay value provided by link l at the cost constraint of c.</text></s>
<s sid="104"><CoreSc1 advantage="None" conceptID="Mod9" novelty="None" type="Mod"/><text>Thus, Dlopt(c) is equal to ∞ if c&lt;cl, otherwise, it is equal to dl if c≥cl.</text></s>
<s sid="105"><CoreSc1 advantage="None" conceptID="Mod10" novelty="None" type="Mod"/><text>Given a path P from s to g, the optimal delay function of Path P, DPopt(c), is the minimum delay value provided by this path with a cost constraint of c.</text></s>
<s sid="106"><CoreSc1 advantage="None" conceptID="Mod11" novelty="None" type="Mod"/><text>Thus, DPopt(c) is equal to ∞ if c&lt;∑l∈Pcl, otherwise, it is equal to ∑l∈Pdl.</text></s>
<s sid="107"><CoreSc1 advantage="None" conceptID="Mod12" novelty="None" type="Mod"/><text>Let Ps→g be the set of paths from s to g.</text></s>
<s sid="108"><CoreSc1 advantage="None" conceptID="Mod13" novelty="None" type="Mod"/><text>We define the optimal delay function from s to g, Ds,gopt(c), which is the minimum delay value provided by all the paths from s to g with the cost constraint of c, as Ds,gopt(c)=minP∈Ps→g{DPopt(c)}.</text></s>
<s sid="109"><CoreSc1 advantage="None" conceptID="Mod14" novelty="None" type="Mod"/><text>Consider a simple network in Fig. 2(a).</text></s>
<s sid="110"><CoreSc1 advantage="None" conceptID="Mod15" novelty="None" type="Mod"/><text>PA→G has six paths: Path A→D→F→G with the QoS parameter (4,7), Path A→C→F→G with the QoS parameter (5,6), Path A→D→C→F→G with the QoS parameter (5,10), Path A→C→E→G with the QoS parameter (7,5), Path A→D→C→E→G with the QoS parameter (7,9), and Path A→B→E→G with the QoS parameter (8,4).</text></s>
<s sid="111"><CoreSc1 advantage="None" conceptID="Mod16" novelty="None" type="Mod"/><text>For the given path P1=A→B→E→G, the corresponding optimal delay function is DP1opt(c)=∞(ifc&lt;8)or4(ifc≥8).</text></s>
<s sid="112"><CoreSc1 advantage="None" conceptID="Mod17" novelty="None" type="Mod"/><text>We can compute the optimal delay function DA,Gopt(c) from A to G based on minP∈PA→G{DPopt(c)}, which is DA,Gopt(c)={4ifc≥85if7≤c&lt;86if5≤c&lt;77if4≤c&lt;5∞ifc&lt;4</text></s>
<s sid="113"><CoreSc1 advantage="None" conceptID="Obs7" novelty="None" type="Obs"/><text>As illustrated in Fig. 2(b), DA,Gopt(c) is a staircase on the cost-delay plane, which is also called the efficient frontier in Bauer et al. (2000).</text></s>
<s sid="114"><CoreSc1 advantage="None" conceptID="Obs8" novelty="None" type="Obs"/><text>We would like to introduce several definitions.Definition 1</text></s>
<s sid="115"><CoreSc1 advantage="None" conceptID="Obs9" novelty="None" type="Obs"/><text>A point (x,y) is more representative than another point (x′,y′), denoted by (x,y)≺(x′,y′), if x≠x′ or y≠y′, moreover, x≤x′ and y≤y′.</text></s>
Definition 2
<s sid="116"><CoreSc1 advantage="None" conceptID="Obs10" novelty="None" type="Obs"/><text>Given a set S of the QoS parameters, (x,y)∈S is a representative point of S if there does not exist any other point (x′,y′)∈S such that (x′,y′)≺(x,y).</text></s>
<s sid="117"><CoreSc1 advantage="None" conceptID="Obs11" novelty="None" type="Obs"/><text>For example, in Fig. 2(b), there are totally six QoS parameters, but four of them, namely, (4,7), (5,6), (7,5), and (8,4), are the optimal representative points.11</text></s>
<s sid="118"><CoreSc1 advantage="None" conceptID="Mod18" novelty="None" type="Mod"/><text>The set of the representative points is called the non-dominated front (or Pareto front).</text></s>
<s sid="119"><CoreSc1 advantage="None" conceptID="Mod19" novelty="None" type="Mod"/><text>The corresponding paths of the representative points are called the non-dominated paths or Pareto optimal paths in the literature.</text></s>
<s sid="120"><CoreSc1 advantage="None" conceptID="Mod20" novelty="None" type="Mod"/><text>Denote PFs,gopt as the set of representative points on the efficient frontier from s to g.</text></s>
In Fig. 2(b), PFA,Gopt={(4,7),(5,6),(7,5),(8,4)}.
Definition 3
<s sid="121"><CoreSc1 advantage="None" conceptID="Mod21" novelty="None" type="Mod"/><text>Given a set of the optimal representative points PFopt, define R={(c,d)|(c′,d′)≺(c,d),(c′,d′)∈PFopt}.</text></s>
<s sid="122"><CoreSc1 advantage="None" conceptID="Mod22" novelty="None" type="Mod"/><text>The feasible area is defined as Afeasibleopt=R∪PFopt.</text></s>
<s sid="123"><CoreSc1 advantage="None" conceptID="Met17" novelty="None" type="Met"/><text>Definition 3 was also described in Bauer et al. (2000) and Cui et al. (2003, 2005).</text></s>
<s sid="124"><CoreSc1 advantage="None" conceptID="Con11" novelty="None" type="Con"/><text>Any request that falls in the feasible area must be supported by at least one path.</text></s>
<s sid="125"><CoreSc1 advantage="None" conceptID="Con12" novelty="None" type="Con"/><text>We call this request a feasible request.</text></s>
<s sid="126"><CoreSc1 advantage="None" conceptID="Con13" novelty="None" type="Con"/><text>The problem of precomputing the supported QoS aims at finding the feasible area Afeasibleopt so that a routing table can tell whether a request is feasible upon a request arrives.</text></s>
This problem is NP-complete.
<s sid="127"><CoreSc1 advantage="None" conceptID="Con14" novelty="None" type="Con"/><text>The feasible area can be uniquely defined by the set of the optimal representative points PFopt.</text></s>
<s sid="128"><CoreSc1 advantage="None" conceptID="Res28" novelty="None" type="Res"/><text>In Fig. 2(b), the shaded area is the feasible area which is on the upper right hand side of the efficient frontier.</text></s>
<s sid="129"><CoreSc1 advantage="None" conceptID="Res29" novelty="None" type="Res"/><text>For instance, Request (10,6) falls in the shaded area.</text></s>
<s sid="130"><CoreSc1 advantage="None" conceptID="Con15" novelty="None" type="Con"/><text>The paths (8,4) and (7,5) can serve this request.</text></s>
<s sid="131"><CoreSc1 advantage="None" conceptID="Con16" novelty="None" type="Con"/><text>Thus, this request is a feasible request.</text></s>
<s sid="132"><CoreSc1 advantage="None" conceptID="Con17" novelty="None" type="Con"/><text>Finding the optimal feasible area is NP-Complete (Orda and Sprintson, 2003).</text></s>
<s sid="133"><CoreSc1 advantage="None" conceptID="Con18" novelty="None" type="Con"/><text>Some existing works propose the approximation algorithms to estimate the feasible area.</text></s>
<s sid="134"><CoreSc1 advantage="None" conceptID="Con19" novelty="None" type="Con"/><text>However, no work analyzes the upper bound of the approximation error caused by the existing works, which is called distortion area in this work.</text></s>
<s sid="135"><CoreSc1 advantage="None" conceptID="Con20" novelty="None" type="Con"/><text>In this work, we first analyze the upper bound of the approximation error produced by the existing quantized algorithms.</text></s>
<s sid="136"><CoreSc1 advantage="None" conceptID="Con21" novelty="None" type="Con"/><text>We then propose a new method to estimate the feasible area, and also give the theoretical comparison between the existing schemes and our proposed method.</text></s>
<s sid="137"><CoreSc1 advantage="None" conceptID="Con22" novelty="None" type="Con"/><text>Analyzing the distortion area of the existing algorithms</text></s>
<s sid="138"><CoreSc1 advantage="None" conceptID="Con23" novelty="None" type="Con"/><text>In this section, we first present an exact pseudo-polynomial algorithm for computing the supported QoS with an integer cost metric.</text></s>
<s sid="139"><CoreSc1 advantage="None" conceptID="Con24" novelty="None" type="Con"/><text>In fact, this algorithm was mentioned in many existing literatures (Hassin, 1992; Orda and Sprintson, 2003).</text></s>
<s sid="140"><CoreSc1 advantage="None" conceptID="Con25" novelty="None" type="Con"/><text>We then present the existing quantization-based methods applied for precomputing the supported QoS.</text></s>
<s sid="141"><CoreSc1 advantage="None" conceptID="Obj22" novelty="None" type="Obj"/><text>Finally, we analyze the performance of the existing quantization-based algorithms based on the proposed metric, distortion area.</text></s>
<s sid="142"><CoreSc1 advantage="None" conceptID="Res30" novelty="None" type="Res"/><text>As mentioned in Section 1, distortion area is defined as the difference between the approximate supported QoS region calculated by an approximation algorithm and the optimal supported QoS region.</text></s>
<s sid="143"><CoreSc1 advantage="None" conceptID="Obs12" novelty="None" type="Obs"/><text>For instance, the shaded area in Fig. 3 shows the optimal supported QoS region while Fig. 4(a) shows an approximate supported QoS region.</text></s>
<s sid="144"><CoreSc1 advantage="None" conceptID="Obs13" novelty="None" type="Obs"/><text>We calculate the shaded area in Fig. 3 as 0.44 while that in Fig. 4(a) as 0.4.</text></s>
<s sid="145"><CoreSc1 advantage="None" conceptID="Res31" novelty="None" type="Res"/><text>The distortion area caused by the approximation algorithm is 0.04.</text></s>
<s sid="146"><CoreSc1 advantage="None" conceptID="Con26" novelty="None" type="Con"/><text>If we assume that the requirements of the connection request are uniformly distributed in the supported QoS region, we can consider that almost 10% of all the requests would be rejected by the approximation algorithm, while these requests actually can be supported by the network.</text></s>
<s sid="147"><CoreSc1 advantage="None" conceptID="Obj23" novelty="None" type="Obj"/><text>In the following, we would give the upper bound of the distortion area introduced by different algorithms.</text></s>
<s sid="148"><CoreSc1 advantage="None" conceptID="Obs14" novelty="None" type="Obs"/><text>Suppose that we arrange the points in PFs,gopt in cost-ascending order.</text></s>
<s sid="149"><CoreSc1 advantage="None" conceptID="Obs15" novelty="None" type="Obs"/><text>The first representative point rc=(Lc,Ud) corresponds to the minimum cost path, and the last representative point rd=(Uc,Ld) corresponds to the minimum delay path.</text></s>
<s sid="150"><CoreSc1 advantage="None" conceptID="Obs16" novelty="None" type="Obs"/><text>All other representative points must have a cost falling between Lc and Uc, and a delay falling between Ld and Ud (Bauer et al., 2000).</text></s>
<s sid="151"><CoreSc1 advantage="None" conceptID="Mod23" novelty="None" type="Mod"/><text>If we obtain all the representative points, we can derive the optimal delay function Ds,gopt(c), and vice versa.</text></s>
<s sid="152"><CoreSc1 advantage="None" conceptID="Mod24" novelty="None" type="Mod"/><text>For example, in Fig. 2(b), the QoS parameter of the minimum cost path is (4,7), and the QoS parameter of the minimum delay path is (8,4).</text></s>
<s sid="153"><CoreSc1 advantage="None" conceptID="Mod25" novelty="None" type="Mod"/><text>In order to compute the optimal delay function DA,Gopt(c), we just need to find the representative points (5,6) and (7,5), which have the costs falling between 4 and 8.</text></s>
<s sid="154"><CoreSc1 advantage="None" conceptID="Mod26" novelty="None" type="Mod"/><text>To make the problem tractable, we first consider that the cost metric associated with each link is integer.</text></s>
<s sid="155"><CoreSc1 advantage="None" conceptID="Mod27" novelty="None" type="Mod"/><text>For the ease of the subsequent discussion, we assume that Uc and Ud are the same, denoted by UB, and Lc and Ld are the same, denoted by LB=1.</text></s>
Exact algorithm
<s sid="156"><CoreSc1 advantage="None" conceptID="Mod28" novelty="None" type="Mod"/><text>Similar to Hassin (1992) and Orda and Sprintson (2003), we assume that, for simplicity, network can be represented by a directed acyclic graph (DAG).</text></s>
<s sid="157"><CoreSc1 advantage="None" conceptID="Obs17" novelty="None" type="Obs"/><text>The extension of the algorithm for a general graph is straightforward.</text></s>
<s sid="158"><CoreSc1 advantage="None" conceptID="Res32" novelty="None" type="Res"/><text>In DAG, the network nodes are numbered in a way such that (i,j)∈E implies i&lt;j.</text></s>
<s sid="159"><CoreSc1 advantage="None" conceptID="Res33" novelty="None" type="Res"/><text>If the cost metric of each link is an integer, we can develop a pseudo-polynomial algorithm for computing the supported QoS as follows:(1)Dg,g(c)←0,c≥0;Di,g(c)←∞,c≥0,i∈Vâ§¹{g};Di,g(c)=mink∈A(i){Dk,g(c-c(i,k))+d(i,k),Di,g(c-1)}c=0,1,2,3,…,UB,i∈V.</text></s>
<s sid="160"><CoreSc1 advantage="None" conceptID="Res34" novelty="None" type="Res"/><text>Orda and Sprintson (2003) and Hassin (1992) give the pseudo-polynomial algorithm description as the same as (1).</text></s>
<s sid="161"><CoreSc1 advantage="None" conceptID="Res35" novelty="None" type="Res"/><text>To compute {Di,g(c),c≥0} for all i∈V, we keep a table of |V| rows and UB columns, where one row for each node and one column for each integer cost value.</text></s>
<s sid="162"><CoreSc1 advantage="None" conceptID="Res36" novelty="None" type="Res"/><text>To ease our discussion, we label the nodes as 1,2,…,|V|.</text></s>
<s sid="163"><CoreSc1 advantage="None" conceptID="Res37" novelty="None" type="Res"/><text>The entry on Row i and Column j represents the estimated delay from Node i to Node g at Cost j.</text></s>
<s sid="164"><CoreSc1 advantage="None" conceptID="Res38" novelty="None" type="Res"/><text>Initially, Dg,g(j), for all j=0,1,…,UB, are all set to be zero while Di,g(j), for all i≠g and j=0,1,…,UB, are all set to be infinity.</text></s>
<s sid="165"><CoreSc1 advantage="None" conceptID="Res39" novelty="None" type="Res"/><text>In the first step, each neighbor u of g sets Du,g(c) to be du,g, where c=cu,g,cu,g+1,…,UB.</text></s>
<s sid="166"><CoreSc1 advantage="None" conceptID="Res40" novelty="None" type="Res"/><text>In step k, we update {Di,g(c),c≥0} for those nodes i that can be k hops away from g.</text></s>
<s sid="167"><CoreSc1 advantage="None" conceptID="Res41" novelty="None" type="Res"/><text>After |V|-1 steps, the algorithm terminates since no path can have more than (|V|-1) hops.</text></s>
<s sid="168"><CoreSc1 advantage="None" conceptID="Res42" novelty="None" type="Res"/><text>As referred to Orda and Sprintson (2003), the computational complexity of this pseudo-polynomial algorithm is O(|E|UB).</text></s>
Existing quantization-based algorithms
<s sid="169"><CoreSc1 advantage="None" conceptID="Res43" novelty="None" type="Res"/><text>In general, cost values are not necessarily integers.</text></s>
<s sid="170"><CoreSc1 advantage="None" conceptID="Mod29" novelty="None" type="Mod"/><text>The cost value of each link is quantized such that it is selected from a set of possible values, instead of the continuous real number line.</text></s>
<s sid="171"><CoreSc1 advantage="None" conceptID="Mod30" novelty="None" type="Mod"/><text>Given the lower bound and the upper bound of the cost values Lc and Uc, we obtain a set of possible quantized cost values, denoted by {s1,s2,…,sn}.</text></s>
<s sid="172"><CoreSc1 advantage="None" conceptID="Mod31" novelty="None" type="Mod"/><text>We then assume that each link or path cost is one of the quantized values.</text></s>
<s sid="173"><CoreSc1 advantage="None" conceptID="Mod32" novelty="None" type="Mod"/><text>For instance, if the cost value of a link cl falls between sj and sj+1, where j=1,…,n-1, we assume cl≈sj+1.</text></s>
<s sid="174"><CoreSc1 advantage="None" conceptID="Res44" novelty="None" type="Res"/><text>Hence, we can use (1) to compute the delay function at the samples.</text></s>
<s sid="175"><CoreSc1 advantage="None" conceptID="Res45" novelty="None" type="Res"/><text>We thus can obtain the approximated representative points based on the quantized cost values.</text></s>
<s sid="176"><CoreSc1 advantage="None" conceptID="Con27" novelty="None" type="Con"/><text>We call this method the quantization-based approximation method.</text></s>
<s sid="177"><CoreSc1 advantage="None" conceptID="Con28" novelty="None" type="Con"/><text>As mentioned in Section 2, the existing approximation algorithms generally apply this quantization method to solve the NP-complete problem.</text></s>
<s sid="178"><CoreSc1 advantage="None" conceptID="Bac10" novelty="None" type="Bac"/><text>Different algorithms can indeed apply different quantization methods (Orda and Sprintson, 2003; Hassin, 1992; Lorenz and Raz, 2001; Goel et al., 2001; Chen et al., 2008; Sahni, 1977; Xue et al., 2007).</text></s>
<s sid="179"><CoreSc1 advantage="None" conceptID="Res46" novelty="None" type="Res"/><text>Most of them apply uniform scaling, and the work in Orda and Sprintson (2003) applies logarithmic scaling.</text></s>
<s sid="180"><CoreSc1 advantage="None" conceptID="Res47" novelty="None" type="Res"/><text>Generally speaking, when applying uniform scaling, the set of possible cost values is denoted by {1,xδ,(x+1)δ,…,(x+m)δ,UB}, where x=min{k|(kδ&gt;1)(k∈Z+)}, and m=max{t|((x+t)δ&lt;UB)(t∈Z+)}. δ is the scaling parameter.</text></s>
<s sid="181"><CoreSc1 advantage="None" conceptID="Con29" novelty="None" type="Con"/><text>Different methods may select different values for δ.</text></s>
<s sid="182"><CoreSc1 advantage="None" conceptID="Obj24" novelty="None" type="Obj"/><text>We shall discuss how to calculate the distortion area produced by uniform scaling with the given scaling parameter δ.</text></s>
<s sid="183"><CoreSc1 advantage="None" conceptID="Res48" novelty="None" type="Res"/><text>In logarithmic scaling, the cost metric of each path is selected from {1,(1+δ),(1+δ)2,…,(1+δ)n,UB}, where n=max{j|((1+δ)j&lt;UB)(j∈Z+)}.</text></s>
<s sid="184"><CoreSc1 advantage="None" conceptID="Obs18" novelty="None" type="Obs"/><text>Consider the optimal delay function Ds,gopt(c) as depicted in Fig. 3.</text></s>
Let UB=2 and δ=0.2.
<s sid="185"><CoreSc1 advantage="None" conceptID="Obs19" novelty="None" type="Obs"/><text>By using logarithmic scaling, there are three samples for cost, namely, 1.2, 1.44, and 1.728.</text></s>
<s sid="186"><CoreSc1 advantage="None" conceptID="Obs20" novelty="None" type="Obs"/><text>From Fig. 3, the minimum delays at these cost values are 2.2, 1.8, and 1.3.</text></s>
<s sid="187"><CoreSc1 advantage="None" conceptID="Res49" novelty="None" type="Res"/><text>We thus obtain the resulting approximated delay function as exhibited in Fig. 5(a).</text></s>
<s sid="188"><CoreSc1 advantage="None" conceptID="Obs21" novelty="None" type="Obs"/><text>On the other hand, when uniform scaling is used, there are four samples between 1 and 2, which are 1.2, 1.4, 1.6, and 1.8.</text></s>
<s sid="189"><CoreSc1 advantage="None" conceptID="Obs22" novelty="None" type="Obs"/><text>The resulting approximated delay function is exhibited in Fig. 4(a).</text></s>
<s sid="190"><CoreSc1 advantage="None" conceptID="Obs23" novelty="None" type="Obs"/><text>It can be observed that different scaling schemes lead to different approximated delay functions.</text></s>
<s sid="191"><CoreSc1 advantage="None" conceptID="Res50" novelty="None" type="Res"/><text>Define Ds,g(c) (without the opt superscript) as the approximated delay function.</text></s>
<s sid="192"><CoreSc1 advantage="None" conceptID="Con30" novelty="None" type="Con"/><text>Without loss of generality, assume that the set of the possible cost values is K={1,k1,k2,…,km,UB}, which is generated by either uniform scaling or logarithmic scaling or any other quantization method.</text></s>
<s sid="193"><CoreSc1 advantage="None" conceptID="Con31" novelty="None" type="Con"/><text>Let k0=1 and km+1=UB, and we compute the value of Ds,g(c) at the quantized values within [1,UB] as follows:(2)Dg,g(c)=0,c≥0;Di,g(c)←∞,c≥0,i∈Vâ§¹{g};Di,g(c)=mink∈A(i){Dk,g(c-c(i,k))+d(i,k),Di,g(c′)}c=kj,c′=kj-1forj=0,…,m+1.If c=k0, then c′=0.</text></s>
Eq.
<s sid="194"><CoreSc1 advantage="None" conceptID="Con32" novelty="None" type="Con"/><text>(2) is similar to (1), except that the set of the cost values is different.</text></s>
<s sid="195"><CoreSc1 advantage="None" conceptID="Res51" novelty="None" type="Res"/><text>In (1), the QoS metric of each link is an integer.</text></s>
<s sid="196"><CoreSc1 advantage="None" conceptID="Res52" novelty="None" type="Res"/><text>We just compute the minimum delay value at the integer cost value.</text></s>
<s sid="197"><CoreSc1 advantage="None" conceptID="Res53" novelty="None" type="Res"/><text>On the other hand, in (2), the cost value is selected from a set of real numbers.</text></s>
<s sid="198"><CoreSc1 advantage="None" conceptID="Con33" novelty="None" type="Con"/><text>We compute the minimum delay values at the discrete cost values, which may not necessarily be integers.</text></s>
<s sid="199"><CoreSc1 advantage="None" conceptID="Con34" novelty="None" type="Con"/><text>By applying the quantization method, the representative points in Ds,g(c) must be at the selected cost values.</text></s>
<s sid="200"><CoreSc1 advantage="None" conceptID="Con35" novelty="None" type="Con"/><text>The pseudo-code of the approximation algorithm can be referred to http://www.eee.hku.hk/research/technical_reports.htm.</text></s>
<s sid="201"><CoreSc1 advantage="None" conceptID="Con36" novelty="None" type="Con"/><text>As we only consider a limited number of the cost values, some representative points may be missed out under the estimation.</text></s>
<s sid="202"><CoreSc1 advantage="None" conceptID="Res54" novelty="None" type="Res"/><text>A drop in the minimum delay may happen at a later quantized cost value.</text></s>
<s sid="203"><CoreSc1 advantage="None" conceptID="Obs24" novelty="None" type="Obs"/><text>For example, the representative point (1.5,1.6) appears in Fig. 3 but not in Fig. 5(a).</text></s>
<s sid="204"><CoreSc1 advantage="None" conceptID="Obs25" novelty="None" type="Obs"/><text>Besides, the optimal delay function in Fig. 3 drops to 1.3 at cost 1.7 but the drop occurs at 1.8 in Fig. 4(a).</text></s>
<s sid="205"><CoreSc1 advantage="None" conceptID="Res55" novelty="None" type="Res"/><text>In other words, the scaling method can overestimate the delay at some costs.</text></s>
<s sid="206"><CoreSc1 advantage="None" conceptID="Res56" novelty="None" type="Res"/><text>The following lemma describes this phenomena.Lemma 1</text></s>
<s sid="207"><CoreSc1 advantage="None" conceptID="Res57" novelty="None" type="Res"/><text>For any c&gt;0, if Ds,g(c)&lt;∞, Ds,g(c)≥Ds,gopt(c).</text></s>
Proof
<s sid="208"><CoreSc1 advantage="None" conceptID="Res58" novelty="None" type="Res"/><text>Ds,g(c) is initially set to infinity.</text></s>
<s sid="209"><CoreSc1 advantage="None" conceptID="Res59" novelty="None" type="Res"/><text>According to (2), if Ds,g(c)&lt;∞, there exists a physical path satisfying Request (c,Ds,g(c)).</text></s>
<s sid="210"><CoreSc1 advantage="None" conceptID="Res60" novelty="None" type="Res"/><text>If Ds,g(c)&lt;Ds,gopt(c), the optimal minimum delay from s to g with the cost constraint of c becomes Ds,g(c), which is less than Ds,gopt(c).</text></s>
<s sid="211"><CoreSc1 advantage="None" conceptID="Res61" novelty="None" type="Res"/><text>In this case, Ds,gopt(c) is no more the optimal delay function, which contradicts our assumption.□</text></s>
<s sid="212"><CoreSc1 advantage="None" conceptID="Res62" novelty="None" type="Res"/><text>For ease of discussion, we drop the subscripts s and g in the delay functions and simply use D(c) and Dopt(c) instead when the context is clear.</text></s>
Distortion area analysis
<s sid="213"><CoreSc1 advantage="None" conceptID="Obs26" novelty="None" type="Obs"/><text>Let PF be the approximated representative points found by the algorithm.</text></s>
<s sid="214"><CoreSc1 advantage="None" conceptID="Obs27" novelty="None" type="Obs"/><text>For instance, in Fig. 4(a), PF has (1,2.2), (1.4,1.8), (1.6,1.5), (1.8,1.3), and (2,1).</text></s>
<s sid="215"><CoreSc1 advantage="None" conceptID="Obs28" novelty="None" type="Obs"/><text>PFopt has (1,2.2), (1.4,1.8), (1.5,1.6), (1.6,1.5), (1.7,1.3), and (2,1), as illustrated in Fig. 3.</text></s>
<s sid="216"><CoreSc1 advantage="None" conceptID="Obs29" novelty="None" type="Obs"/><text>For each point x on the cost-delay plane, denote x·c and x·d as the cost metric and delay metric of this point, respectively.</text></s>
<s sid="217"><CoreSc1 advantage="None" conceptID="Obs30" novelty="None" type="Obs"/><text>For each representative point r′∈PF, we have r′·d=D(r′·c).</text></s>
By Lemma 1, Dopt(r′·c)≤D(r′·c)=r′·d.
<s sid="218"><CoreSc1 advantage="None" conceptID="Res63" novelty="None" type="Res"/><text>This implies that there exists a representative point r∈PFopt such that r≺r′ or r=r′.</text></s>
<s sid="219"><CoreSc1 advantage="None" conceptID="Res64" novelty="None" type="Res"/><text>Let Afeasible be the feasible area estimated by an algorithm, which is defined by PF.</text></s>
We thus have Afeasible⊆Afeasibleopt.
<s sid="220"><CoreSc1 advantage="None" conceptID="Res65" novelty="None" type="Res"/><text>As mentioned in Section 1, the distortion area is defined as Aerror=Afeasibleoptâ§¹Afeasible.</text></s>
<s sid="221"><CoreSc1 advantage="None" conceptID="Res66" novelty="None" type="Res"/><text>Although Afeasibleopt and Afeasible are both infinite, Aerror must be finite since both Afeasibleopt and Afeasible contain the bounded minimum cost and minimum delay representative points.</text></s>
<s sid="222"><CoreSc1 advantage="None" conceptID="Res67" novelty="None" type="Res"/><text>As discussed in Section 1, the distortion area reflects the admission control performance of the network.</text></s>
<s sid="223"><CoreSc1 advantage="None" conceptID="Goa4" novelty="None" type="Goa"/><text>We apply the distortion area as the metric to evaluate the performance of the quantization-based algorithms for estimating the supported QoS.</text></s>
<s sid="224"><CoreSc1 advantage="None" conceptID="Res68" novelty="None" type="Res"/><text>Lemma 1 implies that if D(c)=Dopt(c′), c≥c′.</text></s>
For example, in Figs.
<s sid="225"><CoreSc1 advantage="None" conceptID="Res69" novelty="None" type="Res"/><text>3 and 5(a), the corresponding costs for delay=2 are 1.4 and 1.44, respectively, where the one on the approximation function is larger.</text></s>
<s sid="226"><CoreSc1 advantage="None" conceptID="Con37" novelty="None" type="Con"/><text>The cost deviation captures the difference in the cost values of the optimal and approximated delay functions, as referred to Definition 4.Definition 4</text></s>
<s sid="227"><CoreSc1 advantage="None" conceptID="Con38" novelty="None" type="Con"/><text>If c0 is the cost value of a representative point, we call c0 a representative cost.</text></s>
<s sid="228"><CoreSc1 advantage="None" conceptID="Res70" novelty="None" type="Res"/><text>The cost deviation at the representative cost c0 on Dopt(c), denoted as CD(c0), is min {c|D(c)≤Dopt(c0)}-c0.</text></s>
<s sid="229"><CoreSc1 advantage="None" conceptID="Res71" novelty="None" type="Res"/><text>The existing algorithms also give the upper bound of the cost deviation by using different quantization methods.</text></s>
<s sid="230"><CoreSc1 advantage="None" conceptID="Res72" novelty="None" type="Res"/><text>For instance, it has been shown (Hassin, 1992) that the cost-deviation at any cost value is no more than Hδ if we apply the scaling set K={1,δ,2δ,…,mδ,UB}, where H is the maximum number of hops in the network.</text></s>
<s sid="231"><CoreSc1 advantage="None" conceptID="Con39" novelty="None" type="Con"/><text>The work in Orda and Sprintson (2003) also shows that the cost-deviation at cost value c0 is no more than ((1+δ)H-1)c0 by using logarithmic scaling.</text></s>
<s sid="232"><CoreSc1 advantage="None" conceptID="Con40" novelty="None" type="Con"/><text>Since Afeasible⊆Afeasibleopt, the cost deviation at any cost value cannot be negative by using any kind of quantization method.</text></s>
<s sid="233"><CoreSc1 advantage="None" conceptID="Obs31" novelty="None" type="Obs"/><text>Generally, denote Cmax as the maximum cost-deviation at all the cost values.</text></s>
<s sid="234"><CoreSc1 advantage="None" conceptID="Obj25" novelty="None" type="Obj"/><text>It is the time to discuss how to calculate the distortion area based on PFopt={r0,r1,…,rn-1,rn} and PF={r0′,r1′,…,rm′}, where r0=r0′=rc, rn=rm′=rd.</text></s>
<s sid="235"><CoreSc1 advantage="None" conceptID="Obs32" novelty="None" type="Obs"/><text>Suppose that the points in PFopt and PF are sorted in cost-ascending order.</text></s>
<s sid="236"><CoreSc1 advantage="None" conceptID="Obs33" novelty="None" type="Obs"/><text>Note that the first and the last representative points of PFopt and PF are the same because these two points are the minimum cost and minimum delay representative points, respectively.</text></s>
<s sid="237"><CoreSc1 advantage="None" conceptID="Obs34" novelty="None" type="Obs"/><text>They can be easily found out by Dijkstra's algorithm.</text></s>
<s sid="238"><CoreSc1 advantage="None" conceptID="Goa5" novelty="None" type="Goa"/><text>We first study how to calculate the distortion area between the delay values of two consecutive representative points ri and ri-1 in PFopt.</text></s>
<s sid="239"><CoreSc1 advantage="None" conceptID="Res73" novelty="None" type="Res"/><text>By Definition 4, the point (ri.c+CD(ri.c),ri.d) is on the efficient frontier defined by {D(c),c≥0}.</text></s>
<s sid="240"><CoreSc1 advantage="None" conceptID="Res74" novelty="None" type="Res"/><text>If there is no representative point in PF located in the area [0,UB]×[ri·d,ri-1·d], the area [ri·c,ri·c+CD(ri·c)]×[ri·d,ri-1·d] is NOT included in the feasible area found by the scaling mechanism.</text></s>
<s sid="241"><CoreSc1 advantage="None" conceptID="Res75" novelty="None" type="Res"/><text>The distortion area between the delay values of r1·d and r2·d is (r1·d-r2·d)·CD(r2·c), where CD(r2·c)=r3′·c-r2.c.</text></s>
<s sid="242"><CoreSc1 advantage="None" conceptID="Obs35" novelty="None" type="Obs"/><text>If some representative points in PF, denoted by {rk′,…,rk+j′}, are located in the region spanned by [0,UB]×(ri·d,ri-1·d], rk+l′·d&gt;ri.d, rk+l′·c&lt;ri·c+CD(ri·c) for all l=0,…,j.</text></s>
<s sid="243"><CoreSc1 advantage="None" conceptID="Res76" novelty="None" type="Res"/><text>This means that all these representative points are located in the area [ri·c,ri·c+CD(ri·c)]×(ri·d,ri-1·d].</text></s>
<s sid="244"><CoreSc1 advantage="None" conceptID="Res77" novelty="None" type="Res"/><text>By Definition 4, we have CD(r1·c)=r3′·c, and we can observe that both points r1′ and r2′ are located in the area (r1·d,rc·d]×[r1·c,r1·c+CD(r1·c)].</text></s>
<s sid="245"><CoreSc1 advantage="None" conceptID="Res78" novelty="None" type="Res"/><text>Therefore, the distortion area between the delay values of ri·d and ri-1·d is no more than (ri-1·d-ri·d)·CD(ri·c).</text></s>
<s sid="246"><CoreSc1 advantage="None" conceptID="Res79" novelty="None" type="Res"/><text>The total distortion area is calculated by adding the distortion areas between the delay values of two consecutive optimal representative points as follows:(3)Aerror=∑i=1nCD(ri·c)·(ri-1·d-ri·d)≤Cmax·(∑i=1n(ri-1·d-ri·d))≤Cmax·UB</text></s>
<s sid="247"><CoreSc1 advantage="None" conceptID="Res80" novelty="None" type="Res"/><text>For uniform scaling, we have(4)Aerroruni≤H·δ·UB=εUB,since Cmax≤Hδ and δ=ε/H.</text></s>
<s sid="248"><CoreSc1 advantage="None" conceptID="Res81" novelty="None" type="Res"/><text>Similarly, for logarithmic scaling, we have(5)Aerrorlog≤((1+δ)H-1)UB·UB&lt;εUB2(δ=ε2H),since Cmax≤((1+δ)H-1)UB and δ=ε/2H.</text></s>
Further reducing the error
<s sid="249"><CoreSc1 advantage="None" conceptID="Con41" novelty="None" type="Con"/><text>In this section, we propose a strategy to further reduce the distortion area, which is called two-dimensional scaling.</text></s>
<s sid="250"><CoreSc1 advantage="None" conceptID="Res82" novelty="None" type="Res"/><text>Two-dimensional scaling works with any quantization method, such as uniform scaling or logarithmic scaling.</text></s>
<s sid="251"><CoreSc1 advantage="None" conceptID="Res83" novelty="None" type="Res"/><text>We then calculate the upper bound of the distortion area produced by two-dimensional scaling.</text></s>
<s sid="252"><CoreSc1 advantage="None" conceptID="Res84" novelty="None" type="Res"/><text>Finally, we consider both quantization schemes, namely, uniform scaling and logarithmic scaling, and compare the error of two-dimensional scaling with that of the existing quantization-based algorithms.</text></s>
Two-dimensional scaling
<s sid="253"><CoreSc1 advantage="None" conceptID="Mod33" novelty="None" type="Mod"/><text>In the existing approximation algorithms, the cost metric is quantized, so that we can get the approximate delay function D(c).</text></s>
<s sid="254"><CoreSc1 advantage="None" conceptID="Mod34" novelty="None" type="Mod"/><text>If we indeed quantize the delay metric by using the same scaling mechanism (logarithmic scaling or uniform scaling), we would get a different approximate cost function, denoted by C(d).</text></s>
<s sid="255"><CoreSc1 advantage="None" conceptID="Res85" novelty="None" type="Res"/><text>D(c) and C(d) may represent the different approximate supported QoS regions.</text></s>
<s sid="256"><CoreSc1 advantage="None" conceptID="Res86" novelty="None" type="Res"/><text>If we combine the two supported QoS regions represented by D(c) and C(d), we can get a more accurate supported QoS region than the one denoted by either one.</text></s>
<s sid="257"><CoreSc1 advantage="None" conceptID="Obs36" novelty="None" type="Obs"/><text>For example, consider the optimal delay function depicted in Fig. 3.</text></s>
<s sid="258"><CoreSc1 advantage="None" conceptID="Mod35" novelty="None" type="Mod"/><text>If we use the logarithmic scaling method on cost, we get the approximated function in Fig. 5(a).</text></s>
<s sid="259"><CoreSc1 advantage="None" conceptID="Obs37" novelty="None" type="Obs"/><text>On the other hand, if we quantize on delay, the function becomes the one shown in Fig. 5(b).</text></s>
<s sid="260"><CoreSc1 advantage="None" conceptID="Res87" novelty="None" type="Res"/><text>The sets of the approximate representative points defined by the two functions are different.</text></s>
<s sid="261"><CoreSc1 advantage="None" conceptID="Res88" novelty="None" type="Res"/><text>If we combine both sets, another set of seven representative points, i.e.</text></s>
<s sid="262"><CoreSc1 advantage="None" conceptID="Res89" novelty="None" type="Res"/><text>{(1,2.2), (1.4,2.0736), (1.44,1.8), (1.5,1.728), (1.7,1.44), (1.728,1.3), (2,1)} is obtained, as shown in Fig. 6(b).</text></s>
<s sid="263"><CoreSc1 advantage="None" conceptID="Res90" novelty="None" type="Res"/><text>The supported QoS region of Fig. 6(b) is larger than that of Fig. 5(a) or (b).</text></s>
<s sid="264"><CoreSc1 advantage="None" conceptID="Res91" novelty="None" type="Res"/><text>Our approximation algorithm is as follows.</text></s>
<s sid="265"><CoreSc1 advantage="None" conceptID="Res92" novelty="None" type="Res"/><text>Each node keeps two sets of the approximate representative points, PFu,gd and PFu,gc.</text></s>
<s sid="266"><CoreSc1 advantage="None" conceptID="Res93" novelty="None" type="Res"/><text>PFu,gd is obtained by computing the minimum delay with all possible quantized cost values, while PFu,gc is obtained by computing the minimum cost with all possible quantized delay values.</text></s>
<s sid="267"><CoreSc1 advantage="None" conceptID="Res94" novelty="None" type="Res"/><text>Both PFu,gd and PFu,gc may define different supported QoS regions.</text></s>
<s sid="268"><CoreSc1 advantage="None" conceptID="Res95" novelty="None" type="Res"/><text>We combine both sets to define the supported QoS region from u to g.</text></s>
<s sid="269"><CoreSc1 advantage="None" conceptID="Res96" novelty="None" type="Res"/><text>The pseudo-code of our algorithm is referred to http://www.eee.hku.hk/research/technical_reports.htm.</text></s>
<s sid="270"><CoreSc1 advantage="None" conceptID="Res97" novelty="None" type="Res"/><text>The computational complexity of the quantization-based approximation algorithm depends on the number of quantized values (Orda and Sprintson, 2003).</text></s>
<s sid="271"><CoreSc1 advantage="None" conceptID="Con42" novelty="None" type="Con"/><text>The computational overhead of our algorithm is twice that of the existing quantization-based algorithm, since our algorithm conducts the quantization twice while the existing algorithm does once.</text></s>
<s sid="272"><CoreSc1 advantage="None" conceptID="Con43" novelty="None" type="Con"/><text>For clarity, the existing quantization-based algorithms use cost-scaling, while our approach employs two-dimensional scaling.</text></s>
<s sid="273"><CoreSc1 advantage="None" conceptID="Res98" novelty="None" type="Res"/><text>Either kind of quantization schemes, such as uniform scaling or logarithmic scaling, can be applied through cost-scaling or two-dimensional scaling.</text></s>
<s sid="274"><CoreSc1 advantage="None" conceptID="Res99" novelty="None" type="Res"/><text>Note that intuitively, two-dimensional scaling produces the smaller distortion area but the larger computational overhead if it uses the same scaling parameter as cost-scaling.</text></s>
<s sid="275"><CoreSc1 advantage="None" conceptID="Res100" novelty="None" type="Res"/><text>In the following, we will show that with the condition that both cost-scaling and two-dimensional scaling produce the same computational overhead, two-dimensional scaling yields the smaller upper bound of the distortion area.</text></s>
<s sid="276"><CoreSc1 advantage="None" conceptID="Res101" novelty="None" type="Res"/><text>Distortion area of two-dimensional scaling</text></s>
<s sid="277"><CoreSc1 advantage="None" conceptID="Con44" novelty="None" type="Con"/><text>In this subsection, we describe how to calculate the distortion area produced by our mechanism.</text></s>
<s sid="278"><CoreSc1 advantage="None" conceptID="Res102" novelty="None" type="Res"/><text>Let PFopt={r0,r1,…,rn}, where r0=rc, rn=rd, and ri·c&lt;ri+1·c for all i=0,…,n-1.</text></s>
<s sid="279"><CoreSc1 advantage="None" conceptID="Res103" novelty="None" type="Res"/><text>With the similar method described in Section 4.3, we first calculate the distortion area between two consecutive delay values ri·d and ri-1·d, where i=1,…,n-1.</text></s>
<s sid="280"><CoreSc1 advantage="None" conceptID="Res104" novelty="None" type="Res"/><text>In two-dimensional scaling, the delay metric is also quantized.</text></s>
<s sid="281"><CoreSc1 advantage="None" conceptID="Res105" novelty="None" type="Res"/><text>Let Copt(d) and C(d) be the optimal cost function and the approximated cost function, respectively.</text></s>
<s sid="282"><CoreSc1 advantage="None" conceptID="Res106" novelty="None" type="Res"/><text>Similar to Definition 4, we define delay deviation as follows.Definition 5</text></s>
<s sid="283"><CoreSc1 advantage="None" conceptID="Res107" novelty="None" type="Res"/><text>The delay deviation at the representative delay d0 on Copt(d), denoted as DD(d0), is min {d|C(d)≤Copt(d0)}-d0.</text></s>
<s sid="284"><CoreSc1 advantage="None" conceptID="Res108" novelty="None" type="Res"/><text>In two-dimensional scaling, the cost metric and delay metric are quantized by the same method.</text></s>
<s sid="285"><CoreSc1 advantage="None" conceptID="Res109" novelty="None" type="Res"/><text>Thus, the calculation of the delay deviation at a certain delay value is similar to that of the cost deviation.</text></s>
<s sid="286"><CoreSc1 advantage="None" conceptID="Res110" novelty="None" type="Res"/><text>In other words, by using uniform scaling, the delay deviation at a certain delay value d0 is no more than Hδ, and by using logarithmic scaling, the delay deviation is no more than ((1+δ)H-1)d0.</text></s>
<s sid="287"><CoreSc1 advantage="None" conceptID="Res111" novelty="None" type="Res"/><text>By setting the same upper bound for both cost metric and delay metric as UB, the upper bound of the delay deviation with logarithmic scaling is the same as that of cost deviation.</text></s>
<s sid="288"><CoreSc1 advantage="None" conceptID="Res112" novelty="None" type="Res"/><text>Thus, Cmax denotes the maximum cost deviation at any cost value as well as the maximum delay deviation at any delay value produced by two-dimensional scaling.</text></s>
<s sid="289"><CoreSc1 advantage="None" conceptID="Con45" novelty="None" type="Con"/><text>By Definitions 4 and 5, the points (ri·c+CD(ri·c),ri·d) and (ri·c,ri·d+DD(ri·d)) are in the feasible area found by our mechanism.</text></s>
<s sid="290"><CoreSc1 advantage="None" conceptID="Con46" novelty="None" type="Con"/><text>This implies that the distortion area must be no more than CD(ri·c)·DD(ri·d).</text></s>
<s sid="291"><CoreSc1 advantage="None" conceptID="Res113" novelty="None" type="Res"/><text>The total distortion area produced by two-dimensional scaling is no more than ∑i=1n-1CD(ri·c)·DD(ri·d).</text></s>
<s sid="292"><CoreSc1 advantage="None" conceptID="Res114" novelty="None" type="Res"/><text>We can see that the total distortion area of two-dimensional scaling depends on the number of the optimal representative points n.</text></s>
<s sid="293"><CoreSc1 advantage="None" conceptID="Res115" novelty="None" type="Res"/><text>To gain the insight into n, we assume that the QoS metrics of all paths are independent and identically distributed (i.i.d.) random variables (Van Mieghem and Kuipers, 2003).</text></s>
<s sid="294"><CoreSc1 advantage="None" conceptID="Res116" novelty="None" type="Res"/><text>The following lemma is established in Van Mieghem and Kuipers (2003).Lemma 2</text></s>
<s sid="295"><CoreSc1 advantage="None" conceptID="Res117" novelty="None" type="Res"/><text>The expected number of the representative points among a set of T i.i.d.</text></s>
<s sid="296"><CoreSc1 advantage="None" conceptID="Obs38" novelty="None" type="Obs"/><text>points in K-dimensional space is bounded above by (lnT)K-1.</text></s>
<s sid="297"><CoreSc1 advantage="None" conceptID="Res118" novelty="None" type="Res"/><text>Given a source s, a destination g, and other h-1 nodes in the network, there are at most (h-1)! different h-hop paths from s to g.</text></s>
<s sid="298"><CoreSc1 advantage="None" conceptID="Res119" novelty="None" type="Res"/><text>Therefore, there are at most (h-1)!|V-2|h-1 h-hop paths but |V-2|h-1 different QoS parameters for all h-hop paths from s to g.</text></s>
<s sid="299"><CoreSc1 advantage="None" conceptID="Res120" novelty="None" type="Res"/><text>Therefore, the maximum number of the QoS parameters of the paths from s to g is ∑j=0|V|-2|V-2|h-1=2|V|-2.</text></s>
<s sid="300"><CoreSc1 advantage="None" conceptID="Res121" novelty="None" type="Res"/><text>For the two-dimensional case, it holds that (lnT)K-1≤ln2|V|-2≤|V|-2.</text></s>
We thus have n≤|V|-2.
<s sid="301"><CoreSc1 advantage="None" conceptID="Res122" novelty="None" type="Res"/><text>Therefore, the distortion area introduced due to two-dimensional scaling can be calculated as(6)Aerror2-D=∑i=1n-1CD(ri·c)·DD(ri.d)≤(|V|-2)·Cmax2</text></s>
<s sid="302"><CoreSc1 advantage="None" conceptID="Res123" novelty="None" type="Res"/><text>If two-dimensional uniform scaling is applied, we have DD(ri·d)≤(|V|-1)δ and CD(ri·d)≤(|V|-1)δ.</text></s>
<s sid="303"><CoreSc1 advantage="None" conceptID="Res124" novelty="None" type="Res"/><text>Therefore, the distortion area is(7)Aerror2-D,uni≤(|V|-2)·((|V|-1)δ)2=(|V|-2)ε2where δ=ε/(|V|-1).</text></s>
<s sid="304"><CoreSc1 advantage="None" conceptID="Res125" novelty="None" type="Res"/><text>Similarly, if two-dimensional logarithmic scaling is employed, we have DD(ri·d)≤((1+δ)|V|-1-1)·ri·d and CD(ri·c)≤((1+δ)|V|-1-1)·ri·c.</text></s>
<s sid="305"><CoreSc1 advantage="None" conceptID="Res126" novelty="None" type="Res"/><text>Therefore, the distortion area is(8)Aerror2-D,log≤(|V|-2)·((1+δ)|V|-1-1)2rc·d·rd·c&lt;(|V|-2)((1+δ)|V|-1-1)2UB2≤(|V|-2)ε2UB2where δ=ε/2(|V|-1).</text></s>
Performance comparison
<s sid="306"><CoreSc1 advantage="None" conceptID="Con47" novelty="None" type="Con"/><text>According to the discussion in Sections 4.3 and 5.2, we know that the computational overhead of a quantization-based algorithm depends on the quantization scheme employed.</text></s>
<s sid="307"><CoreSc1 advantage="None" conceptID="Con48" novelty="None" type="Con"/><text>In this section, we consider both quantization schemes, namely, uniform scaling and logarithmic scaling, and compare the error produced by our approach and cost-scaling under the condition that they produce almost the same computational overhead.</text></s>
<s sid="308"><CoreSc1 advantage="None" conceptID="Con49" novelty="None" type="Con"/><text>If the same scaling parameter δ is used, it is obvious that two-dimensional scaling generally outperforms cost-scaling by producing a smaller distortion area.</text></s>
<s sid="309"><CoreSc1 advantage="None" conceptID="Res127" novelty="None" type="Res"/><text>For two-dimensional scaling, the supported QoS region is defined by both PFd and PFc.</text></s>
<s sid="310"><CoreSc1 advantage="None" conceptID="Res128" novelty="None" type="Res"/><text>However, for cost-scaling, the supported QoS region is defined by PFd.</text></s>
<s sid="311"><CoreSc1 advantage="None" conceptID="Res129" novelty="None" type="Res"/><text>On the other hand, two-dimensional scaling yields a larger computational overhead if both techniques apply the same scaling parameter.</text></s>
<s sid="312"><CoreSc1 advantage="None" conceptID="Con50" novelty="None" type="Con"/><text>According to Section 4, we know that the computational overheads of both our proposed approach and cost-scaling heavily depend on the number of possible cost values (and delay values for our approach) caused by the quantization scheme.</text></s>
<s sid="313"><CoreSc1 advantage="None" conceptID="Con51" novelty="None" type="Con"/><text>We believe that if both approaches produce the same number of the possible quantized cost values (and delay values for our approach), they produce almost the same computational overhead.</text></s>
<s sid="314"><CoreSc1 advantage="None" conceptID="Con52" novelty="None" type="Con"/><text>Thus, we are going to discuss how to set the scaling parameter, such that the total number of the possible quantized values is the same.</text></s>
<s sid="315"><CoreSc1 advantage="None" conceptID="Res130" novelty="None" type="Res"/><text>Given a scaling parameter δ, the number of possible cost values by uniform scaling is UB/δ, and that by logarithmic scaling is log1+δUB, as referred to Section 4.2.</text></s>
<s sid="316"><CoreSc1 advantage="None" conceptID="Res131" novelty="None" type="Res"/><text>For ease of discussion, denote δt and δs as the scaling parameters adopted in two-dimensional scaling and cost-scaling, respectively.</text></s>
<s sid="317"><CoreSc1 advantage="None" conceptID="Res132" novelty="None" type="Res"/><text>If we use uniform scaling, by setting δt=2δs, we can consider that the total number of quantized cost and delay values for two-dimensional scaling is the same as that for cost-scaling.</text></s>
<s sid="318"><CoreSc1 advantage="None" conceptID="Res133" novelty="None" type="Res"/><text>We thus consider both algorithms incur a comparable computational overhead.</text></s>
<s sid="319"><CoreSc1 advantage="None" conceptID="Res134" novelty="None" type="Res"/><text>If we use logarithmic scaling, by setting δt=2δs, the total number of possible cost values and delay values by two-dimensional scaling is 2log1+2δsUB, and the number of cost values by cost-scaling is log1+δsUB.</text></s>
<s sid="320"><CoreSc1 advantage="None" conceptID="Res135" novelty="None" type="Res"/><text>When δs is very small, say δs≤0.1, we have 1+2δs≃(1+δs)2.</text></s>
This means that 2log1+2δsUB≃log1+δsUB.
<s sid="321"><CoreSc1 advantage="None" conceptID="Res136" novelty="None" type="Res"/><text>Therefore, if we set δt=2δs, we can consider that the computational overheads produced by two-dimensional scaling and cost-scaling are comparable.</text></s>
<s sid="322"><CoreSc1 advantage="None" conceptID="Res137" novelty="None" type="Res"/><text>Denote δ as the scaling parameter used in cost-scaling.</text></s>
<s sid="323"><CoreSc1 advantage="None" conceptID="Res138" novelty="None" type="Res"/><text>For two-dimensional scaling, the scaling parameter of 2δ is used.</text></s>
<s sid="324"><CoreSc1 advantage="None" conceptID="Res139" novelty="None" type="Res"/><text>If we apply uniform scaling, δ=ε/|V|-1.</text></s>
<s sid="325"><CoreSc1 advantage="None" conceptID="Res140" novelty="None" type="Res"/><text>By (4) and (7), the distortion area for cost-scaling and two-dimensional scaling is upper bounded by ε·UB and 4(|V|-2)ε2, respectively.</text></s>
For logarithmic scaling, δ=ε/2(|V|-1).
<s sid="326"><CoreSc1 advantage="None" conceptID="Res141" novelty="None" type="Res"/><text>By (5) and (8), the distortion area for cost-scaling and two-dimensional scaling is upper bounded by ε·UB2 and 4(|V|-2)·ε2·UB2, respectively.</text></s>
<s sid="327"><CoreSc1 advantage="None" conceptID="Res142" novelty="None" type="Res"/><text>Since UB is the maximum cost value for a path in the network, it is upper bounded by (|V|-1)W, where W is the maximum cost value of each link.</text></s>
<s sid="328"><CoreSc1 advantage="None" conceptID="Res143" novelty="None" type="Res"/><text>For uniform scaling with ε&lt;W/4, two-dimensional scaling yields a smaller upper bound on the distortion area than cost-scaling.</text></s>
<s sid="329"><CoreSc1 advantage="None" conceptID="Res144" novelty="None" type="Res"/><text>For logarithmic scaling with 4(|V|-2)ε&lt;1, two-dimensional scaling provides a better error guarantee.</text></s>
<s sid="330"><CoreSc1 advantage="None" conceptID="Res145" novelty="None" type="Res"/><text>For the worst case, the distortion area incurred equals to its upper bound.</text></s>
<s sid="331"><CoreSc1 advantage="None" conceptID="Res146" novelty="None" type="Res"/><text>This means that the distortion area for two-dimensional scaling is smaller than that for cost-scaling in the worst case analysis.</text></s>
<s sid="332"><CoreSc1 advantage="None" conceptID="Res147" novelty="None" type="Res"/><text>We notice that the distortion area for two-dimensional scaling is proportional to the square of ε, while that for cost-scaling is proportional to ε.</text></s>
Generally speaking, ε&lt;1.
<s sid="333"><CoreSc1 advantage="None" conceptID="Res148" novelty="None" type="Res"/><text>As εincreases, the distortion area of two-dimensional scaling grows much slower than that of cost-scaling.</text></s>
<s sid="334"><CoreSc1 advantage="None" conceptID="Res149" novelty="None" type="Res"/><text>On the other hand, the total number of the cost and delay values taken by two-dimensional scaling reduces with the same rate as that of cost-scaling.</text></s>
<s sid="335"><CoreSc1 advantage="None" conceptID="Con53" novelty="None" type="Con"/><text>This implies that two-dimensional scaling can effectively reduce the computational overhead with a smaller increase in the distortion area when compared with cost-scaling.</text></s>
<s sid="336"><CoreSc1 advantage="None" conceptID="Res150" novelty="None" type="Res"/><text>As the actual improvement depends on the network topology, we have conducted extensive simulations to study the performance, which will be discussed in Section 6.</text></s>
<s sid="337"><CoreSc1 advantage="None" conceptID="Res151" novelty="None" type="Res"/><text>We also notice that by setting the same scaling parameter δ, uniform scaling yields a smaller approximation error but a larger computational overhead than logarithmic scaling.</text></s>
Performance evaluation
<s sid="338"><CoreSc1 advantage="None" conceptID="Con54" novelty="None" type="Con"/><text>In this section, we present our simulation results.</text></s>
<s sid="339"><CoreSc1 advantage="None" conceptID="Con55" novelty="None" type="Con"/><text>We compare our proposed method, two-dimensional scaling, with cost-scaling.</text></s>
<s sid="340"><CoreSc1 advantage="None" conceptID="Con56" novelty="None" type="Con"/><text>We evaluate the performance of the algorithms from the perspectives of the approximation error and the computational overhead.</text></s>
<s sid="341"><CoreSc1 advantage="None" conceptID="Con57" novelty="None" type="Con"/><text>As discussed in Section 1, we use the distortion area as the evaluation metric for the accuracy performance of the quantization-based approximation algorithms.</text></s>
<s sid="342"><CoreSc1 advantage="None" conceptID="Con58" novelty="None" type="Con"/><text>We use the exhaustive method to compute the optimal feasible area Aopt.</text></s>
<s sid="343"><CoreSc1 advantage="None" conceptID="Con59" novelty="None" type="Con"/><text>Denote A as the estimated feasible area computed by an algorithm.</text></s>
<s sid="344"><CoreSc1 advantage="None" conceptID="Res152" novelty="None" type="Res"/><text>The distortion area is thus Aopt-A·(Aopt-A)/Aopt is called the region-deviation ratio which is proportional to the distortion area.</text></s>
<s sid="345"><CoreSc1 advantage="None" conceptID="Res153" novelty="None" type="Res"/><text>We compare the region-deviation ratio for different quantization-based approximation algorithms.</text></s>
<s sid="346"><CoreSc1 advantage="None" conceptID="Res154" novelty="None" type="Res"/><text>It is obvious that the region-deviation ratio depends on the scaling parameter δ.</text></s>
<s sid="347"><CoreSc1 advantage="None" conceptID="Res155" novelty="None" type="Res"/><text>A smaller δ gives a smaller region-deviation ratio, but a larger computational overhead.</text></s>
<s sid="348"><CoreSc1 advantage="None" conceptID="Goa6" novelty="None" type="Goa"/><text>In our simulation experiments, we use the running time of an algorithm as the metric for evaluating the efficiency performance.</text></s>
<s sid="349"><CoreSc1 advantage="None" conceptID="Goa7" novelty="None" type="Goa"/><text>In order to fairly test the computational overheads of the different algorithms, all the algorithms run in turn under the same machine configuration and the same operation system (Fedora 10).</text></s>
<s sid="350"><CoreSc1 advantage="None" conceptID="Met18" novelty="None" type="Met"/><text>Moreover, during the running of each algorithm, the machine did not perform any other task.</text></s>
<s sid="351"><CoreSc1 advantage="None" conceptID="Met19" novelty="None" type="Met"/><text>We use the function &quot;gettimeofday&quot; provided by the system to obtain the exact starting time and the end time, in order to calculate the running time delivered by different algorithms.</text></s>
<s sid="352"><CoreSc1 advantage="None" conceptID="Met20" novelty="None" type="Met"/><text>Similar to Xue et al. (2007), we used BRITE (Huang et al., 2010), a well-known Internet topology generator, to generate network topologies using the Waxman model.</text></s>
<s sid="353"><CoreSc1 advantage="None" conceptID="Met21" novelty="None" type="Met"/><text>We apply the default parameters provided in BRITE.</text></s>
<s sid="354"><CoreSc1 advantage="None" conceptID="Bac11" novelty="None" type="Bac"/><text>The details can be referred to Xue et al. (2007) and Huang et al. (2010).</text></s>
<s sid="355"><CoreSc1 advantage="None" conceptID="Res156" novelty="None" type="Res"/><text>The physical links in the networks are asymmetric, and the link metrics of both directions are independently generated.</text></s>
<s sid="356"><CoreSc1 advantage="None" conceptID="Res157" novelty="None" type="Res"/><text>Cost metrics are selected uniformly from [1,100], while the delay values are selected uniformly from [1,300].</text></s>
<s sid="357"><CoreSc1 advantage="None" conceptID="Res158" novelty="None" type="Res"/><text>We consider five different network sizes with 100, 200, 300, 400, and 500 nodes.</text></s>
<s sid="358"><CoreSc1 advantage="None" conceptID="Res159" novelty="None" type="Res"/><text>We generate ten different instances for each network size.</text></s>
<s sid="359"><CoreSc1 advantage="None" conceptID="Res160" novelty="None" type="Res"/><text>In each instance, we randomly select four nodes and compute the supported QoS regions from each selected node to all the other nodes in the network.</text></s>
<s sid="360"><CoreSc1 advantage="None" conceptID="Res161" novelty="None" type="Res"/><text>There are totally 99·4 different supported QoSes between two nodes in a network instance.</text></s>
<s sid="361"><CoreSc1 advantage="None" conceptID="Res162" novelty="None" type="Res"/><text>For each network size, the average region-deviation ratio is thus an average value of the region-deviation ratios among these 99·4·10 configurations.</text></s>
Significance of distortion area
<s sid="362"><CoreSc1 advantage="None" conceptID="Res163" novelty="None" type="Res"/><text>In Section 1, we mention that the distortion area reflects the admission control performance of the network.</text></s>
<s sid="363"><CoreSc1 advantage="None" conceptID="Con60" novelty="None" type="Con"/><text>In this section, we have conducted the simulation experiments to demonstrate the relationship between the admission control performance and the size of the distortion area.</text></s>
<s sid="364"><CoreSc1 advantage="None" conceptID="Con61" novelty="None" type="Con"/><text>After a source receives a connection request, it first determines whether there is a path satisfying the QoS requirement of a request.</text></s>
<s sid="365"><CoreSc1 advantage="None" conceptID="Con62" novelty="None" type="Con"/><text>The network will accept the request if it is feasible or reject it if the source cannot find a feasible path according to its precomputed supported QoS region.</text></s>
<s sid="366"><CoreSc1 advantage="None" conceptID="Res164" novelty="None" type="Res"/><text>We define the ratio of the number of the requests accepted to the total number of the incoming requests as the acceptance ratio.</text></s>
<s sid="367"><CoreSc1 advantage="None" conceptID="Res165" novelty="None" type="Res"/><text>Denote Sopt as the acceptance ratio corresponding to the optimal feasible area Aopt and S as the acceptance ratio for an approximation algorithm with the approximate feasible area A.</text></s>
<s sid="368"><CoreSc1 advantage="None" conceptID="Res166" novelty="None" type="Res"/><text>Similar to Korkmaz and Krunz (2001), we define S/Sopt as the relative acceptance ratio which implies how well an algorithm works for the provision of the QoS guarantees.</text></s>
<s sid="369"><CoreSc1 advantage="None" conceptID="Res167" novelty="None" type="Res"/><text>S/Sopt thus reflects the admission control performance of the network.</text></s>
<s sid="370"><CoreSc1 advantage="None" conceptID="Res168" novelty="None" type="Res"/><text>A larger S/Sopt implies a better network performance.</text></s>
<s sid="371"><CoreSc1 advantage="None" conceptID="Res169" novelty="None" type="Res"/><text>We generate the connection requests as follows.</text></s>
<s sid="372"><CoreSc1 advantage="None" conceptID="Res170" novelty="None" type="Res"/><text>Given a source and a destination, let p1 and p2 be the minimum cost and minimum delay paths, respectively.</text></s>
<s sid="373"><CoreSc1 advantage="None" conceptID="Obs39" novelty="None" type="Obs"/><text>Denote the QoS parameters of p1 and p2 as (cmin,dmax) and (cmax,dmax), respectively.</text></s>
<s sid="374"><CoreSc1 advantage="None" conceptID="Res171" novelty="None" type="Res"/><text>We generated 1000 requests from each node pair.</text></s>
<s sid="375"><CoreSc1 advantage="None" conceptID="Res172" novelty="None" type="Res"/><text>Each request has the cost requirement creq and the delay requirement dreq.</text></s>
<s sid="376"><CoreSc1 advantage="None" conceptID="Res173" novelty="None" type="Res"/><text>As similar to Korkmaz and Krunz (2001), we take creq~uniform[fl·cmin,fu·cmax] and dreq~uniform[fl·dmin,fu·dmax], where fl=1.</text></s>
<s sid="377"><CoreSc1 advantage="None" conceptID="Res174" novelty="None" type="Res"/><text>In our simulation experiments, the value of the scaling parameter for our proposed approach is twice of that for cost-scaling.</text></s>
<s sid="378"><CoreSc1 advantage="None" conceptID="Obs40" novelty="None" type="Obs"/><text>Figure 7(a) and (b) shows the relative acceptance ratio against the scaling parameter for cost-scaling when fu=1 and fu=0.9, respectively.</text></s>
<s sid="379"><CoreSc1 advantage="None" conceptID="Res175" novelty="None" type="Res"/><text>For example, when δ=0.05, the scaling parameter for two-dimensional scaling becomes 2δ=0.1.</text></s>
<s sid="380"><CoreSc1 advantage="None" conceptID="Res176" novelty="None" type="Res"/><text>The simulation results show that the relative acceptance ratio decreases as the scaling parameter increases.</text></s>
<s sid="381"><CoreSc1 advantage="None" conceptID="Res177" novelty="None" type="Res"/><text>Since the distortion area becomes larger as the scaling parameter increases, the distortion area varies with the relative acceptance ratio.</text></s>
<s sid="382"><CoreSc1 advantage="None" conceptID="Res178" novelty="None" type="Res"/><text>That is, the distortion area reflects the admission control performance of the network.</text></s>
<s sid="383"><CoreSc1 advantage="None" conceptID="Con63" novelty="None" type="Con"/><text>We also observe that the relative acceptance ratio for our approach is higher than that for cost-scaling.</text></s>
<s sid="384"><CoreSc1 advantage="None" conceptID="Con64" novelty="None" type="Con"/><text>In the following, we are going to show that the computational overheads of our approach and cost-scaling are almost the same.</text></s>
<s sid="385"><CoreSc1 advantage="None" conceptID="Con65" novelty="None" type="Con"/><text>Therefore, our approach can provide a better admission control service than cost-scaling without inducing additional overhead.</text></s>
<s sid="386"><CoreSc1 advantage="None" conceptID="Con66" novelty="None" type="Con"/><text>Comparing Fig. 7(a) and (b), we observe that the relative acceptance ratio with fu=0.9 is less than that with fu=1.</text></s>
<s sid="387"><CoreSc1 advantage="None" conceptID="Con67" novelty="None" type="Con"/><text>The larger fu implies that more requests fall in the feasible region, and so, the relative acceptance ratio with larger fu is greater.</text></s>
Two-dimensional scaling against cost-scaling
<s sid="388"><CoreSc1 advantage="None" conceptID="Con68" novelty="None" type="Con"/><text>The relative acceptance ratio does not only depend on the distortion area, but also it relates to the specific QoS requirements of the connection requests.</text></s>
<s sid="389"><CoreSc1 advantage="None" conceptID="Goa8" novelty="None" type="Goa"/><text>We would like to use the region-deviation ratio as the metric to evaluate the accuracy performance of an approximation algorithm.</text></s>
<s sid="390"><CoreSc1 advantage="None" conceptID="Res179" novelty="None" type="Res"/><text>Figure 8 shows the simulation results with uniform scaling.</text></s>
<s sid="391"><CoreSc1 advantage="None" conceptID="Res180" novelty="None" type="Res"/><text>Figure 8(a) exhibits the relationship between the region-deviation ratios and the scaling parameter δ.</text></s>
<s sid="392"><CoreSc1 advantage="None" conceptID="Res181" novelty="None" type="Res"/><text>We can see that the region-deviation ratio for cost-scaling is the higher than that for two-dimensional scaling.</text></s>
<s sid="393"><CoreSc1 advantage="None" conceptID="Res182" novelty="None" type="Res"/><text>For each running time, there is a corresponding region-deviation ratio produced by algorithm.</text></s>
<s sid="394"><CoreSc1 advantage="None" conceptID="Res183" novelty="None" type="Res"/><text>With the same running time, the lower the region-deviation ratio, the better the algorithm.</text></s>
<s sid="395"><CoreSc1 advantage="None" conceptID="Res184" novelty="None" type="Res"/><text>Figure 8(c) shows the region-deviation ratio of two-dimensional scaling is lower than that of cost-scaling, and so the proposed method outperforms cost-scaling.</text></s>
<s sid="396"><CoreSc1 advantage="None" conceptID="Obj26" novelty="None" type="Obj"/><text>We then test the performance of the algorithms applying logarithmic scaling.</text></s>
<s sid="397"><CoreSc1 advantage="None" conceptID="Res185" novelty="None" type="Res"/><text>Figure 9 shows the simulation results.</text></s>
<s sid="398"><CoreSc1 advantage="None" conceptID="Res186" novelty="None" type="Res"/><text>In Fig. 9(b), the scaling parameter for two-dimensional scaling is twice of that for cost-scaling.</text></s>
<s sid="399"><CoreSc1 advantage="None" conceptID="Res187" novelty="None" type="Res"/><text>The computational overheads for both algorithms are comparable.</text></s>
<s sid="400"><CoreSc1 advantage="None" conceptID="Res188" novelty="None" type="Res"/><text>This accords with our theoretical analysis in Section 5.3.</text></s>
<s sid="401"><CoreSc1 advantage="None" conceptID="Res189" novelty="None" type="Res"/><text>That is, when the scaling parameter is small enough, (1+2δ) is approximately the same as (1+δ)2.</text></s>
<s sid="402"><CoreSc1 advantage="None" conceptID="Res190" novelty="None" type="Res"/><text>Figure 9(c) shows the region-deviation ratio of the algorithms against the running time.</text></s>
<s sid="403"><CoreSc1 advantage="None" conceptID="Con69" novelty="None" type="Con"/><text>We observe that the performance improvement for two-dimensional scaling over cost-scaling becomes greater with a smaller scaling parameter, which leads to a larger running time.</text></s>
<s sid="404"><CoreSc1 advantage="None" conceptID="Goa9" novelty="None" type="Goa"/><text>Finally, we would like to evaluate the performance of the algorithms with different network sizes.</text></s>
<s sid="405"><CoreSc1 advantage="None" conceptID="Res191" novelty="None" type="Res"/><text>When applying uniform scaling, we set the scaling parameters as 0.1 and 0.2 for cost-scaling and two-dimensional scaling, respectively.</text></s>
<s sid="406"><CoreSc1 advantage="None" conceptID="Res192" novelty="None" type="Res"/><text>When applying logarithmic scaling, the scaling parameters for cost-scaling and two-dimensional scaling are 0.05 and 0.1, respectively.</text></s>
<s sid="407"><CoreSc1 advantage="None" conceptID="Res193" novelty="None" type="Res"/><text>The simulation results in Figs.</text></s>
<s sid="408"><CoreSc1 advantage="None" conceptID="Res194" novelty="None" type="Res"/><text>10(b) and 11(b) show that the computational overheads incurred by the algorithms are comparable.</text></s>
<s sid="409"><CoreSc1 advantage="None" conceptID="Res195" novelty="None" type="Res"/><text>Figures 10(a) and 11(a) show that the region-deviation ratio for two-dimensional scaling is less than half of that for cost-scaling.</text></s>
<s sid="410"><CoreSc1 advantage="None" conceptID="Con70" novelty="None" type="Con"/><text>These results show that our approach outperforms over cost-scaling in the general network topology.</text></s>
Conclusion
<s sid="411"><CoreSc1 advantage="None" conceptID="Con71" novelty="None" type="Con"/><text>In this paper, we investigated the problem of precomputing the supported QoS with two additive constraints, which is NP-complete.</text></s>
<s sid="412"><CoreSc1 advantage="None" conceptID="Con72" novelty="None" type="Con"/><text>We proposed a new metric, distortion area, to evaluate the performance of the approximation algorithms for estimating the supported QoS.</text></s>
<s sid="413"><CoreSc1 advantage="None" conceptID="Con73" novelty="None" type="Con"/><text>We gave the theoretical analysis for the upper bound of the distortion area produced by the existing quantization-based approximation algorithms, and then we presented a new method to further improve the accuracy performance, which is called two-dimensional scaling.</text></s>
<s sid="414"><CoreSc1 advantage="None" conceptID="Con74" novelty="None" type="Con"/><text>We also formally show that two-dimensional scaling produces the smaller approximation error than the existing methods.</text></s>
<s sid="415"><CoreSc1 advantage="None" conceptID="Con75" novelty="None" type="Con"/><text>Finally, we demonstrated the performance of our method and compared it with the existing methods by conducting the extensive simulation experiments.</text></s>
<s sid="416"><CoreSc1 advantage="None" conceptID="Con76" novelty="None" type="Con"/><text>Our method can be extended for the case of routing with multiple additive constraints.</text></s>
</BODY>
<OTHER>
Acknowledgments
This work was supported in part by the Cisco Research Initiative Award, the National Natural Science Foundation of China (Grant nos.
61101143 and 61231008), the University of Hong Kong Small Project Fundings, the Fundamental Research Funds for the Central Universities K50511010006, and the 111 Project under Grant B08038.

</OTHER>
</PAPER>