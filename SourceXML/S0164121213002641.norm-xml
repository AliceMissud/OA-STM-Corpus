<?xml version="1.0" encoding="UTF-8"?><!-- Normalized for easier text mining. --><xocs:doc xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.elsevier.com/xml/ja/dtd" xmlns:ja="http://www.elsevier.com/xml/ja/dtd" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:tb="http://www.elsevier.com/xml/common/table/dtd" xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/dtd" xmlns:ce="http://www.elsevier.com/xml/common/dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:cals="http://www.elsevier.com/xml/common/cals/dtd" xsi:schemaLocation="http://www.elsevier.com/xml/xocs/dtd http://schema.elsevier.com/dtds/document/fulltext/xcr/xocs-article.xsd"><xocs:meta><xocs:content-family>serial</xocs:content-family><xocs:content-type>JL</xocs:content-type><xocs:cid>271629</xocs:cid><xocs:srctitle>Journal of Systems and Software</xocs:srctitle><xocs:normalized-srctitle>JOURNALSYSTEMSSOFTWARE</xocs:normalized-srctitle><xocs:orig-load-date>2013-11-07</xocs:orig-load-date><xocs:ew-transaction-id>2014-02-21T20:43:24</xocs:ew-transaction-id><xocs:eid>1-s2.0-S0164121213002641</xocs:eid><xocs:pii-formatted>S0164-1212(13)00264-1</xocs:pii-formatted><xocs:pii-unformatted>S0164121213002641</xocs:pii-unformatted><xocs:doi>10.1016/j.jss.2013.10.056</xocs:doi><xocs:item-stage>S300</xocs:item-stage><xocs:item-version-number>S300.1</xocs:item-version-number><xocs:item-weight>FULL-TEXT</xocs:item-weight><xocs:hub-eid>1-s2.0-S0164121214X00038</xocs:hub-eid><xocs:timestamp>2014-02-21T23:21:27.240064-05:00</xocs:timestamp><xocs:issns><xocs:issn-primary-formatted>0164-1212</xocs:issn-primary-formatted><xocs:issn-primary-unformatted>01641212</xocs:issn-primary-unformatted></xocs:issns><xocs:sponsored-access-type>UNLIMITED</xocs:sponsored-access-type><xocs:funding-body-id>NONE</xocs:funding-body-id><xocs:crossmark>true</xocs:crossmark><xocs:vol-first>90</xocs:vol-first><xocs:suppl>C</xocs:suppl><xocs:vol-iss-suppl-text>Volume 90</xocs:vol-iss-suppl-text><xocs:sort-order>7</xocs:sort-order><xocs:first-fp>61</xocs:first-fp><xocs:last-lp>75</xocs:last-lp><xocs:pages><xocs:first-page>61</xocs:first-page><xocs:last-page>75</xocs:last-page></xocs:pages><xocs:cover-date-orig><xocs:start-date>201404</xocs:start-date></xocs:cover-date-orig><xocs:cover-date-text>April 2014</xocs:cover-date-text><xocs:cover-date-start>2014-04-01</xocs:cover-date-start><xocs:cover-date-end>2014-04-30</xocs:cover-date-end><xocs:cover-date-year>2014</xocs:cover-date-year><xocs:hub-sec><xocs:hub-sec-title>Special Issue: Emerging Topics on Software Debugging</xocs:hub-sec-title></xocs:hub-sec><xocs:document-type>article</xocs:document-type><xocs:document-subtype>fla</xocs:document-subtype><xocs:copyright-line>Copyright Â© 2013 The Authors. Published by Elsevier Inc. All rights reserved.</xocs:copyright-line><xocs:normalized-article-title>USINGSPINFORAUTOMATEDDEBUGGINGINFINITEEXECUTIONSJAVAPROGRAMS</xocs:normalized-article-title><xocs:normalized-first-auth-surname>ADALID</xocs:normalized-first-auth-surname><xocs:normalized-first-auth-initial>D</xocs:normalized-first-auth-initial><xocs:item-toc><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>1</xocs:item-toc-label><xocs:item-toc-section-title>Introduction</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>2</xocs:item-toc-label><xocs:item-toc-section-title>Model checking for debugging</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>2.1</xocs:item-toc-label><xocs:item-toc-section-title>Motivating example</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>2.2</xocs:item-toc-label><xocs:item-toc-section-title>LTL for Java traces</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>2.3</xocs:item-toc-label><xocs:item-toc-section-title>Checking LTL with SPIN</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>3</xocs:item-toc-label><xocs:item-toc-section-title>TJT approach for debugging Java executions</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>3.1</xocs:item-toc-label><xocs:item-toc-section-title>Implementation with Spin and JDI</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>3.1.1</xocs:item-toc-label><xocs:item-toc-section-title>The main loop</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>3.1.2</xocs:item-toc-label><xocs:item-toc-section-title>Getting new Java states and checking failures</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>3.1.3</xocs:item-toc-label><xocs:item-toc-section-title>Representing Java states inside Spin</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc-entry></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4</xocs:item-toc-label><xocs:item-toc-section-title>Abstraction of Java traces</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.1</xocs:item-toc-label><xocs:item-toc-section-title>Definitions</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.2</xocs:item-toc-label><xocs:item-toc-section-title>Dealing with cycles</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.2.1</xocs:item-toc-label><xocs:item-toc-section-title>State counting</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.2.2</xocs:item-toc-label><xocs:item-toc-section-title>State hashing</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.2.3</xocs:item-toc-label><xocs:item-toc-section-title>Preservation of results</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.3</xocs:item-toc-label><xocs:item-toc-section-title>Folding consecutive repeated states</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>4.3.1</xocs:item-toc-label><xocs:item-toc-section-title>Preservation of results</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc-entry></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>5</xocs:item-toc-label><xocs:item-toc-section-title>Experimental results</xocs:item-toc-section-title><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>5.1</xocs:item-toc-label><xocs:item-toc-section-title>Counter projection</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>5.2</xocs:item-toc-label><xocs:item-toc-section-title>Hash projection</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>6</xocs:item-toc-label><xocs:item-toc-section-title>Comparison with related work</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:sections"><xocs:item-toc-label>7</xocs:item-toc-label><xocs:item-toc-section-title>Conclusions and future work</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:acknowledgment"><xocs:item-toc-section-title>Acknowledgements</xocs:item-toc-section-title></xocs:item-toc-entry><xocs:item-toc-entry ref-elem="ce:bibliography"><xocs:item-toc-section-title>References</xocs:item-toc-section-title></xocs:item-toc-entry></xocs:item-toc><xocs:references><xocs:ref-info refid="sbref0005"><xocs:ref-normalized-surname>ADALID</xocs:ref-normalized-surname><xocs:ref-pub-year>2012</xocs:ref-pub-year><xocs:ref-normalized-initial>D</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>MSVVEIS2012</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>TESTINGTEMPORALLOGICINFINITEJAVATRACES</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="oref0010"/><xocs:ref-info refid="sbref0015"><xocs:ref-normalized-surname>ALIPOUR</xocs:ref-normalized-surname><xocs:ref-pub-year>2012</xocs:ref-pub-year><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>MODELCHECKINGDELTADEBUGGINGFORAUTOMATEDFAULTLOCALIZATIONATUTORIALTECHNICALREPORT</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="sbref0020"><xocs:ref-normalized-surname>ARTHO</xocs:ref-normalized-surname><xocs:ref-pub-year>2003</xocs:ref-pub-year><xocs:ref-first-fp>87</xocs:ref-first-fp><xocs:ref-last-lp>108</xocs:ref-last-lp><xocs:ref-normalized-initial>C</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>PROCEEDINGSABSTRACTSTATEMACHINES10THINTERNATIONALCONFERENCEADVANCESINTHEORYPRACTICE</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>EXPERIMENTSTESTCASEGENERATIONRUNTIMEANALYSIS</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0025"><xocs:ref-normalized-surname>BAIARDI</xocs:ref-normalized-surname><xocs:ref-pub-year>1986</xocs:ref-pub-year><xocs:ref-first-fp>547</xocs:ref-first-fp><xocs:ref-last-lp>553</xocs:ref-last-lp><xocs:ref-normalized-initial>F</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0030"><xocs:ref-normalized-surname>BAUER</xocs:ref-normalized-surname><xocs:ref-pub-year>2011</xocs:ref-pub-year><xocs:ref-normalized-initial>A</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0035"><xocs:ref-normalized-surname>BEUST</xocs:ref-normalized-surname><xocs:ref-pub-year>2007</xocs:ref-pub-year><xocs:ref-normalized-initial>C</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>JAVATESTINGTESTNGADVANCEDCONCEPTS</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="sbref0040"><xocs:ref-normalized-surname>BEYER</xocs:ref-normalized-surname><xocs:ref-pub-year>2007</xocs:ref-pub-year><xocs:ref-first-fp>505</xocs:ref-first-fp><xocs:ref-last-lp>525</xocs:ref-last-lp><xocs:ref-normalized-initial>D</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0045"><xocs:ref-normalized-surname>BODDEN</xocs:ref-normalized-surname><xocs:ref-pub-year>2004</xocs:ref-pub-year><xocs:ref-first-fp>306</xocs:ref-first-fp><xocs:ref-last-lp>307</xocs:ref-last-lp><xocs:ref-normalized-initial>E</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>COMPANION19THANNUALACMSIGPLANCONFERENCEOBJECTORIENTEDPROGRAMMINGSYSTEMSLANGUAGESAPPLICATIONS</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>ALIGHTWEIGHTLTLRUNTIMEVERIFICATIONTOOLFORJAVA</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0050"><xocs:ref-normalized-surname>CLARKE</xocs:ref-normalized-surname><xocs:ref-pub-year>1999</xocs:ref-pub-year><xocs:ref-normalized-initial>J</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>MODELCHECKING</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="sbref0055"><xocs:ref-normalized-surname>CLARKE</xocs:ref-normalized-surname><xocs:ref-pub-year>2009</xocs:ref-pub-year><xocs:ref-first-fp>74</xocs:ref-first-fp><xocs:ref-last-lp>84</xocs:ref-last-lp><xocs:ref-normalized-initial>E</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0060"><xocs:ref-normalized-surname>CORBETT</xocs:ref-normalized-surname><xocs:ref-pub-year>2000</xocs:ref-pub-year><xocs:ref-first-fp>439</xocs:ref-first-fp><xocs:ref-last-lp>448</xocs:ref-last-lp><xocs:ref-normalized-initial>J</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>PROCEEDINGS2000INTERNATIONALCONFERENCESOFTWAREENGINEERING2000</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>BANDERAEXTRACTINGFINITESTATEMODELSJAVASOURCECODE</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="oref0065"/><xocs:ref-info refid="sbref0070"><xocs:ref-normalized-surname>DAMORIM</xocs:ref-normalized-surname><xocs:ref-pub-year>2005</xocs:ref-pub-year><xocs:ref-first-fp>1</xocs:ref-first-fp><xocs:ref-last-lp>7</xocs:ref-last-lp><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0075"><xocs:ref-normalized-surname>DELACAMARA</xocs:ref-normalized-surname><xocs:ref-pub-year>2006</xocs:ref-pub-year><xocs:ref-first-fp>182</xocs:ref-first-fp><xocs:ref-last-lp>200</xocs:ref-last-lp><xocs:ref-normalized-initial>P</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>MODELCHECKINGSOFTWARE13THINTERNATIONALSPINWORKSHOPVIENNAAUSTRIAMARCH30APRIL12006PROCEEDINGSLECTURENOTESINCOMPUTERSCIENCE</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>ABSTRACTMATCHINGFORSOFTWAREMODELCHECKING</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0080"><xocs:ref-normalized-surname>DELACAMARA</xocs:ref-normalized-surname><xocs:ref-pub-year>2010</xocs:ref-pub-year><xocs:ref-first-fp>267</xocs:ref-first-fp><xocs:ref-last-lp>298</xocs:ref-last-lp><xocs:ref-normalized-initial>P</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0085"><xocs:ref-normalized-surname>DRUSINSKY</xocs:ref-normalized-surname><xocs:ref-pub-year>2000</xocs:ref-pub-year><xocs:ref-first-fp>323</xocs:ref-first-fp><xocs:ref-last-lp>330</xocs:ref-last-lp><xocs:ref-normalized-initial>D</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>PROCEEDINGS7THINTERNATIONALSPINWORKSHOPSPINMODELCHECKINGSOFTWAREVERIFICATION</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>TEMPORALROVERATGROVER</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="oref0090"/><xocs:ref-info refid="sbref0095"><xocs:ref-normalized-surname>FU</xocs:ref-normalized-surname><xocs:ref-pub-year>2005</xocs:ref-pub-year><xocs:ref-first-fp>292</xocs:ref-first-fp><xocs:ref-last-lp>311</xocs:ref-last-lp><xocs:ref-normalized-initial>C</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0100"><xocs:ref-normalized-surname>GALLARDO</xocs:ref-normalized-surname><xocs:ref-pub-year>2004</xocs:ref-pub-year><xocs:ref-first-fp>165</xocs:ref-first-fp><xocs:ref-last-lp>184</xocs:ref-last-lp><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0105"><xocs:ref-normalized-surname>GALLARDO</xocs:ref-normalized-surname><xocs:ref-pub-year>2009</xocs:ref-pub-year><xocs:ref-first-fp>229</xocs:ref-first-fp><xocs:ref-last-lp>264</xocs:ref-last-lp><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0110"><xocs:ref-normalized-surname>GIANNAKOPOULOU</xocs:ref-normalized-surname><xocs:ref-pub-year>2001</xocs:ref-pub-year><xocs:ref-first-fp>412</xocs:ref-first-fp><xocs:ref-last-lp>416</xocs:ref-last-lp><xocs:ref-normalized-initial>D</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>PROCEEDINGS16THIEEEINTERNATIONALCONFERENCEAUTOMATEDSOFTWAREENGINEERING</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>AUTOMATABASEDVERIFICATIONTEMPORALPROPERTIESRUNNINGPROGRAMS</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0115"><xocs:ref-normalized-surname>GODEFROID</xocs:ref-normalized-surname><xocs:ref-pub-year>1997</xocs:ref-pub-year><xocs:ref-first-fp>174</xocs:ref-first-fp><xocs:ref-last-lp>186</xocs:ref-last-lp><xocs:ref-normalized-initial>P</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>PROCEEDINGS24THACMSIGPLANSIGACTSYMPOSIUMPRINCIPLESPROGRAMMINGLANGUAGES</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>MODELCHECKINGFORPROGRAMMINGLANGUAGESUSINGVERISOFT</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0120"><xocs:ref-normalized-surname>HAVELUND</xocs:ref-normalized-surname><xocs:ref-pub-year>2000</xocs:ref-pub-year><xocs:ref-first-fp>366</xocs:ref-first-fp><xocs:ref-last-lp>381</xocs:ref-last-lp><xocs:ref-normalized-initial>K</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0125"><xocs:ref-normalized-surname>HAVELUND</xocs:ref-normalized-surname><xocs:ref-pub-year>2004</xocs:ref-pub-year><xocs:ref-first-fp>189</xocs:ref-first-fp><xocs:ref-last-lp>215</xocs:ref-last-lp><xocs:ref-normalized-initial>K</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0130"><xocs:ref-normalized-surname>HOLZMANN</xocs:ref-normalized-surname><xocs:ref-pub-year>2007</xocs:ref-pub-year><xocs:ref-first-fp>659</xocs:ref-first-fp><xocs:ref-last-lp>674</xocs:ref-last-lp><xocs:ref-normalized-initial>G</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0135"><xocs:ref-normalized-surname>HOLZMANN</xocs:ref-normalized-surname><xocs:ref-pub-year>1995</xocs:ref-pub-year><xocs:ref-first-fp>301</xocs:ref-first-fp><xocs:ref-last-lp>314</xocs:ref-last-lp><xocs:ref-normalized-initial>G</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>ANALYSISBITSTATEHASHINGINFORMALMETHODSINSYSTEMDESIGN</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="sbref0140"><xocs:ref-normalized-surname>HOLZMANN</xocs:ref-normalized-surname><xocs:ref-pub-year>2003</xocs:ref-pub-year><xocs:ref-normalized-initial>G</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>SPINMODELCHECKERPRIMERREFERENCEMANUAL</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="oref0145"/><xocs:ref-info refid="oref0150"/><xocs:ref-info refid="sbref0155"><xocs:ref-normalized-surname>KRAFT</xocs:ref-normalized-surname><xocs:ref-pub-year>2010</xocs:ref-pub-year><xocs:ref-first-fp>315</xocs:ref-first-fp><xocs:ref-last-lp>329</xocs:ref-last-lp><xocs:ref-normalized-initial>J</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>INRV</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>TRACERECORDINGFOREMBEDDEDSYSTEMSLESSONSLEARNEDFIVEINDUSTRIALPROJECTS</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0160"><xocs:ref-normalized-surname>MANNA</xocs:ref-normalized-surname><xocs:ref-pub-year>1992</xocs:ref-pub-year><xocs:ref-normalized-initial>Z</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>TEMPORALLOGICREACTIVECONCURRENTSYSTEMS</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="sbref0165"><xocs:ref-normalized-surname>PELED</xocs:ref-normalized-surname><xocs:ref-pub-year>2003</xocs:ref-pub-year><xocs:ref-first-fp>47</xocs:ref-first-fp><xocs:ref-last-lp>63</xocs:ref-last-lp><xocs:ref-normalized-initial>D</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>INICALP</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>MODELCHECKINGTESTINGCOMBINED</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0170"><xocs:ref-normalized-surname>RUNESON</xocs:ref-normalized-surname><xocs:ref-pub-year>2006</xocs:ref-pub-year><xocs:ref-first-fp>22</xocs:ref-first-fp><xocs:ref-last-lp>29</xocs:ref-last-lp><xocs:ref-normalized-initial>P</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="oref0175"/><xocs:ref-info refid="sbref0180"><xocs:ref-normalized-surname>SCHNEIER</xocs:ref-normalized-surname><xocs:ref-pub-year>1995</xocs:ref-pub-year><xocs:ref-normalized-initial>B</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>APPLIEDCRYPTOGRAPHY2NDEDPROTOCOLSALGORITHMSSOURCECODEINC</xocs:ref-normalized-srctitle></xocs:ref-info><xocs:ref-info refid="oref0185"/><xocs:ref-info refid="sbref0190"><xocs:ref-normalized-surname>STOLLER</xocs:ref-normalized-surname><xocs:ref-pub-year>2002</xocs:ref-pub-year><xocs:ref-first-fp>71</xocs:ref-first-fp><xocs:ref-last-lp>91</xocs:ref-last-lp><xocs:ref-normalized-initial>S</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0195"><xocs:ref-normalized-surname>VARDI</xocs:ref-normalized-surname><xocs:ref-pub-year>1986</xocs:ref-pub-year><xocs:ref-first-fp>183</xocs:ref-first-fp><xocs:ref-last-lp>221</xocs:ref-last-lp><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0200"><xocs:ref-normalized-surname>VISSER</xocs:ref-normalized-surname><xocs:ref-pub-year>2003</xocs:ref-pub-year><xocs:ref-first-fp>203</xocs:ref-first-fp><xocs:ref-last-lp>232</xocs:ref-last-lp><xocs:ref-normalized-initial>W</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0205"><xocs:ref-normalized-surname>WOLPER</xocs:ref-normalized-surname><xocs:ref-pub-year>1993</xocs:ref-pub-year><xocs:ref-first-fp>59</xocs:ref-first-fp><xocs:ref-last-lp>70</xocs:ref-last-lp><xocs:ref-normalized-initial>P</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>5THINTERNATIONALCONFERENCECOMPUTERAIDEDVERIFICATION</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>RELIABLEHASHINGWITHOUTCOLLISIONDETECTION</xocs:ref-normalized-article-title></xocs:ref-info><xocs:ref-info refid="sbref0210"><xocs:ref-normalized-surname>ZHANG</xocs:ref-normalized-surname><xocs:ref-pub-year>2009</xocs:ref-pub-year><xocs:ref-first-fp>40</xocs:ref-first-fp><xocs:ref-last-lp>46</xocs:ref-last-lp><xocs:ref-normalized-initial>F</xocs:ref-normalized-initial><xocs:ref-normalized-srctitle>THIRDIEEEINTERNATIONALCONFERENCESECURESOFTWAREINTEGRATIONRELIABILITYIMPROVEMENT2009SSIRI2009</xocs:ref-normalized-srctitle><xocs:ref-normalized-article-title>FILMARUNTIMEMONITORINGTOOLFORDISTRIBUTEDSYSTEMS</xocs:ref-normalized-article-title></xocs:ref-info></xocs:references><xocs:attachment-metadata-doc><xocs:attachment-set-type>item</xocs:attachment-set-type><xocs:pii-formatted>S0164-1212(13)00264-1</xocs:pii-formatted><xocs:pii-unformatted>S0164121213002641</xocs:pii-unformatted><xocs:eid>1-s2.0-S0164121213002641</xocs:eid><xocs:doi>10.1016/j.jss.2013.10.056</xocs:doi><xocs:cid>271629</xocs:cid><xocs:timestamp>2014-02-21T23:21:27.240064-05:00</xocs:timestamp><xocs:path>/271629/1-s2.0-S0164121214X00038/1-s2.0-S0164121213002641/</xocs:path><xocs:cover-date-start>2014-04-01</xocs:cover-date-start><xocs:cover-date-end>2014-04-30</xocs:cover-date-end><xocs:sponsored-access-type>UNLIMITED</xocs:sponsored-access-type><xocs:funding-body-id>NONE</xocs:funding-body-id><xocs:attachments><xocs:web-pdf><xocs:attachment-eid>1-s2.0-S0164121213002641-main.pdf</xocs:attachment-eid><xocs:filename>main.pdf</xocs:filename><xocs:extension>pdf</xocs:extension><xocs:pdf-optimized>true</xocs:pdf-optimized><xocs:filesize>1861271</xocs:filesize><xocs:web-pdf-purpose>MAIN</xocs:web-pdf-purpose><xocs:web-pdf-page-count>15</xocs:web-pdf-page-count><xocs:web-pdf-images><xocs:web-pdf-image><xocs:attachment-eid>1-s2.0-S0164121213002641-main_1.png</xocs:attachment-eid><xocs:filename>main_1.png</xocs:filename><xocs:extension>png</xocs:extension><xocs:filesize>136165</xocs:filesize><xocs:pixel-height>849</xocs:pixel-height><xocs:pixel-width>656</xocs:pixel-width><xocs:attachment-type>IMAGE-WEB-PDF</xocs:attachment-type><xocs:pdf-page-num>1</xocs:pdf-page-num></xocs:web-pdf-image></xocs:web-pdf-images></xocs:web-pdf><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si9.gif</xocs:attachment-eid><xocs:file-basename>si9</xocs:file-basename><xocs:filename>si9.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>254</xocs:filesize><xocs:pixel-height>24</xocs:pixel-height><xocs:pixel-width>41</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si8.gif</xocs:attachment-eid><xocs:file-basename>si8</xocs:file-basename><xocs:filename>si8.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>254</xocs:filesize><xocs:pixel-height>24</xocs:pixel-height><xocs:pixel-width>41</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si7.gif</xocs:attachment-eid><xocs:file-basename>si7</xocs:file-basename><xocs:filename>si7.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>673</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>231</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si60.gif</xocs:attachment-eid><xocs:file-basename>si60</xocs:file-basename><xocs:filename>si60.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>551</xocs:filesize><xocs:pixel-height>20</xocs:pixel-height><xocs:pixel-width>147</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si6.gif</xocs:attachment-eid><xocs:file-basename>si6</xocs:file-basename><xocs:filename>si6.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>342</xocs:filesize><xocs:pixel-height>12</xocs:pixel-height><xocs:pixel-width>111</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si59.gif</xocs:attachment-eid><xocs:file-basename>si59</xocs:file-basename><xocs:filename>si59.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>534</xocs:filesize><xocs:pixel-height>20</xocs:pixel-height><xocs:pixel-width>146</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si58.gif</xocs:attachment-eid><xocs:file-basename>si58</xocs:file-basename><xocs:filename>si58.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>504</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>141</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si57.gif</xocs:attachment-eid><xocs:file-basename>si57</xocs:file-basename><xocs:filename>si57.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>153</xocs:filesize><xocs:pixel-height>13</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si56.gif</xocs:attachment-eid><xocs:file-basename>si56</xocs:file-basename><xocs:filename>si56.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>152</xocs:filesize><xocs:pixel-height>13</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si55.gif</xocs:attachment-eid><xocs:file-basename>si55</xocs:file-basename><xocs:filename>si55.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>387</xocs:filesize><xocs:pixel-height>17</xocs:pixel-height><xocs:pixel-width>79</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si54.gif</xocs:attachment-eid><xocs:file-basename>si54</xocs:file-basename><xocs:filename>si54.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>1061</xocs:filesize><xocs:pixel-height>20</xocs:pixel-height><xocs:pixel-width>295</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si53.gif</xocs:attachment-eid><xocs:file-basename>si53</xocs:file-basename><xocs:filename>si53.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>194</xocs:filesize><xocs:pixel-height>11</xocs:pixel-height><xocs:pixel-width>37</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si52.gif</xocs:attachment-eid><xocs:file-basename>si52</xocs:file-basename><xocs:filename>si52.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>394</xocs:filesize><xocs:pixel-height>17</xocs:pixel-height><xocs:pixel-width>83</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si51.gif</xocs:attachment-eid><xocs:file-basename>si51</xocs:file-basename><xocs:filename>si51.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>1087</xocs:filesize><xocs:pixel-height>19</xocs:pixel-height><xocs:pixel-width>290</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si50.gif</xocs:attachment-eid><xocs:file-basename>si50</xocs:file-basename><xocs:filename>si50.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>982</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>290</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si5.gif</xocs:attachment-eid><xocs:file-basename>si5</xocs:file-basename><xocs:filename>si5.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>124</xocs:filesize><xocs:pixel-height>10</xocs:pixel-height><xocs:pixel-width>11</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si49.gif</xocs:attachment-eid><xocs:file-basename>si49</xocs:file-basename><xocs:filename>si49.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>265</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>36</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si48.gif</xocs:attachment-eid><xocs:file-basename>si48</xocs:file-basename><xocs:filename>si48.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>238</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>36</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si47.gif</xocs:attachment-eid><xocs:file-basename>si47</xocs:file-basename><xocs:filename>si47.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>705</xocs:filesize><xocs:pixel-height>14</xocs:pixel-height><xocs:pixel-width>226</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si46.gif</xocs:attachment-eid><xocs:file-basename>si46</xocs:file-basename><xocs:filename>si46.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>504</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>112</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si45.gif</xocs:attachment-eid><xocs:file-basename>si45</xocs:file-basename><xocs:filename>si45.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>478</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>111</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si44.gif</xocs:attachment-eid><xocs:file-basename>si44</xocs:file-basename><xocs:filename>si44.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>238</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>36</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si43.gif</xocs:attachment-eid><xocs:file-basename>si43</xocs:file-basename><xocs:filename>si43.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>177</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si42.gif</xocs:attachment-eid><xocs:file-basename>si42</xocs:file-basename><xocs:filename>si42.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>494</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>112</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si41.gif</xocs:attachment-eid><xocs:file-basename>si41</xocs:file-basename><xocs:filename>si41.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>307</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>46</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si40.gif</xocs:attachment-eid><xocs:file-basename>si40</xocs:file-basename><xocs:filename>si40.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>301</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>46</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si4.gif</xocs:attachment-eid><xocs:file-basename>si4</xocs:file-basename><xocs:filename>si4.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>133</xocs:filesize><xocs:pixel-height>12</xocs:pixel-height><xocs:pixel-width>13</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si39.gif</xocs:attachment-eid><xocs:file-basename>si39</xocs:file-basename><xocs:filename>si39.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>278</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>40</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si38.gif</xocs:attachment-eid><xocs:file-basename>si38</xocs:file-basename><xocs:filename>si38.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>760</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>186</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si37.gif</xocs:attachment-eid><xocs:file-basename>si37</xocs:file-basename><xocs:filename>si37.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>185</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si36.gif</xocs:attachment-eid><xocs:file-basename>si36</xocs:file-basename><xocs:filename>si36.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>278</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>40</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si35.gif</xocs:attachment-eid><xocs:file-basename>si35</xocs:file-basename><xocs:filename>si35.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>626</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>132</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si34.gif</xocs:attachment-eid><xocs:file-basename>si34</xocs:file-basename><xocs:filename>si34.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>194</xocs:filesize><xocs:pixel-height>11</xocs:pixel-height><xocs:pixel-width>37</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si33.gif</xocs:attachment-eid><xocs:file-basename>si33</xocs:file-basename><xocs:filename>si33.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>610</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>135</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si32.gif</xocs:attachment-eid><xocs:file-basename>si32</xocs:file-basename><xocs:filename>si32.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>720</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>184</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si31.gif</xocs:attachment-eid><xocs:file-basename>si31</xocs:file-basename><xocs:filename>si31.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>278</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>40</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si30.gif</xocs:attachment-eid><xocs:file-basename>si30</xocs:file-basename><xocs:filename>si30.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>176</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si3.gif</xocs:attachment-eid><xocs:file-basename>si3</xocs:file-basename><xocs:filename>si3.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>1050</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>303</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si29.gif</xocs:attachment-eid><xocs:file-basename>si29</xocs:file-basename><xocs:filename>si29.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>177</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si28.gif</xocs:attachment-eid><xocs:file-basename>si28</xocs:file-basename><xocs:filename>si28.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>691</xocs:filesize><xocs:pixel-height>17</xocs:pixel-height><xocs:pixel-width>186</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si27.gif</xocs:attachment-eid><xocs:file-basename>si27</xocs:file-basename><xocs:filename>si27.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>177</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>18</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si26.gif</xocs:attachment-eid><xocs:file-basename>si26</xocs:file-basename><xocs:filename>si26.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>276</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>40</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si25.gif</xocs:attachment-eid><xocs:file-basename>si25</xocs:file-basename><xocs:filename>si25.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>276</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>40</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si24.gif</xocs:attachment-eid><xocs:file-basename>si24</xocs:file-basename><xocs:filename>si24.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>532</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>115</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si23.gif</xocs:attachment-eid><xocs:file-basename>si23</xocs:file-basename><xocs:filename>si23.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>194</xocs:filesize><xocs:pixel-height>11</xocs:pixel-height><xocs:pixel-width>37</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si22.gif</xocs:attachment-eid><xocs:file-basename>si22</xocs:file-basename><xocs:filename>si22.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>600</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>135</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si21.gif</xocs:attachment-eid><xocs:file-basename>si21</xocs:file-basename><xocs:filename>si21.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>716</xocs:filesize><xocs:pixel-height>18</xocs:pixel-height><xocs:pixel-width>193</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si20.gif</xocs:attachment-eid><xocs:file-basename>si20</xocs:file-basename><xocs:filename>si20.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>331</xocs:filesize><xocs:pixel-height>12</xocs:pixel-height><xocs:pixel-width>98</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si2.gif</xocs:attachment-eid><xocs:file-basename>si2</xocs:file-basename><xocs:filename>si2.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>1990</xocs:filesize><xocs:pixel-height>43</xocs:pixel-height><xocs:pixel-width>316</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si19.gif</xocs:attachment-eid><xocs:file-basename>si19</xocs:file-basename><xocs:filename>si19.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>507</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>142</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si18.gif</xocs:attachment-eid><xocs:file-basename>si18</xocs:file-basename><xocs:filename>si18.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>518</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>141</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si17.gif</xocs:attachment-eid><xocs:file-basename>si17</xocs:file-basename><xocs:filename>si17.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>515</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>143</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si16.gif</xocs:attachment-eid><xocs:file-basename>si16</xocs:file-basename><xocs:filename>si16.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>452</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>115</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si15.gif</xocs:attachment-eid><xocs:file-basename>si15</xocs:file-basename><xocs:filename>si15.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>861</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>281</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si14.gif</xocs:attachment-eid><xocs:file-basename>si14</xocs:file-basename><xocs:filename>si14.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>605</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>155</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si13.gif</xocs:attachment-eid><xocs:file-basename>si13</xocs:file-basename><xocs:filename>si13.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>459</xocs:filesize><xocs:pixel-height>15</xocs:pixel-height><xocs:pixel-width>127</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si12.gif</xocs:attachment-eid><xocs:file-basename>si12</xocs:file-basename><xocs:filename>si12.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>207</xocs:filesize><xocs:pixel-height>12</xocs:pixel-height><xocs:pixel-width>39</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si11.gif</xocs:attachment-eid><xocs:file-basename>si11</xocs:file-basename><xocs:filename>si11.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>301</xocs:filesize><xocs:pixel-height>24</xocs:pixel-height><xocs:pixel-width>67</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si10.gif</xocs:attachment-eid><xocs:file-basename>si10</xocs:file-basename><xocs:filename>si10.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>301</xocs:filesize><xocs:pixel-height>24</xocs:pixel-height><xocs:pixel-width>67</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-si1.gif</xocs:attachment-eid><xocs:file-basename>si1</xocs:file-basename><xocs:filename>si1.gif</xocs:filename><xocs:extension>gif</xocs:extension><xocs:filesize>1216</xocs:filesize><xocs:pixel-height>16</xocs:pixel-height><xocs:pixel-width>348</xocs:pixel-width><xocs:attachment-type>ALTIMG</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr9.jpg</xocs:attachment-eid><xocs:file-basename>gr9</xocs:file-basename><xocs:filename>gr9.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>42853</xocs:filesize><xocs:pixel-height>475</xocs:pixel-height><xocs:pixel-width>454</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr8.jpg</xocs:attachment-eid><xocs:file-basename>gr8</xocs:file-basename><xocs:filename>gr8.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>23915</xocs:filesize><xocs:pixel-height>286</xocs:pixel-height><xocs:pixel-width>567</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr7.jpg</xocs:attachment-eid><xocs:file-basename>gr7</xocs:file-basename><xocs:filename>gr7.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>62313</xocs:filesize><xocs:pixel-height>330</xocs:pixel-height><xocs:pixel-width>602</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr6.jpg</xocs:attachment-eid><xocs:file-basename>gr6</xocs:file-basename><xocs:filename>gr6.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>39913</xocs:filesize><xocs:pixel-height>240</xocs:pixel-height><xocs:pixel-width>538</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr5.jpg</xocs:attachment-eid><xocs:file-basename>gr5</xocs:file-basename><xocs:filename>gr5.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>21867</xocs:filesize><xocs:pixel-height>201</xocs:pixel-height><xocs:pixel-width>489</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr4.jpg</xocs:attachment-eid><xocs:file-basename>gr4</xocs:file-basename><xocs:filename>gr4.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>34654</xocs:filesize><xocs:pixel-height>357</xocs:pixel-height><xocs:pixel-width>393</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr3.jpg</xocs:attachment-eid><xocs:file-basename>gr3</xocs:file-basename><xocs:filename>gr3.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>48745</xocs:filesize><xocs:pixel-height>213</xocs:pixel-height><xocs:pixel-width>489</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr2.jpg</xocs:attachment-eid><xocs:file-basename>gr2</xocs:file-basename><xocs:filename>gr2.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>19613</xocs:filesize><xocs:pixel-height>151</xocs:pixel-height><xocs:pixel-width>479</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr15.jpg</xocs:attachment-eid><xocs:file-basename>gr15</xocs:file-basename><xocs:filename>gr15.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>16974</xocs:filesize><xocs:pixel-height>150</xocs:pixel-height><xocs:pixel-width>418</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr14.jpg</xocs:attachment-eid><xocs:file-basename>gr14</xocs:file-basename><xocs:filename>gr14.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>17430</xocs:filesize><xocs:pixel-height>163</xocs:pixel-height><xocs:pixel-width>474</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr13.jpg</xocs:attachment-eid><xocs:file-basename>gr13</xocs:file-basename><xocs:filename>gr13.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>19521</xocs:filesize><xocs:pixel-height>123</xocs:pixel-height><xocs:pixel-width>508</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr12.jpg</xocs:attachment-eid><xocs:file-basename>gr12</xocs:file-basename><xocs:filename>gr12.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>15771</xocs:filesize><xocs:pixel-height>108</xocs:pixel-height><xocs:pixel-width>489</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr11.jpg</xocs:attachment-eid><xocs:file-basename>gr11</xocs:file-basename><xocs:filename>gr11.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>10321</xocs:filesize><xocs:pixel-height>65</xocs:pixel-height><xocs:pixel-width>489</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr10.jpg</xocs:attachment-eid><xocs:file-basename>gr10</xocs:file-basename><xocs:filename>gr10.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>8581</xocs:filesize><xocs:pixel-height>65</xocs:pixel-height><xocs:pixel-width>489</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr1.jpg</xocs:attachment-eid><xocs:file-basename>gr1</xocs:file-basename><xocs:filename>gr1.jpg</xocs:filename><xocs:extension>jpg</xocs:extension><xocs:filesize>24453</xocs:filesize><xocs:pixel-height>251</xocs:pixel-height><xocs:pixel-width>494</xocs:pixel-width><xocs:attachment-type>IMAGE-DOWNSAMPLED</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr9.sml</xocs:attachment-eid><xocs:file-basename>gr9</xocs:file-basename><xocs:filename>gr9.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>3510</xocs:filesize><xocs:pixel-height>164</xocs:pixel-height><xocs:pixel-width>157</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr8.sml</xocs:attachment-eid><xocs:file-basename>gr8</xocs:file-basename><xocs:filename>gr8.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2720</xocs:filesize><xocs:pixel-height>111</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr7.sml</xocs:attachment-eid><xocs:file-basename>gr7</xocs:file-basename><xocs:filename>gr7.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>7098</xocs:filesize><xocs:pixel-height>120</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr6.sml</xocs:attachment-eid><xocs:file-basename>gr6</xocs:file-basename><xocs:filename>gr6.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>10383</xocs:filesize><xocs:pixel-height>98</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr5.sml</xocs:attachment-eid><xocs:file-basename>gr5</xocs:file-basename><xocs:filename>gr5.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>5379</xocs:filesize><xocs:pixel-height>90</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr4.sml</xocs:attachment-eid><xocs:file-basename>gr4</xocs:file-basename><xocs:filename>gr4.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>5588</xocs:filesize><xocs:pixel-height>163</xocs:pixel-height><xocs:pixel-width>180</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr3.sml</xocs:attachment-eid><xocs:file-basename>gr3</xocs:file-basename><xocs:filename>gr3.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>7150</xocs:filesize><xocs:pixel-height>96</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr2.sml</xocs:attachment-eid><xocs:file-basename>gr2</xocs:file-basename><xocs:filename>gr2.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2875</xocs:filesize><xocs:pixel-height>69</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr15.sml</xocs:attachment-eid><xocs:file-basename>gr15</xocs:file-basename><xocs:filename>gr15.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2943</xocs:filesize><xocs:pixel-height>78</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr14.sml</xocs:attachment-eid><xocs:file-basename>gr14</xocs:file-basename><xocs:filename>gr14.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2851</xocs:filesize><xocs:pixel-height>75</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr13.sml</xocs:attachment-eid><xocs:file-basename>gr13</xocs:file-basename><xocs:filename>gr13.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>3326</xocs:filesize><xocs:pixel-height>53</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr12.sml</xocs:attachment-eid><xocs:file-basename>gr12</xocs:file-basename><xocs:filename>gr12.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>3456</xocs:filesize><xocs:pixel-height>48</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr11.sml</xocs:attachment-eid><xocs:file-basename>gr11</xocs:file-basename><xocs:filename>gr11.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2637</xocs:filesize><xocs:pixel-height>29</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr10.sml</xocs:attachment-eid><xocs:file-basename>gr10</xocs:file-basename><xocs:filename>gr10.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>2354</xocs:filesize><xocs:pixel-height>29</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment><xocs:attachment><xocs:attachment-eid>1-s2.0-S0164121213002641-gr1.sml</xocs:attachment-eid><xocs:file-basename>gr1</xocs:file-basename><xocs:filename>gr1.sml</xocs:filename><xocs:extension>sml</xocs:extension><xocs:filesize>3363</xocs:filesize><xocs:pixel-height>111</xocs:pixel-height><xocs:pixel-width>219</xocs:pixel-width><xocs:attachment-type>IMAGE-THUMBNAIL</xocs:attachment-type></xocs:attachment></xocs:attachments></xocs:attachment-metadata-doc><xocs:refkeys><xocs:refkey3>ADALIDX2014X61</xocs:refkey3><xocs:refkey4lp>ADALIDX2014X61X75</xocs:refkey4lp><xocs:refkey4ai>ADALIDX2014X61XD</xocs:refkey4ai><xocs:refkey5>ADALIDX2014X61X75XD</xocs:refkey5></xocs:refkeys><xocs:open-access><xocs:oa-article-status is-open-access="1" is-open-archive="0">Full</xocs:oa-article-status><xocs:oa-access-effective-date>2013-11-05T09:29:51Z</xocs:oa-access-effective-date><xocs:oa-sponsor><xocs:oa-sponsor-type>Author</xocs:oa-sponsor-type></xocs:oa-sponsor><xocs:oa-user-license>http://creativecommons.org/licenses/by/3.0/</xocs:oa-user-license></xocs:open-access></xocs:meta><xocs:serial-item><article xmlns:sa="http://www.elsevier.com/xml/common/struct-aff/dtd" version="5.2" xml:lang="en" docsubtype="fla"><item-info><jid>JSS</jid><aid>9246</aid><ce:pii>S0164-1212(13)00264-1</ce:pii><ce:doi>10.1016/j.jss.2013.10.056</ce:doi><ce:copyright type="other" year="2013">The Authors</ce:copyright></item-info><ce:floats><ce:figure id="fig0005"><ce:label>Fig. 1</ce:label><ce:caption id="cap0005"><ce:simple-para id="spar0015" view="all">FTP server: the main loop.</ce:simple-para></ce:caption><ce:link locator="gr1"/></ce:figure><ce:figure id="fig0010"><ce:label>Fig. 2</ce:label><ce:caption id="cap0010"><ce:simple-para id="spar0020" view="all">FTP server: part of <ce:monospace>CWD</ce:monospace> command.</ce:simple-para></ce:caption><ce:link locator="gr2"/></ce:figure><ce:figure id="fig0015"><ce:label>Fig. 3</ce:label><ce:caption id="cap0015"><ce:simple-para id="spar0025" view="all">Example trace of property violation.</ce:simple-para></ce:caption><ce:link locator="gr3"/></ce:figure><ce:figure id="fig0020"><ce:label>Fig. 4</ce:label><ce:caption id="cap0020"><ce:simple-para id="spar0030" view="all">Simplified BÃ¼chi automaton.</ce:simple-para></ce:caption><ce:link locator="gr4"/></ce:figure><ce:figure id="fig0025"><ce:label>Fig. 5</ce:label><ce:caption id="cap0025"><ce:simple-para id="spar0035" view="all">Spin data structures.</ce:simple-para></ce:caption><ce:link locator="gr5"/></ce:figure><ce:figure id="fig0030"><ce:label>Fig. 6</ce:label><ce:caption id="cap0030"><ce:simple-para id="spar0040" view="all">TJT architecture and workflow.</ce:simple-para></ce:caption><ce:link locator="gr6"/></ce:figure><ce:figure id="fig0035"><ce:label>Fig. 7</ce:label><ce:caption id="cap0035"><ce:simple-para id="spar0045" view="all">TJT Eclipse plug-in showing the test specification file editor.</ce:simple-para></ce:caption><ce:link locator="gr7"/></ce:figure><ce:figure id="fig0040"><ce:label>Fig. 8</ce:label><ce:caption id="cap0040"><ce:simple-para id="spar0050" view="all">Extract of Promela code to control automated debugging.</ce:simple-para></ce:caption><ce:link locator="gr8"/></ce:figure><ce:figure id="fig0045"><ce:label>Fig. 9</ce:label><ce:caption id="cap0045"><ce:simple-para id="spar0055" view="all">Extract of C code of <ce:monospace>getNextState()</ce:monospace>.</ce:simple-para></ce:caption><ce:link locator="gr9"/></ce:figure><ce:figure id="fig0050"><ce:label>Fig. 10</ce:label><ce:caption id="cap0050"><ce:simple-para id="spar0060" view="all">Trace projection</ce:simple-para></ce:caption><ce:link locator="gr10"/></ce:figure><ce:figure id="fig0055"><ce:label>Fig. 11</ce:label><ce:caption id="cap0055"><ce:simple-para id="spar0065" view="all">Trace projection with state counting</ce:simple-para></ce:caption><ce:link locator="gr11"/></ce:figure><ce:figure id="fig0060"><ce:label>Fig. 12</ce:label><ce:caption id="cap0060"><ce:simple-para id="spar0070" view="all">Trace projection with state hashing</ce:simple-para></ce:caption><ce:link locator="gr12"/></ce:figure><ce:figure id="fig0065"><ce:label>Fig. 13</ce:label><ce:caption id="cap0065"><ce:simple-para id="spar0075" view="all">Example of the folded and limited folded hash projections of a Java trace</ce:simple-para></ce:caption><ce:link locator="gr13"/></ce:figure><ce:figure id="fig0070"><ce:label>Fig. 14</ce:label><ce:caption id="cap0070"><ce:simple-para id="spar0080" view="all">Elevator: elevator waiting for clients</ce:simple-para></ce:caption><ce:link locator="gr14"/></ce:figure><ce:figure id="fig0075"><ce:label>Fig. 15</ce:label><ce:caption id="cap0075"><ce:simple-para id="spar0085" view="all">Elevator: client waiting for the elevator</ce:simple-para></ce:caption><ce:link locator="gr15"/></ce:figure><ce:table xmlns="http://www.elsevier.com/xml/common/cals/dtd" id="tbl0005" frame="topbot" colsep="0" rowsep="0"><ce:label>Table 1</ce:label><ce:caption id="cap0080"><ce:simple-para id="spar0090" view="all">Formulas for the examples.</ce:simple-para></ce:caption><tgroup cols="4" align="center"><colspec colnum="1" colname="col1" colsep="0" align="left"/><colspec colnum="2" colname="col2" colsep="0" align="left"/><colspec colnum="3" colname="col3" colsep="0" align="left"/><colspec colnum="4" colname="col4" colsep="0" align="justify"/><thead valign="top"><row rowsep="1"><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Application</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" namest="col2" nameend="col4" align="left">Formula</entry></row></thead><tbody><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">FTP server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F1</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡<hsp sp="0.25"/>(loc("<hsp sp="0.25"/><monospace>FTPServer</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>285â³) â â<hsp sp="0.25"/>(incoming<hsp sp="0.25"/>=<hsp sp="0.25"/><italic>null</italic>))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F2</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡â<hsp sp="0.25"/>(streq(FTPDConnection<hsp sp="0.25"/>.<hsp sp="0.25"/>status, "<hsp sp="0.25"/><monospace>CDUP</monospace>â³) â</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify"><hsp sp="1"/><hsp sp="1"/><hsp sp="0.25"/>â<hsp sp="0.25"/>(loc("<hsp sp="0.25"/><monospace>FTPDConnection</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>470â³))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡<hsp sp="0.25"/>((req1<hsp sp="0.25"/>â<hsp sp="0.25"/>â<hsp sp="0.25"/>(resp1)) â§ (req2<hsp sp="0.25"/>â<hsp sp="0.25"/>â<hsp sp="0.25"/>(resp2)))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F4</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">none:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>(streq(FTPDConnection<hsp sp="0.25"/>.<hsp sp="0.25"/>status, "<hsp sp="0.25"/><monospace>STOR</monospace>â³) â§</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify"><hsp sp="1"/><hsp sp="1"/><hsp sp="0.25"/>Â¬<hsp sp="0.25"/>FTPDConnection<hsp sp="0.25"/>.<hsp sp="0.25"/>authentified)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F5</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">none:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>((incoming<hsp sp="0.25"/>=<hsp sp="0.25"/>0) <italic>U</italic> (loc("<hsp sp="0.25"/><monospace>FTPServer</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>285â³)))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Elevator</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F6</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">none:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>(loc("<hsp sp="0.25"/><monospace>Elevator</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>86â³) â§ Â¬<hsp sp="0.25"/>Elevator<hsp sp="0.25"/>.<hsp sp="0.25"/>isFree)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F7</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>(loc("<hsp sp="0.25"/><monospace>Elevator</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>86â³) â§ Elevator<hsp sp="0.25"/>.<hsp sp="0.25"/>isFree)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">NFS server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F8</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">any:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>â¡<hsp sp="0.25"/>MountdHandler<hsp sp="0.25"/>.<hsp sp="0.25"/>err<hsp sp="0.25"/>&gt;<hsp sp="0.25"/>0</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F9</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â<hsp sp="0.25"/>(MountdHandler<hsp sp="0.25"/>.<hsp sp="0.25"/>err<hsp sp="0.25"/>&gt;<hsp sp="0.25"/>0 â§ â<hsp sp="0.25"/>loc("<hsp sp="0.25"/><monospace>MountdHandler</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>95â³))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F10</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">none:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">MountdHandler<hsp sp="0.25"/>.<hsp sp="0.25"/>err<hsp sp="0.25"/>=<hsp sp="0.25"/>0 <italic>U</italic> loc("<hsp sp="0.25"/><monospace>MountdHandler</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>95â³)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Web server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F11</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">any:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡<hsp sp="0.25"/>(â<hsp sp="0.25"/>(loc("<hsp sp="0.25"/><monospace>WebServer</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>65â³) â§ â<hsp sp="0.25"/>exc("<hsp sp="0.25"/><monospace>WebServerException</monospace>â³)))</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F12</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡<hsp sp="0.25"/>Â¬<hsp sp="0.25"/>loc("<hsp sp="0.25"/><monospace>ClientConnection</monospace><hsp sp="0.25"/>:<hsp sp="0.25"/>41â³)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Lists</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F13</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">all:</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="justify">â¡<hsp sp="0.25"/>â<hsp sp="0.25"/>(numElements<hsp sp="0.25"/>=<hsp sp="0.25"/>1)</entry></row></tbody></tgroup></ce:table><ce:table xmlns="http://www.elsevier.com/xml/common/cals/dtd" id="tbl0010" frame="topbot" colsep="0" rowsep="0"><ce:label>Table 2</ce:label><ce:caption id="cap0085"><ce:simple-para id="spar0095" view="all">Test results using folded counter and hash projections.</ce:simple-para></ce:caption><tgroup cols="11" align="center"><colspec colnum="1" colname="col1" colsep="0" align="left"/><colspec colnum="2" colname="col2" colsep="0" align="left"/><colspec colnum="3" colname="col3" colsep="0" align="char" char="."/><colspec colnum="4" colname="col4" colsep="0" align="char" char="."/><colspec colnum="5" colname="col5" colsep="0" align="char" char="."/><colspec colnum="6" colname="col6" colsep="0" align="char" char="."/><colspec colnum="7" colname="col7" colsep="0" align="char" char="."/><colspec colnum="8" colname="col8" colsep="0" align="char" char="."/><colspec colnum="9" colname="col9" colsep="0" align="char" char="."/><colspec colnum="10" colname="col10" colsep="0" align="char" char="."/><colspec colnum="11" colname="col11" colsep="0" align="char" char="."/><thead valign="top"><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" namest="col3" nameend="col6" align="left">Counter projection</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" namest="col7" nameend="col10" align="left">Hash projection</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row rowsep="1"><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Application</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">Formula</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">States</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">Trans.</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">S. size</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">Time</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">States</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">Trans.</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">S. size</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">Time</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">J. size</entry></row></thead><tbody><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">FTP server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F1</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">47</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">83</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">4.2<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">4.27<hsp sp="0.25"/>MB</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F2<cross-ref id="crf0005" refid="tblfn0005"><sup loc="post">3</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">150</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">187</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">14.9<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">2419</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">6211</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">34.7<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F4</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">59</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">265</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">17.6<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F4<cross-ref id="crf0010" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">130</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">131</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">48<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">0.8<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">171</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">172</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">0.9<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F5</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">33</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">34</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">84<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">3.9<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F5<cross-ref id="crf0015" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">19</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">20</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">48<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">0.8<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">23</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">24</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">76<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">5.5<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Elevator</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F6</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">31</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">219</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">28.7<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">31</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">204</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">34.7<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">0.74<hsp sp="0.25"/>MB</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F6<cross-ref id="crf0020" refid="tblfn0005"><sup loc="post">3</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">54</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">23.0<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">54</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">24.1<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F7<cross-ref id="crf0025" refid="tblfn0005"><sup loc="post">3</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">51</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">29.0<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">51</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">33.7<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">NFS server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F8<cross-ref id="crf0030" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">15.3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">94.3</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">5.1<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">17.6</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">99</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">10.8<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">4.08<hsp sp="0.25"/>MB</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F9<cross-ref id="crf0035" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">5</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">140</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">22.9<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">5</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">140</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B 1</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">27.1<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F10</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">4</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">14</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">40<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">4.6<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">4</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">14</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">5.2<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Web server</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F11</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">211</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">231</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">92<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">202<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">6.71<hsp sp="0.25"/>MB</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F11<cross-ref id="crf0040" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">165</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">175</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">64<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">8.6<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">258</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">270</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">92<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">13<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F12</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">135</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">146</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">96<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">214<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F12<cross-ref id="crf0045" refid="tblfn0010"><sup loc="post">4</sup></cross-ref></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">168</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">179</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">9.1<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">273</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">284</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">96<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">13.5<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char="."/></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Lists</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">F13</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="char" char=".">-</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col7" align="char" char=".">6</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col8" align="char" char=".">33</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col9" align="char" char=".">68<hsp sp="0.25"/>B</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col10" align="char" char=".">0.7<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col11" align="char" char=".">0.14<hsp sp="0.25"/>MB</entry></row></tbody></tgroup><ce:table-footnote id="tblfn0005"><ce:label>3</ce:label><ce:note-para id="npar0005" view="all">Formula tested over a program where errors were manually introduced.</ce:note-para></ce:table-footnote><ce:table-footnote id="tblfn0010"><ce:label>4</ce:label><ce:note-para id="npar0010" view="all">Formula tested over a finite version of the original infinite program.</ce:note-para></ce:table-footnote></ce:table><ce:table xmlns="http://www.elsevier.com/xml/common/cals/dtd" id="tbl0015" frame="topbot" colsep="0" rowsep="0"><ce:label>Table 3</ce:label><ce:caption id="cap0090"><ce:simple-para id="spar0100" view="all">Comparison of results using TJT and JPF-LTL.</ce:simple-para></ce:caption><tgroup cols="6" align="center"><colspec colnum="1" colname="col1" colsep="0" align="left"/><colspec colnum="2" colname="col2" colsep="0" align="left"/><colspec colnum="3" colname="col3" colsep="0" align="left"/><colspec colnum="4" colname="col4" colsep="0" align="left"/><colspec colnum="5" colname="col5" colsep="0" align="left"/><colspec colnum="6" colname="col6" colsep="0" align="left"/><thead valign="top"><row rowsep="1"><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left"/><entry xmlns="http://www.elsevier.com/xml/common/dtd" namest="col3" nameend="col4" align="left">TJT</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" namest="col5" nameend="col6" align="left">JPF-LTL</entry></row></thead><tbody><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Example</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">Formula</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">Transitions</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="left">Time</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="left">Transitions</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="left">Time</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Eventually1</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">â<hsp sp="0.25"/><italic>p</italic></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">8</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="left">0.6<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="left">10</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="left">0.6<hsp sp="0.25"/>s</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">Eventually2</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">â¡<hsp sp="0.25"/>â<hsp sp="0.25"/><italic>p</italic></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">68</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="left">2.2<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="left">8</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="left">0.5<hsp sp="0.25"/>s</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left">DoubleEventuallySwitch1</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col2" align="left">â<hsp sp="0.25"/><italic>p</italic><hsp sp="0.25"/>â¨<hsp sp="0.25"/>â<hsp sp="0.25"/><italic>q</italic></entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col3" align="left">8</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col4" align="left">0.6<hsp sp="0.25"/>s</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col5" align="left">37</entry><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col6" align="left">0.6<hsp sp="0.25"/>s</entry></row></tbody></tgroup></ce:table></ce:floats><head><ce:article-footnote><ce:label>â</ce:label><ce:note-para id="npar0025" view="all">This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</ce:note-para></ce:article-footnote><ce:title id="tit0005">Using SPIN for automated debugging of infinite executions of Java programs</ce:title><ce:author-group id="aug0005"><ce:author id="aut0005" biographyid="vt0005"><ce:given-name>DamiÃ¡n</ce:given-name><ce:surname>Adalid</ce:surname><ce:e-address id="eadd0005" type="email">damian@lcc.uma.es</ce:e-address></ce:author><ce:author id="aut0010" biographyid="vt0010"><ce:given-name>Alberto</ce:given-name><ce:surname>SalmerÃ³n</ce:surname><ce:e-address id="eadd0010" type="email">salmeron@lcc.uma.es</ce:e-address></ce:author><ce:author id="aut0015" biographyid="vt0015"><ce:given-name>MarÃ­a del Mar</ce:given-name><ce:surname>Gallardo</ce:surname><ce:e-address id="eadd0015" type="email">gallardo@lcc.uma.es</ce:e-address></ce:author><ce:author id="aut0020" biographyid="vt0020"><ce:given-name>Pedro</ce:given-name><ce:surname>Merino</ce:surname><ce:cross-ref id="crf0050" refid="cor0005"><ce:sup loc="post">â</ce:sup></ce:cross-ref><ce:e-address id="eadd0020" type="email">pedro@lcc.uma.es</ce:e-address></ce:author><ce:affiliation id="aff0005"><ce:textfn>Dpto. de Lenguajes y Ciencias de la ComputaciÃ³n, University of MÃ¡laga, Spain</ce:textfn><sa:affiliation><sa:organization>Dpto. de Lenguajes y Ciencias de la ComputaciÃ³n, University of MÃ¡laga</sa:organization><sa:country>Spain</sa:country></sa:affiliation></ce:affiliation><ce:correspondence id="cor0005"><ce:label>â</ce:label><ce:text>Corresponding author. Tel.: +34 952 13 2752; fax: +34 952 13 1397.</ce:text></ce:correspondence></ce:author-group><ce:date-received day="31" month="1" year="2013"/><ce:date-revised day="8" month="10" year="2013"/><ce:date-accepted day="26" month="10" year="2013"/><ce:abstract id="abs0005" class="author-highlights" view="all"><ce:abstract-sec id="abst0005" view="all"><ce:section-title id="sect0005">Highlights</ce:section-title><ce:simple-para id="spar0005" view="all"><ce:list id="list0020"><ce:list-item id="listitem0080"><ce:label>â¢</ce:label><ce:para id="p0005" view="all">We use linear time temporal logic to represent both failures and desirable behaviors regarding a temporally ordered sequence of events and/or conditions to be checked along one execution.</ce:para></ce:list-item><ce:list-item id="listitem0085"><ce:label>â¢</ce:label><ce:para id="p0010" view="all">We use model checking algorithms record the history of the failed execution, which we use to implement a controlled replay to locate the bugs.</ce:para></ce:list-item><ce:list-item id="listitem0090"><ce:label>â¢</ce:label><ce:para id="p0015" view="all">We support the analysis of potentially infinite executions.</ce:para></ce:list-item><ce:list-item id="listitem0095"><ce:label>â¢</ce:label><ce:para id="p0020" view="all">We use runtime techniques to start the debugging work directly on the programmer's code.</ce:para></ce:list-item></ce:list></ce:simple-para></ce:abstract-sec></ce:abstract><ce:abstract id="abs0010" class="author" view="all"><ce:section-title id="sect0010">Abstract</ce:section-title><ce:abstract-sec id="abst0010" view="all"><ce:simple-para id="spar0010" view="all">This paper presents an approach for the automated debugging of reactive and concurrent Java programs, combining model checking and runtime monitoring. Runtime monitoring is used to transform the Java execution traces into the input for the model checker, the purpose of which is twofold. First, it checks these execution traces against properties written in linear temporal logic (LTL), which represent desirable or undesirable behaviors. Second, it produces several execution traces for a single Java program by generating test inputs and exploring different schedulings in multithreaded programs. As state explosion is the main drawback to model checking, we propose two abstraction approaches to reduce the memory requirements when storing Java states. We also present the formal framework to clarify which kinds of LTL safety and liveness formulas can be correctly analysed with each abstraction for both finite and infinite program executions. A major advantage of our approach comes from the model checker, which stores the trace of each failed execution, allowing the programmer to replay these executions to locate the bugs. Our current implementation, the tool TJT, uses Spin as the model checker and the Java Debug Interface (JDI) for runtime monitoring. TJT is presented as an Eclipse plug-in and it has been successfully applied to debug complex public Java programs.</ce:simple-para></ce:abstract-sec></ce:abstract></head><body view="all"><ce:sections><ce:section id="sec0005" view="all"><ce:label>1</ce:label><ce:section-title id="sect0015">Introduction</ce:section-title><ce:para id="p0025" view="all">The complexity of current software development is pushing programmers towards more automated analysis techniques, instead of the traditional interactive or postmortem debuggers. For instance, unit testing allows the execution of test cases against a program, checking parts of the code such as single methods or classes in isolation (<ce:cross-refs id="crfs0005" refid="bib0170 bib0150 bib0035 bib0065">Runeson, 2006; JUnit testing and framework, xxxx; Beust and Suleiman, 2007; CppUnit framework, xxxx</ce:cross-refs>). Runtime monitoring tools usually carry out some controlled executions of instrumented code on real or emulated target platforms (<ce:cross-refs id="crfs0010" refid="bib0175 bib0155">Run-time Monitoring and Checking, (MaC), xxxx; Kraft et al., 2010</ce:cross-refs>). Model checking can produce and inspect all possible execution traces of a program, checking the presence or absence of failures along each trace (<ce:cross-refs id="crfs0015" refid="bib0050 bib0120 bib0040">Clarke et al., 1999; Havelund and Pressburger, 2000; Beyer et al., 2007</ce:cross-refs>). In the case of a failure, this technique records a trace to replay the failed execution. To overcome some of the shortcomings of these automatic methods when used in isolation and to extend their domain of application, there have been several proposals that combine a few of them (<ce:cross-refs id="crfs0020" refid="bib0165 bib0020 bib0125">Peled, 2003; Artho et al., 2003; Havelund and RoÅu, 2004</ce:cross-refs>). This paper discusses an approach to <ce:italic>automated software debugging</ce:italic> by the combination of model checking and runtime monitoring. We focus on its application to analyze the (infinite) executions of a given reactive and/or concurrent Java program.</ce:para><ce:para id="p0030" view="all">Model checking allows the software developer to describe correctness properties with specification languages such as Temporal Logic (<ce:cross-ref id="crf0055" refid="bib0160">Manna and Pnueli, 1992</ce:cross-ref>). The properties could represent <ce:italic>safety</ce:italic> requirements, like â¡<ce:italic>p</ce:italic> ("<ce:italic>p</ce:italic> is always true") and <ce:italic>p</ce:italic> U <ce:italic>q</ce:italic> ("<ce:italic>q</ce:italic> will be true, and <ce:italic>p</ce:italic> will be true in all previous states"), or <ce:italic>liveness</ce:italic> properties expressed with formulas such as â<ce:italic>p</ce:italic> ("eventually <ce:italic>p</ce:italic> will be true"), â<ce:hsp sp="0.25"/>â¡<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> ("eventually <ce:italic>p</ce:italic> will be true forever"), and â¡(<ce:italic>p</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>q</ce:italic>) ("<ce:italic>p</ce:italic> will always be followed by <ce:italic>q</ce:italic>"), <ce:italic>p</ce:italic> and <ce:italic>p</ce:italic> being any kind of proposition or even temporal formulas. The most common use of LTL is to express complex liveness behaviors of <ce:italic>infinite traces</ce:italic>, which are the traces produced by reactive and/or concurrent software (<ce:cross-ref id="crf0060" refid="bib0160">Manna and Pnueli, 1992</ce:cross-ref>).</ce:para><ce:para id="p0035" view="all">In order to check whether or not a program satisfies an LTL formula, model checking algorithms were designed to produce the whole execution graph in a concurrent program and to efficiently detect execution traces violating a formula, presenting these traces as <ce:italic>counter-examples</ce:italic>. Counter-examples provide the sequence of instructions to the error, and they are the main source of information used to <ce:italic>debug</ce:italic> the program.</ce:para><ce:para id="p0040" view="all">When we do not wish to produce all traces or check liveness properties, other less-expensive approaches, like the use of <ce:italic>runtime monitors</ce:italic> can be used to check only the subset of LTL representing safety properties. Other monitor based approaches adapt the semantics of full LTL to finite executions, as done by Java PathExplorer (<ce:cross-ref id="crf0065" refid="bib0125">Havelund and RoÅu, 2004</ce:cross-ref>). The original design of Java PathExplorer only considered finite executions, and to the best of our knowledge, the extension for infinite traces is still not available. Tools such as Verisoft (<ce:cross-ref id="crf0070" refid="bib0115">Godefroid, 1997</ce:cross-ref>) and CMC (<ce:cross-ref id="crf0075" refid="bib0190">Stoller, 2002</ce:cross-ref>) avoid storing the states of the program during monitoring, so they can perform a partial analysis of very large systems with little memory consumption. Unfortunately, this stateless approach does not permit the analysis of LTL for infinite traces.</ce:para><ce:para id="p0045" view="all">The analysis of an LTL formula along one or several potential infinite execution paths cannot be carried out with standard monitors, but requires storing the states of the program and the use of algorithms based on automata to recognize special cycles, like BÃ¼chi automata (<ce:cross-ref id="crf0080" refid="bib0050">Clarke et al., 1999</ce:cross-ref>). Stateful approaches, like the one implemented in Java PathFinder (<ce:cross-ref id="crf0085" refid="bib0200">Visser et al., 2003</ce:cross-ref>) (JPF) keep a stack with the current execution trace to control backtracking, to produce counter-examples and to check cycles, so they could check LTL on infinite traces. However, at the time of writing this paper, the extension for checking LTL formulas can only detect a few program events. In the following sections we expand on the current status of LTL verification with JPF in a comparison with our proposal.</ce:para><ce:para id="p0050" view="all">In this paper we propose a method to convert a Java execution trace into a sequence of states that can be analyzed by the model checker Spin (<ce:cross-ref id="crf0090" refid="bib0140">Holzmann, 2003</ce:cross-ref>). We use runtime monitoring to generate just the Spin oriented execution paths from real software, thereby allowing the formulas to be evaluated by Spin. Our work focuses on two major issues of software model checking, <ce:italic>analysis of infinite executions</ce:italic> and <ce:italic>efficient abstraction of execution paths.</ce:italic></ce:para><ce:para id="p0055" view="all">As Spin implements the analysis of LTL formulas by translation to BÃ¼chi automata, thanks to our method to feed Java executions to Spin as input, we can check the formulas on Java programs with infinite cycles. Furthermore, the Spin <ce:italic>stuttering</ce:italic> mechanism for dealing with finite execution traces allows us to deal with any kind of program without redefining the original LTL semantics.</ce:para><ce:para id="p0060" view="all">In order to address the second issue, the <ce:italic>abstraction of execution paths</ce:italic>, our conversion of Java traces into Spin oriented traces is based on two efficient abstraction methods of the full state of the program. The <ce:italic>counter projection</ce:italic> abstracts the Java state by preserving the variables which appear in the LTL formula and adding a counter to distinguish the rest of the state. As we do not keep all the information, the counter projection is very efficient at the cost of being useful only for finite executions. The <ce:italic>hash projection</ce:italic> abstracts each Java state with the variables in the formula plus a hash of the whole state. The way of constructing the hash makes the probability of conflict for two different states negligible, so we can rely on the Spin algorithm to check LTL based on cycle detection. The paper provides a formal study of the correctness of both abstraction methods.</ce:para><ce:para id="p0065" view="all">We have implemented the proposed approach in TJT, a tool that combines runtime monitoring and model checking and allows Java application developers to debug programs by checking complex requirements represented with temporal logic in a transparent way: the actual Java program is analyzed on the final target platform without additional modifications by the user, while the test execution is managed in the usual integrated development environment. Specifically, we combine the Spin model checker (<ce:cross-ref id="crf0095" refid="bib0140">Holzmann, 2003</ce:cross-ref>) and the runtime debugging API Java Debug Interface (JDI) (<ce:cross-ref id="crf0100" refid="bib0145">Java Platform Debugger Architecture, xxxx</ce:cross-ref>). Checking each execution means evaluating a temporal formula representing a failure, over the observable states in the program. Such observable states are provided for Spin by a runtime monitoring module built on top of the JDI support in the Java virtual machine. Both modules are integrated as a new Eclipse (<ce:cross-ref id="crf0105" refid="bib0090">Eclipse development environment, xxxx</ce:cross-ref>) plug-in for automatic debugging. TJT stores the failed executions, so that the programmer can later replay them in Eclipse to locate and fix the bugs.</ce:para><ce:para id="p0070" view="all">In summary, our method for combining Spin with runtime monitoring offers several advantages to Java developers:<ce:list id="list0025"><ce:list-item id="listitem0100"><ce:label>â¢</ce:label><ce:para id="p0075" view="all">Linear time temporal logic (LTL) is a compact and rich formalism to represent both <ce:italic>failures</ce:italic> and <ce:italic>desirable behaviors</ce:italic> regarding a temporally ordered sequence of events and/or conditions to be checked along one execution. Checking the LTL formula naturally considers the <ce:italic>history of the execution</ce:italic>, providing clear advantages compared with the isolated evaluation of invariants, assertions or just the values returned by methods.</ce:para></ce:list-item><ce:list-item id="listitem0105"><ce:label>â¢</ce:label><ce:para id="p0080" view="all">Model checking algorithms record the history of the failed execution, which we then use to implement a controlled <ce:italic>replay</ce:italic> to locate and fix the bugs.</ce:para></ce:list-item><ce:list-item id="listitem0110"><ce:label>â¢</ce:label><ce:para id="p0085" view="all">The support for <ce:italic>model checking</ce:italic> permits the analysis of potentially <ce:italic>infinite executions</ce:italic>, which may have two origins. On the one hand, they are produced by reactive software like servers or daemons (e.g. FTP servers and web proxies) which are always in execution responding to interactions with an environment (for instance, client processes). On the other hand, bugs may introduce infinite loops that should not happen. In both situations, model checking can be used to locate the cycles and to decide whether they should be considered as failures.</ce:para></ce:list-item><ce:list-item id="listitem0115"><ce:label>â¢</ce:label><ce:para id="p0090" view="all">The use of runtime techniques removes the extra work required to produce model checking oriented models and makes it possible to start the debugging work <ce:italic>directly on the programmer's code.</ce:italic></ce:para></ce:list-item></ce:list></ce:para><ce:para id="p0095" view="all">We do not intend to perform "full" model checking of Java programs, like Java PathFinder. Full model checking requires a specific virtual machine to control the Java execution in order to carry out the exploration of all possible execution paths, which is time- and memory-consuming. Our approach consists of using only some features of model checking to have a light automated debugging method that helps the programmer to locate errors. Potential errors are described with temporal logic and we use the capability of model checking to check the temporal logic formula in "one execution path", even if the execution path corresponds to the infinite behavior of a reactive program. This execution path is naturally produced by the execution of the program in the real environment, with the standard Java virtual machine.</ce:para><ce:para id="p0100" view="all">This is a cost-effective application of model checking to program traces that is nevertheless useful for finding faults in concurrent programs and debugging their causes. The use of LTL formulas and a reduced set of variables of interest produces traces as counterexamples, which are very valuable when locating bugs (<ce:cross-ref id="crf0110" refid="bib0055">Clarke et al., 2009</ce:cross-ref>). This is specially relevant in concurrent programs where it is usually more important and difficult to find interleaving of actions that produce faults, than failure-inducing test inputs (<ce:cross-ref id="crf0115" refid="bib0025">Baiardi et al., 1986</ce:cross-ref>). While the analysis of the traces for finding the root cause is still a manual process, the formulas and the selected variables of interest significantly reduce the size of the traces to analyze (<ce:cross-ref id="crf0120" refid="bib0015">Alipour, 2012</ce:cross-ref>).</ce:para><ce:para id="p0105" view="all">This paper is an extension of previous work of ours presented in (<ce:cross-ref id="crf0125" refid="bib0005">Adalid et al., 2012</ce:cross-ref>). In particular, the description of our approach, its implementation, the experimental results and comparison with related work have been significantly expanded.</ce:para><ce:para id="p0110" view="all">The rest of the paper is organized as follows. Section <ce:cross-ref id="crf0130" refid="sec0010">2</ce:cross-ref> introduces the use of model checking for debugging Java programs using a real example. Section <ce:cross-ref id="crf0135" refid="sec0030">3</ce:cross-ref> presents the architecture of TJT for combining model checking and Java runtime monitoring. The formalization of the abstraction approach and the preservation results are presented in Section <ce:cross-ref id="crf0140" refid="sec0055">4</ce:cross-ref>. Experimental results of the case studies are summarized in Section <ce:cross-ref id="crf0145" refid="sec0095">5</ce:cross-ref>. In Section <ce:cross-ref id="crf0150" refid="sec0110">6</ce:cross-ref> we compare our tool with related proposals. Finally, Section <ce:cross-ref id="crf0155" refid="sec0115">7</ce:cross-ref> presents some conclusions and points of interest for future work.</ce:para></ce:section><ce:section id="sec0010" view="all"><ce:label>2</ce:label><ce:section-title id="sect0020">Model checking for debugging</ce:section-title><ce:para id="p0115" view="all">In this section we outline how model checking can be applied for the debugging of real Java programs, as the motivation for the development of our tool. We introduce a real example (an open source FTP server) and show several tests where the use of LTL formulas would be useful. Then we introduce the semantics of the LTL formulas that we consider in our approach, i.e. the usual one for infinite traces. Finally, we discuss how Spin performs the analysis of LTL formulas, translated into BÃ¼chi automata.</ce:para><ce:section id="sec0015" view="all"><ce:label>2.1</ce:label><ce:section-title id="sect0025">Motivating example</ce:section-title><ce:para id="p0120" view="all">To illustrate our proposal we use an FTP server (<ce:cross-ref id="crf0160" refid="bib0185">Sorotokin, xxxx</ce:cross-ref>). This server understands the usual commands and can handle several concurrent user connections. We show several tests that a programmer may want to perform on the code of the server, using LTL formulas where the variables and events of the program can be referenced. The formulas are presented in a formal notation, but using helper functions, such as "loc()" for checking the program counter location, that are available in our tool. It is worth noting that the following three formulas represent <ce:italic>liveness properties</ce:italic> to be evaluated on potentially infinite executions, and they cannot be handled by other runtime checkers cited in Sections <ce:cross-ref id="crf0165" refid="sec0005">1</ce:cross-ref> and <ce:cross-ref id="crf0170" refid="sec0110">6</ce:cross-ref>.</ce:para><ce:para id="p0125" view="all">The code in <ce:cross-ref id="crf0175" refid="fig0005">Fig. 1</ce:cross-ref><ce:float-anchor refid="fig0005"/> corresponds to the main loop in the server. The programmer may want check if the program variables in the loop are correctly cleared between client connections. For instance, to check that the <ce:monospace>incoming</ce:monospace> variable is set to <ce:monospace>null</ce:monospace> after each iteration we could use the following formula:</ce:para><ce:para id="p0130" view="all"><ce:display><ce:formula id="eq0005"><ce:label>(1)</ce:label><mml:math altimg="si1.gif" overflow="scroll"><mml:mo>â¡</mml:mo><mml:mtext> </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">loc</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>"</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">FTPServer</mml:mi><mml:mo>:</mml:mo><mml:mn>285</mml:mn></mml:mrow><mml:mo>â³</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">incoming</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">null</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></ce:formula></ce:display></ce:para><ce:para id="p0135" view="all">This formula states that, after reaching line 285 of the FTPServer.java file in Fig. <ce:cross-ref id="crf0180" refid="fig0005">1</ce:cross-ref>), the <ce:monospace>incoming</ce:monospace> variable should be <ce:monospace>null</ce:monospace> at some point in the future.</ce:para><ce:para id="p0140" view="all"><ce:cross-ref id="crf0185" refid="fig0010">Fig. 2</ce:cross-ref><ce:float-anchor refid="fig0010"/> shows the method that handles <ce:monospace>CWD</ce:monospace> (change directory) commands. If a client performs an erroneous request the operation should fail, but the server should recover from the exception and return the appropriate error code (line 471). The programmer may want to check if this code is reachable when a client misbehaves, using the following formula:</ce:para><ce:para id="p0145" view="all"><ce:display><ce:formula id="eq0010"><ce:label>(2)</ce:label><mml:math altimg="si2.gif" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mo>â¡</mml:mo><mml:mo>â</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">streq</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">FTPDConnection</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">status</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mo>"</mml:mo><mml:msup><mml:mi mathvariant="normal">CDUP</mml:mi><mml:mo>â³</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mo>â</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">loc</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>"</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">FTPDConnection</mml:mi><mml:mo>:</mml:mo><mml:mn>470</mml:mn></mml:mrow><mml:mo>â³</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd columnalign="left"/></mml:mtr></mml:mtable></mml:math></ce:formula></ce:display></ce:para><ce:para id="p0150" view="all">Testing these and other properties requires the use of controlled mock clients as part of the test fixture. In this case, the client tries to send several <ce:monospace>CDUP</ce:monospace> commands (change to parent directory), which are executed as <ce:monospace>CWD</ce:monospace> commands in the server and should lead to the behavior described above.</ce:para><ce:para id="p0155" view="all">The final condition that we want to check deals with thread scheduling and fairness. In addition to synchronization problems, multithreaded programs are prone to fairness issues: some of the threads may take all the CPU time, leaving others starving. The programmer may want to check whether this is a possible outcome under the default scheduling employed by the JVM or under other schedulings that may be forced in the execution. For instance, we can check the fairness between two clients that compete with each other to interact with the FTP server in a loop.</ce:para><ce:para id="p0160" view="all"><ce:display><ce:formula id="eq0015"><ce:label>(3)</ce:label><mml:math altimg="si3.gif" overflow="scroll"><mml:mo>â¡</mml:mo><mml:mtext> </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">req</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mrow><mml:mi mathvariant="normal">resp</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mtext> </mml:mtext><mml:mo>â§</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">req</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>â</mml:mo><mml:mrow><mml:mi mathvariant="normal">resp</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></ce:formula></ce:display></ce:para><ce:para id="p0165" view="all">For clarity, in the previous formula we used boolean propositions, such as req1, instead of referencing program variables like in the first two formulas. These propositions refer to auxiliary boolean variables in the FTP clients, i.e. the <ce:monospace>clientFTP</ce:monospace> and <ce:monospace>clientFTP2</ce:monospace> classes.</ce:para></ce:section><ce:section id="sec0020" view="all"><ce:label>2.2</ce:label><ce:section-title id="sect0030">LTL for Java traces</ce:section-title><ce:para id="p0170" view="all">In this section, we give a formal characterization of LTL formulas for Java, like the three examples used above.</ce:para><ce:para id="p0175" view="all">Let <ce:italic>Prog</ce:italic> be a Java program and <ce:italic>Var</ce:italic> an enumerable set of variable names used by <ce:italic>Prog</ce:italic>. The variables' names may be recursively constructed by appending the name of class members to object identifiers. For instance, if <ce:italic>o</ce:italic> is a reference to an object of class <ce:italic>C</ce:italic>, and <ce:italic>f</ce:italic> is an instance variable of <ce:italic>C</ce:italic>, <ce:italic>o</ce:italic><ce:hsp sp="0.25"/>.<ce:hsp sp="0.25"/><ce:italic>f</ce:italic> is the name of the variable recording the value of field <ce:italic>f</ce:italic> in the object instance <ce:italic>o</ce:italic>.</ce:para><ce:para id="p0180" view="all">Values of Java variables may belong to a Java primitive data type (<ce:italic>int</ce:italic>, <ce:italic>char</ce:italic>, â¦) or may be a reference if the variable is an object. Let <mml:math altimg="si4.gif" overflow="scroll"><mml:mi mathvariant="script">A</mml:mi></mml:math> and <mml:math altimg="si5.gif" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math> be the set of possible memory references and the set of all possible values of Java primitive data types. A state of a Java program is a function <mml:math altimg="si6.gif" overflow="scroll"><mml:mi>Ï</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="italic">Var</mml:mi><mml:mo>â</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math> that associates each variable with its value. Let us denote with <ce:italic>States</ce:italic> the set of possible states of a Java program <ce:italic>Prog</ce:italic>. Assume that if <ce:italic>h</ce:italic> is a variable referencing a thread, then <ce:italic>Ï</ce:italic>(<ce:italic>h</ce:italic><ce:hsp sp="0.25"/>.<ce:hsp sp="0.25"/><ce:italic>cp</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>int</ce:italic> represents the position of the program counter of <ce:italic>h</ce:italic> in <ce:italic>Ï</ce:italic>.</ce:para><ce:para id="p0185" view="all">Each possible execution of <ce:italic>Prog</ce:italic> may be represented as an infinite sequence of states<ce:cross-ref id="crf0190" refid="fn0005"><ce:sup loc="post">1</ce:sup></ce:cross-ref><ce:footnote id="fn0005"><ce:label>1</ce:label><ce:note-para id="npar0020" view="all">If the sequence is finite, we assume that the last state is infinitely repeated.</ce:note-para></ce:footnote><ce:display><ce:formula id="eq0020"><ce:label>(4)</ce:label><mml:math altimg="si7.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:mo>â¦</mml:mo><mml:mo>â</mml:mo><mml:msup><mml:mi mathvariant="italic">States</mml:mi><mml:mi>Ï</mml:mi></mml:msup></mml:math></ce:formula></ce:display></ce:para><ce:para id="p0190" view="all"><ce:italic>States</ce:italic><ce:sup loc="post"><ce:italic>Ï</ce:italic></ce:sup> being the set of all possible infinite sequences of elements from <ce:italic>States</ce:italic>, called traces.</ce:para><ce:para id="p0195" view="all">We now recall the syntax and semantics of LTL. Let <mml:math altimg="si8.gif" overflow="scroll"><mml:mi mathvariant="script">Prop</mml:mi></mml:math> be a set of atomic propositions. The set of LTL temporal formulas may be inductively built using the elements of <mml:math altimg="si9.gif" overflow="scroll"><mml:mi mathvariant="script">Prop</mml:mi></mml:math>, the standard Boolean operators, and the <ce:italic>temporal operators</ce:italic>: <ce:italic>next</ce:italic> "â", <ce:italic>always</ce:italic> "â¡", <ce:italic>eventually</ce:italic> "â", and <ce:italic>until</ce:italic> "U".</ce:para><ce:para id="p0200" view="all">We assume that given a Java state <ce:italic>Ï</ce:italic>, and an atomic proposition <mml:math altimg="si10.gif" overflow="scroll"><mml:mi>p</mml:mi><mml:mo>â</mml:mo><mml:mi mathvariant="script">Prop</mml:mi></mml:math>, <ce:italic>Ï</ce:italic><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> represents the result of evaluating <ce:italic>p</ce:italic> on <ce:italic>Ï</ce:italic>, that is, <ce:italic>Ï</ce:italic><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> holds iff <ce:italic>Ï</ce:italic> satisfies <ce:italic>p</ce:italic>. In what follows, given a (possibly infinite) Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â¯, we denote with <ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>â<ce:hsp sp="0.25"/>â¯ the suffix of <ce:italic>t</ce:italic> starting at state <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>. Consider <mml:math altimg="si11.gif" overflow="scroll"><mml:mi>p</mml:mi><mml:mo>â</mml:mo><mml:mi mathvariant="script">Prop</mml:mi></mml:math>, and <ce:italic>f</ce:italic> and <ce:italic>g</ce:italic> two LTL formulas. We inductively define â¨ over traces and LTL formulas as follows.<ce:list id="list0005"><ce:list-item id="listitem0005"><ce:label>1</ce:label><ce:para id="p0205" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> iff <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic>.</ce:para></ce:list-item><ce:list-item id="listitem0010"><ce:label>2</ce:label><ce:para id="p0210" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/>Â¬<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> iff <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â­<ce:hsp sp="0.25"/><ce:italic>p</ce:italic>.</ce:para></ce:list-item><ce:list-item id="listitem0015"><ce:label>3</ce:label><ce:para id="p0215" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>q</ce:italic> iff <ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>p</ce:italic> or <ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>q</ce:italic>.</ce:para></ce:list-item><ce:list-item id="listitem0020"><ce:label>4</ce:label><ce:para id="p0220" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>f</ce:italic> iff <ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic>+1</ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f</ce:italic>.</ce:para></ce:list-item><ce:list-item id="listitem0025"><ce:label>5</ce:label><ce:para id="p0225" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/>â¡<ce:hsp sp="0.25"/><ce:italic>f</ce:italic> iff <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f</ce:italic> and <ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic>+1</ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/>â¡<ce:hsp sp="0.25"/><ce:italic>f</ce:italic>.</ce:para></ce:list-item><ce:list-item id="listitem0030"><ce:label>6</ce:label><ce:para id="p0230" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>f</ce:italic> iff â<ce:italic>j</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/><ce:italic>i</ce:italic><ce:hsp sp="0.25"/>.<ce:hsp sp="0.25"/>(<ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f</ce:italic>).</ce:para></ce:list-item><ce:list-item id="listitem0035"><ce:label>7</ce:label><ce:para id="p0235" view="all"><ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f U g</ce:italic> iff â<ce:italic>j</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/><ce:italic>i</ce:italic><ce:hsp sp="0.25"/>.<ce:hsp sp="0.25"/>(<ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>g</ce:italic> and â<ce:italic>i</ce:italic><ce:hsp sp="0.25"/>â¤<ce:hsp sp="0.25"/><ce:italic>k</ce:italic><ce:hsp sp="0.25"/>&lt;<ce:hsp sp="0.25"/><ce:italic>j</ce:italic><ce:hsp sp="0.25"/>.<ce:hsp sp="0.25"/>[<ce:italic>t</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f</ce:italic>]).</ce:para></ce:list-item></ce:list></ce:para><ce:para id="p0240" view="all">Note that the operator <ce:italic>implies</ce:italic> "â" is usually omitted in these rules and transformed into a combination of negation and disjunction.</ce:para><ce:para id="p0245" view="all">In what follows, we use the same LTL semantics as Spin, without the <ce:italic>next</ce:italic> operator as usual. Note that in <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>â¨<ce:hsp sp="0.25"/><ce:italic>f</ce:italic>, <ce:italic>t</ce:italic> may be a prefix of a complete Java trace, i.e. it may not be necessary to generate the whole trace in order to check the satisfaction of a property.</ce:para></ce:section><ce:section id="sec0025" view="all"><ce:label>2.3</ce:label><ce:section-title id="sect0035">Checking LTL with SPIN</ce:section-title><ce:para id="p0250" view="all">Spin is a well known model checker for analyzing models of software and other complex systems, defined with the Promela language. Promela contains constructions for describing concurrent and non-deterministic behavior which, combined with the right tool, makes it easier to discover unexpected events or interactions which could be difficult to find in the traditional debugging tools available for programming languages.</ce:para><ce:para id="p0255" view="all">A Promela model produces a set of possible executions called execution traces or paths. The role of Spin is to look for traces that satisfy or violate a given set of properties. Properties include deadlocks, assertions, code reachability or non-progress loops. However, the most interesting set of properties are complex requirements described with linear temporal logic (LTL) (<ce:cross-ref id="crf0195" refid="bib0160">Manna and Pnueli, 1992</ce:cross-ref>).</ce:para><ce:para id="p0260" view="all">Spin implements the algorithms by <ce:cross-ref id="crf0200" refid="bib0195">Vardi and Wolper (1986)</ce:cross-ref> to check LTL properties, which are based in the translation of the negated LTL formula into a BÃ¼chi automaton. A BÃ¼chi automaton is defined as a standard automaton that recognizes states in a programm to be analysed, but with the addition of final states (also called "accepting states") that restrict the number of executions allowed by the automaton. In particular, we say that one execution of the program violates the original LTL formula if the corresponding BÃ¼chi automaton visits, at least, one of the accepting states infinitely often. This method is well suited to check LTL liveness properties in infinite program executions, and has been adapted in Spin to be used for finite executions as well.</ce:para><ce:para id="p0265" view="all"><ce:cross-ref id="crf0205" refid="fig0020">Fig. 4</ce:cross-ref><ce:float-anchor refid="fig0020"/> contains a simplified graphical representation of the BÃ¼chi automaton generated from Formula <ce:cross-ref id="crf0210" refid="eq0015">(3)</ce:cross-ref>, from the examples above. This automaton is executed synchronously with the Java trace, inspecting the Java states to decide which transition (or transitions) must be taken, and stopping when no transition is possible. A trace is accepted if it contains a finite sequence of states (a cycle) including an accepting state, which repeats infinitely often. Accepting states are represented with a double circle in the figure. Using this automata to recognize a given Java execution trace, Spin could find a violation of that formula, i.e. an execution where one client makes the other starve. The violation would include the instructions executed in the program, up to the point where the error was found. For instance, a simplified trace for a violation of this formula, only including the locations where the variables from the formula change their value, is shown in <ce:cross-ref id="crf0215" refid="fig0015">Fig. 3</ce:cross-ref><ce:float-anchor refid="fig0015"/> (cycle between steps 8 and 10). These variables are initialized on line 25 on both files, they change on line 270 to indicate that a request has been issued, and change again in lines 275 and 280 (of classes <ce:monospace>clientFTP</ce:monospace> and <ce:monospace>clientFTP2</ce:monospace>, respectively), when said request has been satisfied. Others variables can be included in the trace if requested, as well.</ce:para><ce:para id="p0270" view="all">Given a Promela model, Spin performs an exhaustive exploration of its state space. Full-state on-the-fly explicit model checking, as implemented in Spin, requires two main data structures to manage model states (see <ce:cross-ref id="crf0220" refid="fig0025">Fig. 5</ce:cross-ref><ce:float-anchor refid="fig0025"/>): the <ce:italic>stack</ce:italic> and the <ce:italic>hash table</ce:italic>. While performing a depth-first search, Spin stores the states of the current path in the stack. This allows Spin to backtrack to a previous state and also to find cycles, both in the model under verification and in the BÃ¼chi automaton which represents the temporal property. The hash table is used to store all unique states visited while exploring the model, so that Spin does not explore the same path twice.</ce:para><ce:para id="p0275" view="all">The model checking algorithm requires the full representation of each state to be included in both data structures (stack and hash table). This might pose a problem for large models, where the number of states to be stored can be higher than 10<ce:sup loc="post">20</ce:sup>. In order to deal with such large models, Spin has been extended with several optimization techniques, some of which can be used in TJT. <ce:italic>Hash-compact</ce:italic> (<ce:cross-ref id="crf0225" refid="bib0205">Wolper et al., 1993</ce:cross-ref>) reduces the use of memory by compressing the representation of the states without losing information. <ce:italic>Bit-state hashing</ce:italic> (<ce:cross-ref id="crf0230" refid="bib0135">Holzmann, 1995</ce:cross-ref>) represents states as single bits in a hash table, which may lead to a partial analysis of the model in some cases. Currently, work is being carried out in order to obtain parallel versions of Spin that preserve most of these optimizations (<ce:cross-ref id="crf0235" refid="bib0130">Holzmann and Bosnacki, 2007</ce:cross-ref>). Finally, there are other strategies that deal with scalability, such as the automatic transformation of the models to implement abstraction methods (<ce:cross-ref id="crf0240" refid="bib0100">Gallardo et al., 2004</ce:cross-ref>) or the abstract matching proposed in (<ce:cross-ref id="crf0245" refid="bib0080">de la CÃ¡mara et al., 2010</ce:cross-ref>).</ce:para></ce:section></ce:section><ce:section id="sec0030" view="all"><ce:label>3</ce:label><ce:section-title id="sect0040">TJT approach for debugging Java executions</ce:section-title><ce:para id="p0280" view="all">This section gives an overview of our approach for debugging Java programs using model checking and runtime monitoring. The main idea is to make Spin handle the states produced by Java instead of the states produced by a regular Promela model. In the standard use of Spin, states are produced by the execution of Promela specifications. Such states include all the local and global variables in the Promela specification and other information, such as the program counters of the processes or the contents of the communications channels. The entire space state generated from the Promela code is managed with the <ce:italic>stack</ce:italic> and <ce:italic>hash table</ce:italic> in order to check properties such as deadlocks and LTL formulas. In our particular use of Spin, states are produced by the execution of Java programs. However, in order to reuse Spin features transparently, we still use a special Promela specification that is able to transform sequences of Java states into sequences of Promela-like states. Thereby, we can check complex correctness requirements, like LTL properties, on the Java execution.</ce:para><ce:para id="p0285" view="all"><ce:cross-ref id="crf0250" refid="fig0030">Fig. 6</ce:cross-ref><ce:float-anchor refid="fig0030"/> shows an overview of the architecture and the workflow of our tool TJT, which is divided into three modules: the <ce:italic>model checking module</ce:italic>, the <ce:italic>runtime monitoring module</ce:italic> and the <ce:italic>Eclipse plug-in</ce:italic>. The programmer must supply two inputs in this workflow (to the left of the figure): the main entrypoint of the Java program being analyzed and an XML file with the test specification. This main entrypoint may be the real one from the program, or a specific main method associated with a particular test scenario. The test specification includes the correctness requirement: a complex behavior described in a formalism supported by Spin, such as an LTL formula. The user must also declare the objective of the formula, i.e. whether it represents a behavior that should be checked for <ce:italic>all</ce:italic> traces (desired behavior), <ce:italic>none</ce:italic> (undesired behavior) or if it is enough for <ce:italic>any</ce:italic> trace to satisfy it (whether that is desired or undesired behavior is up to the programmer). This specification also contains additional information for carrying out the tests, like the program parameters, and their ranges, for generating test inputs.</ce:para><ce:para id="p0290" view="all">The <ce:italic>model checking module</ce:italic>, implemented with Spin and a special Promela template, creates a series of Java Virtual Machines (JVMs) to execute the Java program with all the values considered for the configuration variables. The executions are actually launched and monitored by the <ce:italic>runtime monitoring module</ce:italic>, which detects the events that are relevant for checking the LTL formula. Each event provokes the creation of a Java state that is sent to the <ce:italic>model checking module</ce:italic>. Spin processes the information reported by the monitoring module for each execution of the program, and checks the LTL formula. When Spin detects that a Java execution does not match an LTL formula and objective (desired/undesired), it sends information to the <ce:italic>Eclipse plug-in</ce:italic> in order to show the steps that have led to the failed execution. In the following section we discuss model checking in detail, focusing on efficient methods for abstracting the Java states.</ce:para><ce:para id="p0295" view="all">Each Java execution is carried out in the target platform under the control of our <ce:italic>runtime monitoring module</ce:italic>, which has been implemented in Java using JDI (<ce:cross-ref id="crf0255" refid="bib0145">Java Platform Debugger Architecture, xxxx</ce:cross-ref>). The monitor and the program being tested run in different JVMs. JDI offers an event based framework, where the application can be notified of certain events in a remote JVM, such as breakpoints, exceptions, changes in object fields or thread states. The monitoring module watches the events relevant to the specified property and sends the information to the <ce:italic>model checking module</ce:italic>.</ce:para><ce:para id="p0300" view="all">At present, our tool can check LTL properties on finite and infinite traces, asserts, and deadlocks. The LTL property can reference class variables present in the Java program, thrown exceptions or breakpoints set at specific locations in the code. When Java executions are finite, we take advantage of the stuttering mechanism implemented in Spin (<ce:cross-ref id="crf0260" refid="bib0140">Holzmann, 2003</ce:cross-ref>), and we assume the semantics derived from considering the last state of the trace repeated forever. So, there are no limitations to using the LTL formulas supported by Spin. In addition, deadlocks can be detected by the monitoring module by checking the status of each thread before processing each event.</ce:para><ce:para id="p0305" view="all">TJT analyzes each program trace independently. Different traces can be generated by providing information about the input parameters of the program, which will generate different test inputs. These test inputs are currently passed on to the main method of the program as command line arguments. A main method developed specifically for a test may use these arguments to set different parameters in the program, or to execute slightly different test scenarios. In addition, the program may be run more than once with the same test input, in order to produce different schedulings for threaded programs. In connection with this, we are experimenting with the automatic insertion of calls to methods that alter thread scheduling, e.g. <ce:monospace>yield</ce:monospace> and <ce:monospace>sleep</ce:monospace>, to cover a greater range of program schedulings.</ce:para><ce:para id="p0310" view="all">We have also developed an Eclipse plug-in to make executing tests and reviewing their results more user-friendly. The plug-in includes a form-based editor for creating test specification files, instead of writing error prone XML code. This includes selecting fields to be monitored, setting breakpoints, writing the LTL property to be checked and declaring the test input parameters. Once the specification has been finished, it can be executed within Eclipse and its progress tracked in the TJT console. After the test has finished, a dedicated view shows the erroneous traces that were found, i.e. the execution paths that led to a property violation. Clicking on a trace line takes the user to the corresponding Java line of code. A screenshot of the plug-in is shown in <ce:cross-ref id="crf0265" refid="fig0035">Fig. 7</ce:cross-ref><ce:float-anchor refid="fig0035"/>. The tool TJT and several examples can be downloaded from (<ce:cross-ref id="crf0270" refid="bib0010">Adalid et al., xxxx</ce:cross-ref>).</ce:para><ce:section id="sec0035" view="all"><ce:label>3.1</ce:label><ce:section-title id="sect0045">Implementation with Spin and JDI</ce:section-title><ce:para id="p0315" view="all">This section explains our approach, which uses Spin as the core of the <ce:italic>model checking module</ce:italic> of our debugging tool for Java. In addition to the capability to check properties with BÃ¼chi automata, Spin also allows embedding C code in the Promela models, using <ce:monospace>c_code</ce:monospace> blocks. These blocks are executed atomically by Spin and may interact with global state variables or call external library functions. The <ce:monospace>c_expr</ce:monospace> allows the evaluation of a C expression free from side effects, e.g. to use it as a loop condition. Furthermore, C variables can be treated as if they were part of the global state. Using <ce:monospace>c_track</ce:monospace>, existing C variables can be tracked and included in the global state, even as <ce:italic>unmatched</ce:italic> variables, i.e. they are stored in the stack but not in the hash. Unmatched variables are restored when backtracking, but they are not taken into account when deciding whether two states are equal (see (<ce:cross-ref id="crf0275" refid="bib0140">Holzmann, 2003</ce:cross-ref>) for details). Note that states in the stack contain all the information whereas the hash table contains only part of the information. We take advantage of these C oriented features to communicate Spin with the JDI-based monitor, to represent the Java states in Spin, and to implement our abstraction methods for Java states, explained in Section <ce:cross-ref id="crf0280" refid="sec0050">3.1.3</ce:cross-ref>.</ce:para><ce:para id="p0320" view="all">As explained above, while Spin is generally used to check program specifications written in its own Promela language, TJT uses a special Promela specification, part of which is shown in <ce:cross-ref id="crf0285" refid="fig0040">Fig. 8</ce:cross-ref><ce:float-anchor refid="fig0040"/>, to drive all the automatic debugging work. Such Promela code contains the logic to generate the values for the configuration variables that produce different executions, to communicate with the <ce:italic>runtime monitoring module</ce:italic> and to check whether a Java execution fails. The code is automatically generated using an initial Promela template and the information provided by the user in the <ce:italic>correctness specification file</ce:italic> (see <ce:cross-ref id="crf0290" refid="fig0030">Fig. 6</ce:cross-ref>). When an LTL formula is present in this file, it is translated into a BÃ¼chi automaton, and then included in the resulting Promela specification as a <ce:monospace>never</ce:monospace> claim definition. If the formula represents a behavior that must be satisfied in <ce:italic>all</ce:italic> traces, it is negated first, in order to find counterexamples.</ce:para><ce:para id="p0325" view="all">The execution of this Promela code by Spin is summarized in Algorithm <ce:cross-ref id="crf0295" refid="enun0005">1</ce:cross-ref>. This algorithm shows how Spin produces and inspects several Java traces, depending on the potential values for the configuration variables in the <ce:italic>correctness specification file</ce:italic>. For each combination of input values, Spin launches a new execution and then enters a loop to collect the sequence of Java states for that execution, checking the LTL formula and reporting failed executions to the <ce:italic>Eclipse plug-in</ce:italic>. This is described in more detail in the following sections.</ce:para><ce:para id="p0330" view="all"><ce:enunciation id="enun0005"><ce:label>Algorithm 1</ce:label><ce:para id="p0335" view="all">TJT main loop: Spin executing the Promela code in <ce:cross-ref id="crf0300" refid="fig0040">Fig. 8</ce:cross-ref>. <ce:display><ce:table xmlns="http://www.elsevier.com/xml/common/cals/dtd" id="tbl0020" frame="none" colsep="0" rowsep="0"><tgroup cols="1" align="center"><colspec colnum="1" colname="col1" colsep="0" align="left"/><tbody><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><bold>while</bold> !testInputsExhausted <bold>do</bold></entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/>input â generateInput()</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/>newExecution(input)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/>step â 0</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/><bold>while</bold> !error AND !finished <bold>do</bold></entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="2"/> nextState(step)</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="2"/> step â step + 1</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/><bold>end while</bold></entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/><bold>if</bold> error <bold>then</bold></entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="2"/> storeTrace()</entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><hsp sp="1.0"/><bold>end if</bold></entry></row><row><entry xmlns="http://www.elsevier.com/xml/common/dtd" colname="col1" align="left"><bold>end while</bold></entry></row></tbody></tgroup></ce:table></ce:display></ce:para></ce:enunciation></ce:para><ce:section id="sec0040" view="all"><ce:label>3.1.1</ce:label><ce:section-title id="sect0050">The main loop</ce:section-title><ce:para id="p0340" view="all">The loop represented in Algorithm <ce:cross-ref id="crf0305" refid="enun0005">1</ce:cross-ref> actually corresponds to the execution (in Spin) of lines 17 to 22 of the code in <ce:cross-ref id="crf0310" refid="fig0040">Fig. 8</ce:cross-ref>. The first two functions, <ce:monospace>initialization()</ce:monospace> and <ce:monospace>createSocket()</ce:monospace> are executed as if they were a single instruction, using the <ce:monospace>c_code</ce:monospace> mechanism. They create all the data and communication structures needed to connect the <ce:italic>model checking</ce:italic> and the <ce:italic>runtime monitoring modules</ce:italic>. Note that the communication is done with a socket, so if necessary, e.g. to increase performance, they can run in different computers. To ensure interoperability of these two modules in different nodes, we also use standard XDR-based encoding for the data transferred in this socket.</ce:para><ce:para id="p0345" view="all">Each Java execution corresponds to a possible combination of values for configuration variables defined by the user in the <ce:italic>correctness requirement</ce:italic> (see <ce:cross-ref id="crf0315" refid="fig0030">Fig. 6</ce:cross-ref>). The generation of one combination of values is done by <ce:monospace>generateConfig()</ce:monospace>. The function <ce:monospace>execute()</ce:monospace> launches the Java program being tested with the given configuration values as test input under the supervision of the monitoring module. When the current Java execution finishes, Spin backtracks to <ce:monospace>generateConfig()</ce:monospace> to select another set of values for the configuration variables. Then, <ce:monospace>execute()</ce:monospace> is again called to run the program under the new test input. This backtracking-based process continues until no more combinations are possible. The result is the exploration of all the Java executions defined by the programmer in the test specification file.</ce:para></ce:section><ce:section id="sec0045" view="all"><ce:label>3.1.2</ce:label><ce:section-title id="sect0055">Getting new Java states and checking failures</ce:section-title><ce:para id="p0350" view="all">The current Java execution trace is reconstructed in Spin thanks to the <ce:monospace>getNextState()</ce:monospace> function partially shown in <ce:cross-ref id="crf0320" refid="fig0045">Fig. 9</ce:cross-ref><ce:float-anchor refid="fig0045"/>. The next state is either read from the socket with the <ce:italic>runtime monitoring module</ce:italic> (lines 9 to 16) or retrieved from a list of already visited states in the case of backtracking, as will be explained below. For each new state, we check events such as program termination (line 17) or assertion violations (line 21), which are also communicated through the socket. The current list of failure-related events include a dozen cases.</ce:para><ce:para id="p0355" view="all">The most interesting analysis is checking LTL properties. Spin checks each execution path using a double depth-first search algorithm that maintains a stack of program states ("Spin States" in <ce:cross-ref id="crf0325" refid="fig0030">Fig. 6</ce:cross-ref>). The state of the BÃ¼chi automaton, which is used to track the satisfaction of an LTL property, is also stored as part of the global state. Each state <ce:italic>s</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> handled by Spin is composed of three components ã<ce:italic>j</ce:italic>, <ce:italic>Ï</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>), <ce:italic>b</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>ã, where <ce:italic>b</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> is the state of the BÃ¼chi automata which is executed synchronously with the system, <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf> is the current Java state provided by the <ce:italic>runtime monitoring module</ce:italic>, and <ce:italic>Ï</ce:italic> is a projection function used to simplify the Java states before being analyzed by Spin. The fact that the indexes of <ce:italic>s</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> and <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf> are not necessarily equal will be explained below.</ce:para><ce:para id="p0360" view="all">Although the execution of a Java program results in a linear sequence of states, the addition of the BÃ¼chi automaton representing the LTL formula may result in several branches that must be explored exhaustively. To support this, variable values received from the <ce:italic>runtime monitoring module</ce:italic> are first stored in a Java trace stack ("Java Trace" in <ce:cross-ref id="crf0330" refid="fig0030">Fig. 6</ce:cross-ref>), and then retrieved from there, as needed (as explained above). Therefore, if Spin backtracks during the search, the BÃ¼chi automaton will produce new states but the Java states will be a replay of the previously visited states. Note that we have acknowledged this in <ce:cross-ref id="crf0335" refid="fig0030">Fig. 6</ce:cross-ref> by not necessarily showing the same subindex for the whole state <ce:italic>s</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> and the corresponding Java part <ce:italic>Ï</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>).</ce:para></ce:section><ce:section id="sec0050" view="all"><ce:label>3.1.3</ce:label><ce:section-title id="sect0060">Representing Java states inside Spin</ce:section-title><ce:para id="p0365" view="all">The main drawback that usually has to be taken into consideration when applying model checking to programming languages is state space explosion: states may be too large and too many to be stored in the memory. Apart from taking advantage of some of the Spin optimization methods described in Section <ce:cross-ref id="crf0340" refid="sec0010">2</ce:cross-ref>, our tool TJT deals with these problems with several novel techniques. The first one consists of selecting the Java states to be sent to the <ce:italic>model checking module</ce:italic>: we only send those states produced after relevant events in the Java execution. These events include exceptions, deadlocks, update of designated variables, method entry and exit, interactions with monitors, breakpoints, and program termination.</ce:para><ce:para id="p0370" view="all">The second optimization consists of <ce:italic>abstracting</ce:italic> (projecting) the Java state when it is converted to a Spin state. The simplest abstraction method generates a Spin state with only some (a small number) of the variables of the current Java state. These variables are stored in C variables, which are tracked by Spin and part of the global state. In this case, the <ce:italic>runtime monitoring module</ce:italic> only sends the <ce:italic>Ï</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>) part of the original <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf> Java state. These selected variables are those that are relevant for checking the user requirements, like the LTL formula. We include one additional variable, the index <ce:italic>j</ce:italic>, in the Spin state, which is useful to retrieve the appropriate Java state <ce:italic>Ï</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>) when backtracking, as shown in <ce:cross-ref id="crf0345" refid="fig0045">Fig. 9</ce:cross-ref>.</ce:para><ce:para id="p0375" view="all">An alternative, and more complex, abstraction method consists of building an optimized Spin state with all the information in the Java state. Note that this information may be huge, and includes all the variables in objects, thread state and static variables (states <ce:italic>Ï</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>) and <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf> Java would be the same). This state is optimized in two steps. First, we collect strings representing the Java hash value for all objects, threads and static variables. Then, we apply the hashing algorithm MD5 to a canonical concatenation of these strings. The result is extremely efficient in both processing time and size of the final state. This abstraction method, called <ce:italic>state hashing</ce:italic>, is suitable for checking cycles in Spin, and it can be used to detect cycles in the Java program and to check LTL liveness formulas in infinite executions of Java programs.</ce:para><ce:para id="p0380" view="all">Both abstraction methods are implemented, making use of the Promela features for embedded C code as explained above. The next section is dedicated to describing and proving the correctness of these abstraction methods supported by TJT.</ce:para></ce:section></ce:section></ce:section><ce:section id="sec0055" view="all"><ce:label>4</ce:label><ce:section-title id="sect0065">Abstraction of Java traces</ce:section-title><ce:para id="p0385" view="all">In this section we formalize the Java state abstractions mentioned in previous section and which enable the analysis of infinite Java execution traces.</ce:para><ce:section id="sec0060" view="all"><ce:label>4.1</ce:label><ce:section-title id="sect0070">Definitions</ce:section-title><ce:para id="p0390" view="all">A Java trace <ce:italic>t</ce:italic>, as defined in Section <ce:cross-ref id="crf0350" refid="sec0020">2.2</ce:cross-ref>, represents a possible Java execution of a given program. However, sometimes we do not intend for Spin to analyze complete Java traces. Instead, Spin will be given <ce:italic>projections</ce:italic> of traces, some Java states are discarded, and the states that are transferred are simplified. Only the part of the state that is involved in the evaluation of the formula is transferred to the model checker. We now describe how the projection of Java states is constructed and the correctness relation between the evaluation results regarding the original traces, and the projected ones on Spin. In order to simplify the presentation below, we assume that the set of possible data values of program variables, <mml:math altimg="si12.gif" overflow="scroll"><mml:mi mathvariant="script">A</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math> contains the integer numbers.</ce:para><ce:para id="p0395" view="all"><ce:enunciation id="enun0010"><ce:label>Definition 1</ce:label><ce:para id="p0400" view="all">[Projection] Given a subset of variables <ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var, we define the projection of a state <ce:italic>Ï</ce:italic> onto <ce:italic>V</ce:italic> as the function <mml:math altimg="si13.gif" overflow="scroll"><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>â</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math> such that <mml:math altimg="si14.gif" overflow="scroll"><mml:mo>â</mml:mo><mml:mi>v</mml:mi><mml:mo>â</mml:mo><mml:mi>V</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>. Now, given a Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">2</ce:inf><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>â¦, we define the projection of <ce:italic>t</ce:italic> onto <ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var as<ce:display><ce:formula id="eq0025"><ce:label>(5)</ce:label><mml:math altimg="si15.gif" overflow="scroll"><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:mo>â¦</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0405" view="all"><ce:cross-ref id="crf0355" refid="fig0050">Fig. 10</ce:cross-ref><ce:float-anchor refid="fig0050"/> shows the projection <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>V</ce:italic></ce:inf> of a trace. Observe that <ce:italic>V</ce:italic> divides each state <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> into two parts: the part concerning the variables of <ce:italic>V</ce:italic> in state <ce:italic>i</ce:italic> (<ce:italic>V</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>), and the rest (rest<ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>). The projection simply takes the first part from each state and ignores the rest. The effect of this projection is similar to that of the "cone of influence" technique (<ce:cross-ref id="crf0360" refid="bib0050">Clarke et al., 1999</ce:cross-ref>). However, while this technique simplifies the code to include only variables which are on the set <ce:italic>V</ce:italic> (or which influence them) before executing it, we execute the program as is and then simplify (i.e. project) the generated trace. We do not automatically include variables not in <ce:italic>V</ce:italic>, though.</ce:para><ce:para id="p0410" view="all">As a general result of this definition of projection, if all the variables required for evaluating an LTL formula are present in the projection, the evaluation of the formula is not affected. Let <ce:italic>f</ce:italic> be an <ce:italic>LTL</ce:italic> formula and let us denote the set of variables in <ce:italic>f</ce:italic> as <ce:italic>var</ce:italic>(<ce:italic>f</ce:italic>).</ce:para><ce:para id="p0415" view="all"><ce:enunciation id="enun0015"><ce:label>Proposition 1</ce:label><ce:para id="p0420" view="all"><ce:italic>Given a Java trace t, a temporal formula f and a subset of program variables V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var<ce:italic>, if var</ce:italic>(<ce:italic>f</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>V then</ce:italic><ce:display><ce:formula id="eq0030"><ce:label>(6)</ce:label><mml:math altimg="si16.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0425" view="all">As described in Section <ce:cross-ref id="crf0365" refid="sec0030">3</ce:cross-ref>, temporal formulas can be used in debugging with different use cases. In contrast to model checking, testing works with a subset of program traces instead of every possible trace. Test cases may pass when a property is checked in all, some or none of the given traces. Thus we extend â¨ for sets of traces and the â and â quantifier operators.</ce:para><ce:para id="p0430" view="all"><ce:enunciation id="enun0020"><ce:label>Definition 2</ce:label><ce:para id="p0435" view="all">Given a temporal formula <ce:italic>f</ce:italic> and a set of traces <ce:italic>T</ce:italic>,<ce:display><ce:formula id="eq0035"><ce:label>(7)</ce:label><mml:math altimg="si17.gif" overflow="scroll"><mml:mi>T</mml:mi><mml:mo>â¨</mml:mo><mml:mo>â</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:mo>â</mml:mo><mml:mi>t</mml:mi><mml:mo>â</mml:mo><mml:mi>T</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi></mml:math></ce:formula></ce:display><ce:display><ce:formula id="eq0040"><ce:label>(8)</ce:label><mml:math altimg="si18.gif" overflow="scroll"><mml:mi>T</mml:mi><mml:mo>â¨</mml:mo><mml:mo>â</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:mo>â</mml:mo><mml:mi>t</mml:mi><mml:mo>â</mml:mo><mml:mi>T</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi></mml:math></ce:formula></ce:display><ce:display><ce:formula id="eq0045"><ce:label>(9)</ce:label><mml:math altimg="si19.gif" overflow="scroll"><mml:mi>T</mml:mi><mml:mo>â¨</mml:mo><mml:mo>â</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:mo>â</mml:mo><mml:mi>t</mml:mi><mml:mo>â</mml:mo><mml:mi>T</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para></ce:section><ce:section id="sec0065" view="all"><ce:label>4.2</ce:label><ce:section-title id="sect0075">Dealing with cycles</ce:section-title><ce:para id="p0440" view="all">Due to the elimination of most program variables in the projected states, it is very likely that a projected trace <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>V</ce:italic></ce:inf>(<ce:italic>t</ce:italic>) contains many consecutive repeated states. This represents a problem for the model checker since it can erroneously deduce that the original trace has a cycle due to the double depth search (DDS) algorithm used by Spin to check properties. Note that this does not contradict Proposition <ce:cross-ref id="crf0370" refid="enun0015">1</ce:cross-ref>, since in this result we do not assume any particular algorithm to evaluate the property on the projected trace. In the following sections, we use relation â¨<ce:inf loc="post"><ce:italic>s</ce:italic></ce:inf> to distinguish between the LTL evaluation carried out by Spin through the DDS algorithm, and the satisfaction relation â¨ defined above.</ce:para><ce:para id="p0445" view="all">To correctly eliminate consecutive repeated states in traces, we propose two different techniques that we discuss in the following subsections, along with the corresponding preservation results.</ce:para><ce:section id="sec0070" view="all"><ce:label>4.2.1</ce:label><ce:section-title id="sect0080">State counting</ce:section-title><ce:para id="p0450" view="all">A simple solution is to add a new counter variable <ce:italic>count</ce:italic> to the set of visible variables <ce:italic>V</ce:italic>. This counter is increased for every new state, thus removing the possibility that Spin erroneously finds a non-existing cycle. Observe that this also precludes Spin from detecting real cycles present in the Java program. This case will be discussed in the following subsection.</ce:para><ce:para id="p0455" view="all">We extend the notion of trace projection given in Definition <ce:cross-ref id="crf0375" refid="enun0010">1</ce:cross-ref>, by adding the state counter variable as follows:</ce:para><ce:para id="p0460" view="all"><ce:enunciation id="enun0025"><ce:label>Definition 3</ce:label><ce:para id="p0465" view="all">[Counter projection of states and traces] Given a subset of visible variables <ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var and a fresh variable count<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var, we define the <ce:italic>ith counter projection of a state</ce:italic> <mml:math altimg="si20.gif" overflow="scroll"><mml:mi>Ï</mml:mi><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>â</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math> as <mml:math altimg="si21.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>âª</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi mathvariant="normal">count</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>â</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math> defined as <mml:math altimg="si22.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>, for all <mml:math altimg="si23.gif" overflow="scroll"><mml:mi>v</mml:mi><mml:mo>â</mml:mo><mml:mi>V</mml:mi></mml:math>, and <mml:math altimg="si24.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">count</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:math>. Variable count is called state counter of <mml:math altimg="si25.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>. Sometimes, we will represent function <mml:math altimg="si26.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> as the pair ã<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>V</ce:italic></ce:inf>(<ce:italic>Ï</ce:italic>), <ce:italic>i</ce:italic>ã.</ce:para><ce:para id="p0470" view="all">Now, given a Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â¯ we define the <ce:italic>counter projection of t</ce:italic> onto <ce:italic>V</ce:italic>, <mml:math altimg="si27.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:math>, by projecting each state <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> with the <ce:italic>i</ce:italic>-th counter projection, that is, <mml:math altimg="si28.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mn>0</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â¯</mml:mo></mml:math>.</ce:para></ce:enunciation></ce:para><ce:para id="p0475" view="all">It is worth noting that there is a slight difference in the notation of the counter projection of a trace (<mml:math altimg="si29.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:math>) and the counter projection of a state (<mml:math altimg="si30.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:math>). Notice that the former includes a <ce:italic>c</ce:italic> superscript, while the latter includes the value of the counter itself as a superscript. <ce:cross-ref id="crf0380" refid="fig0055">Fig. 11</ce:cross-ref><ce:float-anchor refid="fig0055"/> shows the projection of a trace with the addition of the state counter.</ce:para></ce:section><ce:section id="sec0075" view="all"><ce:label>4.2.2</ce:label><ce:section-title id="sect0085">State hashing</ce:section-title><ce:para id="p0480" view="all">In this section, we assume that Java states have a canonical representation, which makes it possible to safely check whether two states are equal. We know that canonical representation of states in languages that make an intensive use of dynamic memory is not trivial. We are currently evaluating an extension of the memory representation described in (<ce:cross-ref id="crf0385" refid="bib0105">Gallardo et al., 2009</ce:cross-ref>). But a detailed explanation of this extension would exceed the goals of this paper. Besides, in this section, the actual representation is not relevant for the results obtained. We only need to assume that given two logically equal Java states <ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf> and <ce:italic>Ï</ce:italic><ce:inf loc="post">2</ce:inf>, there exists a <ce:italic>matching algorithm</ce:italic> able to check that they are equal.</ce:para><ce:para id="p0485" view="all">We use a proper hash function <ce:italic>h</ce:italic><ce:hsp sp="0.25"/>:<ce:hsp sp="0.25"/><ce:italic>State</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>int</ce:italic> to represent each state in the projected trace. It is worth noting that as not all of the Java states <ce:italic>Ï</ce:italic> have to be stored (we only project the visible part <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>V</ce:italic></ce:inf>(<ce:italic>Ï</ce:italic>)), we may assume that function <ce:italic>h</ce:italic> is very precise, producing a minimum number of collisions. That is, <ce:italic>h</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf>)<ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>h</ce:italic>(<ce:italic>Ï</ce:italic><ce:inf loc="post">2</ce:inf>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">2</ce:inf>, with a high degree of probability.</ce:para><ce:para id="p0490" view="all">To put this into perspective, we present a very brief study of the MD5 hash function, which we used in our implementation. This function transforms the given input (in this case a string representation of the Java state) into a 128-bit digest. Thus, there are 2<ce:sup loc="post">128</ce:sup> (or about 3.3<ce:hsp sp="0.25"/>Ã<ce:hsp sp="0.25"/>10<ce:sup loc="post">38</ce:sup>) possible values of this function. We are interested in the likelyhood of a <ce:italic>birthday attack</ce:italic> (<ce:cross-ref id="crf0390" refid="bib0180">Schneier, 1995</ce:cross-ref>), i.e. the probability of a collision between any two states belonging to the same trace or, conversely, in the number of different states that could be generated before a collision is found with a given probability. For instance, if we assume that a probability 10<ce:sup loc="post">-12</ce:sup> is enough for our analysis, this number is approximately 2.6<ce:hsp sp="0.25"/>Ã<ce:hsp sp="0.25"/>10<ce:sup loc="post">13</ce:sup>. Given a state size of 64 bytes (a reasonable assumption, see <ce:cross-ref id="crf0395" refid="tbl0010">Table 2</ce:cross-ref> in Section <ce:cross-ref id="crf0400" refid="sec0095">5</ce:cross-ref>), about 1.5<ce:hsp sp="0.25"/>Ã<ce:hsp sp="0.25"/>10<ce:sup loc="post">6</ce:sup> gigabytes of memory would be required to store this number of states. This is well beyond what current computers carry, and therefore computationally unfeasible. Thus, we conclude that such a hash function is adequate for our uses.</ce:para><ce:para id="p0495" view="all">Now, we extend the notion of state projection given in Definition <ce:cross-ref id="crf0405" refid="enun0010">1</ce:cross-ref>, by adding the codification of the whole state (including the non-visible part) as follows:</ce:para><ce:para id="p0500" view="all"><ce:enunciation id="enun0030"><ce:label>Definition 4</ce:label><ce:para id="p0505" view="all">[Hash projection] Given a subset of visible variables <ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var, and a fresh variable <ce:italic>hash</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var, we define the <ce:italic>hash projection</ce:italic> <mml:math altimg="si31.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> of a state <ce:italic>Ï</ce:italic> onto <ce:italic>V</ce:italic> using the hash function <ce:italic>h</ce:italic> as <mml:math altimg="si32.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>âª</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi mathvariant="italic">hash</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>â</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>âª</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:math> as follows. <mml:math altimg="si33.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>, for all <mml:math altimg="si34.gif" overflow="scroll"><mml:mi>v</mml:mi><mml:mo>â</mml:mo><mml:mi>V</mml:mi></mml:math>, and <mml:math altimg="si35.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">hash</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>. We usually represent function <mml:math altimg="si36.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> as pair ã<ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>V</ce:italic></ce:inf>(<ce:italic>Ï</ce:italic>), <ce:italic>h</ce:italic>(<ce:italic>Ï</ce:italic>)ã.</ce:para><ce:para id="p0510" view="all">Now, given a Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â¯ we define the <ce:italic>hash projection of t</ce:italic> onto <ce:italic>V</ce:italic>, <mml:math altimg="si37.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup></mml:math>, by projecting each state <ce:italic>Ï</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> with the hash projection, that is, <mml:math altimg="si38.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â¯</mml:mo></mml:math>.</ce:para></ce:enunciation></ce:para><ce:para id="p0515" view="all"><ce:cross-ref id="crf0410" refid="fig0060">Fig. 12</ce:cross-ref><ce:float-anchor refid="fig0060"/> shows the projection of a trace with the addition of the state hash. Only projected states <mml:math altimg="si39.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>Ï</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> are transferred to Spin. If the model checker detects that two states <mml:math altimg="si40.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math> and <mml:math altimg="si41.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math> are equal, then we can infer that the original states <ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf> and <ce:italic>Ï</ce:italic><ce:inf loc="post">2</ce:inf> are equal with a high degree of probability.</ce:para></ce:section><ce:section id="sec0080" view="all"><ce:label>4.2.3</ce:label><ce:section-title id="sect0090">Preservation of results</ce:section-title><ce:para id="p0520" view="all">We now discuss how the results are preserved regarding the satisfaction of temporal properties in Java and in the projected traces. Here we assume that the algorithm for checking the satisfaction of a property uses the double depth search algorithm as implemented by Spin. We focus on the preservation of results using the counter and hash projections as described in Definitions <ce:cross-ref id="crf0415" refid="enun0025">3</ce:cross-ref> and <ce:cross-ref id="crf0420" refid="enun0030">4</ce:cross-ref>, respectively, which were introduced to deal with cycles as required by the model checking algorithm implemented by Spin.</ce:para><ce:para id="p0525" view="all"><ce:enunciation id="enun0035"><ce:label>Proposition 2</ce:label><ce:para id="p0530" view="all"><ce:italic>Given a temporal formula f using only the eventually "</ce:italic>â<ce:italic>" and until "U" temporal operators, if V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>var</ce:italic>(<ce:italic>f</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var <ce:italic>then</ce:italic><ce:display><ce:formula id="eq0050"><ce:label>(10)</ce:label><mml:math altimg="si42.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0535" view="all">Counter projection <mml:math altimg="si43.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:math> does not permit Spin to detect cycles in the projected trace. Thus, properties that do not require the detection of cycles (i.e. those that use only operators <ce:italic>eventually</ce:italic> "â" and <ce:italic>until</ce:italic> "<ce:italic>U</ce:italic>") can be properly checked over this projection. In contrast, since properties that use the <ce:italic>always</ce:italic> "â¡" temporal operator are checked by Spin by searching for cycles, they cannot be analyzed over <mml:math altimg="si44.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>.</ce:para><ce:para id="p0540" view="all"><ce:enunciation id="enun0040"><ce:label>Proposition 3</ce:label><ce:para id="p0545" view="all"><ce:italic>Given a temporal formula f and a set of variables V, if V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>var</ce:italic>(<ce:italic>f</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var <ce:italic>then</ce:italic><ce:display><ce:formula id="eq0055"><ce:label>(11)</ce:label><mml:math altimg="si45.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi></mml:math></ce:formula></ce:display><ce:italic>with the degree of probability allowed by h, and</ce:italic><ce:display><ce:formula id="eq0060"><ce:label>(12)</ce:label><mml:math altimg="si46.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0550" view="all">This theorem asserts that any temporal formula which is satisfied in the original Java trace <ce:italic>t</ce:italic>, is also satisfied in the hash projection of the trace. The converse, while generally true for practical purposes, is limited by the quality of the hash function <ce:italic>h</ce:italic>. In addition to projecting the variables in <ce:italic>f</ce:italic>, as established in Proposition <ce:cross-ref id="crf0425" refid="enun0015">1</ce:cross-ref>, the hash projection includes a variable computed by <ce:italic>h</ce:italic> that identifies the global state and is used to detect cycles in the trace.</ce:para></ce:section></ce:section><ce:section id="sec0085" view="all"><ce:label>4.3</ce:label><ce:section-title id="sect0095">Folding consecutive repeated states</ce:section-title><ce:para id="p0555" view="all">In this section we propose an optimization approach to minimize the number of states of the projected trace that need to be generated and transferred to Spin. To do this, we slightly modify transition relation â defined above by labeling transitions as follows. A Java trace is now given by a sequence of states</ce:para><ce:para id="p0560" view="all"><ce:display><ce:formula id="eq0065"><ce:label>(13)</ce:label><mml:math altimg="si47.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:msub><mml:mi>Ï</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:msub><mml:mi>Ï</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>â</mml:mo><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>â¦</mml:mo></mml:math></ce:formula></ce:display>where each label <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var is the set of variables which are modified by the Java sentence that produced the transition.</ce:para><ce:para id="p0565" view="all">Recall that counter and hash projections of Java traces <ce:italic>t</ce:italic> (<mml:math altimg="si48.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> and <mml:math altimg="si49.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>) discard all program variables except the ones in <ce:italic>V</ce:italic>, which are the only ones needed to check a temporal formula <ce:italic>f</ce:italic>, (<ce:italic>V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>var</ce:italic>(<ce:italic>f</ce:italic>)), while the rest of the state is collapsed into a single variable. However, Spin does not need to know about states in which none of the variables in <ce:italic>V</ce:italic> change as they do not affect the evaluation of temporal formulas as described in Propositions <ce:cross-ref id="crf0430" refid="enun0035">2</ce:cross-ref> and <ce:cross-ref id="crf0435" refid="enun0040">3</ce:cross-ref>. Thus, we propose removing these states from the final projection given to Spin. We call this removed states <ce:italic>folded states</ce:italic>.</ce:para><ce:para id="p0570" view="all"><ce:enunciation id="enun0045"><ce:label>Definition 5</ce:label><ce:para id="p0575" view="all">[Folded projection] Given a Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>M</ce:italic><ce:inf loc="post">1</ce:inf><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>M</ce:italic><ce:inf loc="post">2</ce:inf><ce:hsp sp="0.25"/>â¯ as defined in <ce:cross-ref id="crf0440" refid="eq0065">(13)</ce:cross-ref>, we define the folded counter/hash projection of <ce:italic>t</ce:italic> onto <ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var as<ce:display><ce:formula id="eq0070"><ce:label>(14)</ce:label><mml:math altimg="si50.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mn>0</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:mo>â¦</mml:mo></mml:math></ce:formula></ce:display>and<ce:display><ce:formula id="eq0075"><ce:label>(15)</ce:label><mml:math altimg="si51.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:mo>â¦</mml:mo></mml:math></ce:formula></ce:display>such that:<ce:list id="list0010"><ce:list-item id="listitem0040"><ce:label>1</ce:label><ce:para id="p0580" view="all">index <ce:italic>i</ce:italic><ce:inf loc="post">0</ce:inf><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>0,</ce:para></ce:list-item><ce:list-item id="listitem0045"><ce:label>2</ce:label><ce:para id="p0585" view="all">for all <ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>0, <ce:italic>i</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>&lt;<ce:hsp sp="0.25"/><ce:italic>i</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic>+1</ce:inf></ce:para></ce:list-item><ce:list-item id="listitem0050"><ce:label>3</ce:label><ce:para id="p0590" view="all">for all <ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>1, <mml:math altimg="si52.gif" overflow="scroll"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>â©</mml:mo><mml:mi>V</mml:mi><mml:mo>â </mml:mo><mml:mo>â</mml:mo><mml:mo>.</mml:mo></mml:math></ce:para></ce:list-item><ce:list-item id="listitem0055"><ce:label>4</ce:label><ce:para id="p0595" view="all">if there exists <ce:italic>j</ce:italic><ce:hsp sp="0.25"/>&gt;<ce:hsp sp="0.25"/>0 such that â<ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>0, <ce:italic>i</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>â <ce:hsp sp="0.25"/><ce:italic>j</ce:italic>, then <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>â©<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>â</ce:para></ce:list-item></ce:list></ce:para></ce:enunciation></ce:para><ce:para id="p0600" view="all">That is, we only project to Spin those states where some visible variable has just been modified.</ce:para><ce:para id="p0605" view="all">However, this definition of folding is not enough to allow a precise cycle detection, which was the main reason for introducing the hash projection. If an infinite cycle is located in the folded states, Spin will not be informed of any new Java state, and thus Spin will not be aware that the Java program is going to loop endlessly in those states.</ce:para><ce:para id="p0610" view="all">To avoid this, we define the <ce:italic>limited</ce:italic> folding of a hash projection, where the word <ce:italic>limited</ce:italic> means that the folding between two non-folded states is never greater than a given limit. After a specified number of folded Java states, we project the next Java state, even that state did not change any of the variables <mml:math altimg="si53.gif" overflow="scroll"><mml:mi>v</mml:mi><mml:mo>â</mml:mo><mml:mi>V</mml:mi></mml:math>.</ce:para><ce:para id="p0615" view="all">An implementation may choose to use a timer as a limit instead of a state counter, which may be more practical and would not affect the results given below. This projection may be further refined in the implementation with an adaptive limit, e.g. a limit which decreases progressively.</ce:para><ce:para id="p0620" view="all"><ce:enunciation id="enun0050"><ce:label>Definition 6</ce:label><ce:para id="p0625" view="all">[Limited folded hash projection] Given a Java trace <ce:italic>t</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>Ï</ce:italic><ce:inf loc="post">0</ce:inf>â<ce:hsp sp="0.25"/><ce:italic>M</ce:italic><ce:inf loc="post">1</ce:inf><ce:italic>Ï</ce:italic><ce:inf loc="post">1</ce:inf><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>M</ce:italic><ce:inf loc="post">2</ce:inf><ce:hsp sp="0.25"/>â¯ as defined in <ce:cross-ref id="crf0445" refid="eq0065">(13)</ce:cross-ref> and a limit <ce:italic>l</ce:italic><ce:hsp sp="0.25"/>&gt;<ce:hsp sp="0.25"/>0, we define the <ce:italic>limited folded hash projection of t onto V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var as<ce:display><ce:formula id="eq0080"><ce:label>(16)</ce:label><mml:math altimg="si54.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>â</mml:mo><mml:mo>â¦</mml:mo></mml:math></ce:formula></ce:display>such that:<ce:list id="list0015"><ce:list-item id="listitem0060"><ce:label>1</ce:label><ce:para id="p0630" view="all">index <ce:italic>j</ce:italic><ce:inf loc="post">0</ce:inf><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>0,</ce:para></ce:list-item><ce:list-item id="listitem0065"><ce:label>2</ce:label><ce:para id="p0635" view="all">for all <ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>0, <ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>&lt;<ce:hsp sp="0.25"/><ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic>+1</ce:inf>, and</ce:para></ce:list-item><ce:list-item id="listitem0070"><ce:label>3</ce:label><ce:para id="p0640" view="all">for all <ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>1, either <mml:math altimg="si55.gif" overflow="scroll"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>â©</mml:mo><mml:mi>V</mml:mi><mml:mo>â </mml:mo><mml:mo>â</mml:mo></mml:math>, or, the distance between <ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf> and <ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic>-1</ce:inf> is limit <ce:italic>l</ce:italic>, that is <ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>-<ce:hsp sp="0.25"/><ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic>-1</ce:inf><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/><ce:italic>l</ce:italic>,</ce:para></ce:list-item><ce:list-item id="listitem0075"><ce:label>4</ce:label><ce:para id="p0645" view="all">if there exists <ce:italic>j</ce:italic><ce:hsp sp="0.25"/>&gt;<ce:hsp sp="0.25"/>0 such that â<ce:italic>k</ce:italic><ce:hsp sp="0.25"/>â¥<ce:hsp sp="0.25"/>0, <ce:italic>j</ce:italic><ce:inf loc="post"><ce:italic>k</ce:italic></ce:inf><ce:hsp sp="0.25"/>â <ce:hsp sp="0.25"/><ce:italic>j</ce:italic>, then <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>j</ce:italic></ce:inf>â©<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>â.</ce:para></ce:list-item></ce:list></ce:para></ce:enunciation></ce:para><ce:para id="p0650" view="all">Although we could define a limited folded counter projection in a similar fashion, there would be no benefit in doing so, since the counter prevents any kind of cycle from being detected.</ce:para><ce:para id="p0655" view="all"><ce:cross-ref id="crf0450" refid="fig0065">Fig. 13</ce:cross-ref><ce:float-anchor refid="fig0065"/> shows an example of a limited folded hash projection, with limit <ce:italic>l</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>1. This limit ensures that only one state can be folded consecutively. In the figure, a bold <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf> label indicates that <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>â©<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â <ce:hsp sp="0.25"/>â, i.e. that transition modifies one or more variables of the set <ce:italic>V</ce:italic>. In this example, the limit forces the projection of states <ce:italic>Ï</ce:italic><ce:inf loc="post">4</ce:inf> and <ce:italic>Ï</ce:italic><ce:inf loc="post">6</ce:inf>, which should have been folded, resulting in the projected states <mml:math altimg="si56.gif" overflow="scroll"><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:math> and <mml:math altimg="si57.gif" overflow="scroll"><mml:msub><mml:mi>Ï</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:msub></mml:math>.</ce:para><ce:section id="sec0090" view="all"><ce:label>4.3.1</ce:label><ce:section-title id="sect0100">Preservation of results</ce:section-title><ce:para id="p0660" view="all">We now show how the results are preserved with these projections.</ce:para><ce:para id="p0665" view="all"><ce:enunciation id="enun0055"><ce:label>Proposition 4</ce:label><ce:para id="p0670" view="all"><ce:italic>Given a temporal formula f using the eventually "</ce:italic>â<ce:italic>" and until "U" temporal operators, and a set of variables V, if var</ce:italic>(<ce:italic>f</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var <ce:italic>then</ce:italic><ce:display><ce:formula id="eq0085"><ce:label>(17)</ce:label><mml:math altimg="si58.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mspace width="1em"/><mml:mo>â</mml:mo><mml:mspace width="1em"/><mml:msubsup><mml:mi>Ï</mml:mi><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0675" view="all">This result is not affected by the folding in the projection, because (i) the folded states are not required to evaluate the boolean tests of the temporal formula, and (ii) cycle detection is not affected since it is not supported by the counter projection, as discussed in Section <ce:cross-ref id="crf0455" refid="sec0080">4.2.3</ce:cross-ref>.</ce:para><ce:para id="p0680" view="all"><ce:enunciation id="enun0060"><ce:label>Proposition 5</ce:label><ce:para id="p0685" view="all"><ce:italic>Given a temporal formula f and a set of variables V, if var</ce:italic>(<ce:italic>f</ce:italic>)<ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>â<ce:hsp sp="0.25"/>Var <ce:italic>then</ce:italic><ce:display><ce:formula id="eq0090"><ce:label>(18)</ce:label><mml:math altimg="si59.gif" overflow="scroll"><mml:msubsup><mml:mi>Ï</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mspace width="1em"/><mml:mo>â</mml:mo><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi></mml:math></ce:formula></ce:display><ce:italic>with the degree of probability allowed by h, and</ce:italic><ce:display><ce:formula id="eq0095"><ce:label>(19)</ce:label><mml:math altimg="si60.gif" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>â¨</mml:mo><mml:mi>f</mml:mi><mml:mspace width="1em"/><mml:mo>â</mml:mo><mml:mspace width="1em"/><mml:msubsup><mml:mi>Ï</mml:mi><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>â¨</mml:mo><mml:mi>s</mml:mi></mml:msub><mml:mi>f</mml:mi><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display></ce:para></ce:enunciation></ce:para><ce:para id="p0690" view="all">Again, this result is not affected by the folding in the projection thanks to the limit, which covers the detection of cycles in (otherwise) folded states. If there is a cycle in an infinite sequence of states the transition labels of which are <ce:italic>M</ce:italic><ce:inf loc="post"><ce:italic>i</ce:italic></ce:inf>â©<ce:hsp sp="0.25"/><ce:italic>V</ce:italic><ce:hsp sp="0.25"/>=<ce:hsp sp="0.25"/>â, the limited folding only removes a subset of the states. Since a cycle is by definition a finite sequence of states, it is guaranteed that eventually two equal states will be projected, and thus the cycle will be detected.</ce:para></ce:section></ce:section></ce:section><ce:section id="sec0095" view="all"><ce:label>5</ce:label><ce:section-title id="sect0105">Experimental results</ce:section-title><ce:para id="p0695" view="all">TJT has been successfully used with real Java applications. In this section, we show some example properties evaluated on public open source Java projects, some of which were also evaluated in (<ce:cross-ref id="crf0460" refid="bib0095">Fu et al., 2005</ce:cross-ref>). These applications include three servers: FTP, NFS and HTTP. It is worth noting that, in order to test these servers, we had to implement mock clients to simulate the behavior required by each test. In addition, we studied the elevator problem, a typical example of control software. The temporal formulas used in each test have been gathered together in Table <ce:cross-ref id="crf0465" refid="tbl0005">1</ce:cross-ref><ce:float-anchor refid="tbl0005"/>. Note that all formulas, with the exception of <ce:monospace>F4</ce:monospace> and <ce:monospace>F6</ce:monospace>, represent liveness properties, and, in the case of programs with infinite executions, they can only be analyzed with runtime checkers that implement mechanisms like the cycle detection considered in this paper (see <ce:cross-ref id="crf0470" refid="bib0195">Vardi and Wolper (1986)</ce:cross-ref>).</ce:para><ce:para id="p0700" view="all"><ce:italic>FTPD server (http://peter.sorotokin.com/ftpd).</ce:italic> The first application is the FTP server described in Section <ce:cross-ref id="crf0475" refid="sec0015">2.1</ce:cross-ref>. We tested the three formulas from Section <ce:cross-ref id="crf0480" refid="sec0015">2.1</ce:cross-ref>, shown in Table <ce:cross-ref id="crf0485" refid="tbl0005">1</ce:cross-ref> as formulas <ce:monospace>F1</ce:monospace>, <ce:monospace>F2</ce:monospace> and <ce:monospace>F3</ce:monospace>, and two additional ones. Of all these formulas, <ce:monospace>F2</ce:monospace> was prepared to uncover a manually introduced bug, while the rest were analyzed over the normal server. <ce:monospace>F4</ce:monospace> deals with security in the server, checking that no user is able to perform a <ce:monospace>STOR</ce:monospace> operation without being authenticated first. Finally, formula <ce:monospace>F5</ce:monospace> is a twist on <ce:monospace>F1</ce:monospace>, but using the temporal operator "until". Using this formula we check that, at some point, the variable <ce:monospace>incoming</ce:monospace>, which holds the socket just opened for attending the client, should be non-null until a specific thread is created for attending that client.</ce:para><ce:para id="p0705" view="all"><ce:italic>Elevator problem.</ce:italic> The next application is a typical example of concurrency: a shared resource (an elevator) and several clients trying to use it at the same time. This example has been implemented in Java using locks and conditions. <ce:cross-ref id="crf0490" refid="fig0070">Figs. 14</ce:cross-ref><ce:float-anchor refid="fig0070"/> and <ce:cross-ref id="crf0495" refid="fig0075">15</ce:cross-ref><ce:float-anchor refid="fig0075"/> show part of the elevator and client code, respectively. We can use a temporal formula to check that the elevator does not wait for clients if it is not free (<ce:monospace>F6</ce:monospace>). For the sake of illustration, we tested this formula to debug an incorrect implementation, where the wait condition of the server is wrong (line 3 in Fig. <ce:cross-ref id="crf0500" refid="fig0070">14</ce:cross-ref>). We also used this incorrect implementation to test the opposite condition (<ce:monospace>F7</ce:monospace>). In both cases, the generated traces led us to this manually introduced error.</ce:para><ce:para id="p0710" view="all"><ce:italic>NFS server (http://www.void.org/ steven/jnfs/).</ce:italic> We have also debugged an NFS server implemented in Java using a client that tries to mount a directory provided by the server. We can test some conditions related to an incorrect or unauthorized request, by checking whether some internal error fields are updated (<ce:monospace>F8</ce:monospace>) or specific exceptions are thrown (<ce:monospace>F9</ce:monospace>, <ce:monospace>F10</ce:monospace>).</ce:para><ce:para id="p0715" view="all"><ce:italic>Jibble Web Server (http://www.jibble.org/jibblewebserver.php).</ce:italic> Finally, we also studied a Java web server that manages HTTP requests. One possible condition to check would be that the server throws the right exception if it is launched from an incorrect root directory (<ce:monospace>F11</ce:monospace>). In addition, we can test whether the server fails to start on any port from a given range, which can be specified as a test input parameter. All executions should thus avoid the location of the exception that would be thrown in this case (<ce:monospace>F12</ce:monospace>).</ce:para><ce:section id="sec0100" view="all"><ce:label>5.1</ce:label><ce:section-title id="sect0110">Counter projection</ce:section-title><ce:para id="p0720" view="all">We performed some the aforementioned tests using the folded counter projection. It is worth noting that not all of the proposed tests can be carried out using this projection. Formulas that would require cycle detection cannot be checked, as per Proposition <ce:cross-ref id="crf0505" refid="enun0035">2</ce:cross-ref>. However, formulas where the cycle that Spin's stuttering mechanism creates using the last state is enough for detecting every accepting cycle in the never claim automata generated from the formula. Most of the programs we are debugging are infinite, i.e. they are servers with an infinite reactive loop, and this cannot be checked with finite resources and this projection. We modified these programs to produce finite versions that could de checked with both projections, for the purpose of comparison.</ce:para><ce:para id="p0725" view="all">The results are summarized on the left hand side of <ce:cross-ref id="crf0510" refid="tbl0010">Table 2</ce:cross-ref><ce:float-anchor refid="tbl0010"/>, averaged over a series of test executions. The third column shows the number of projected Java states, while the fourth column indicates the number of state transitions in Spin. The next two columns show the size of a Spin state and the total time of analysis. The last column of the table shows an approximation of the size of the Java states, before any projection. This number only takes into account the size of objects allocated in the heap. Since the size of the heap changes dynamically, we report the maximum value the we observed during the execution of each program.</ce:para><ce:para id="p0730" view="all">The size of states in Spin after the projection is influenced by several factors. First, Spin has an overhead of 16<ce:hsp sp="0.25"/>B for a Promela specification with a single process, and a BÃ¼chi automata adds another 8<ce:hsp sp="0.25"/>B. Then, a <ce:monospace>step</ce:monospace> integer variable is added to track the Java state that is retrieved in each state (see Section <ce:cross-ref id="crf0515" refid="sec0050">3.1.3</ce:cross-ref>). The variables used for generating test inputs, if any, are added to the global state as well. Furthermore, the counter projection requires an additional variable as described in Section <ce:cross-ref id="crf0520" refid="sec0070">4.2.1</ce:cross-ref>. It is worth noting that the variables being monitored are not part of the global state, but are kept in a separate data structure, in order to support backtracking with minimal impact in the size of Spin states.</ce:para><ce:para id="p0735" view="all">TJT also has a deadlock detection algorithm. Although the purpose of formula <ce:monospace>F7</ce:monospace> was to detect the incorrect wait condition, it uncovered a deadlock in each execution of the program detected by the monitoring module. Although deadlocks may be detected while using any property, omitting the temporal formula is recommended when specifically searching for them in order to prevent the trace being terminated early due to a specified property.</ce:para></ce:section><ce:section id="sec0105" view="all"><ce:label>5.2</ce:label><ce:section-title id="sect0115">Hash projection</ce:section-title><ce:para id="p0740" view="all">We also evaluated the hash projection, using all the properties described above. Thanks to its cycle detection capabilities, we could use it for more tests than the counter projection. The right hand side of Table <ce:cross-ref id="crf0525" refid="tbl0010">2</ce:cross-ref> shows these results. The table shows that, compared with the counter projection, the hash projection is generally slower, due to the computation penalty associated with visiting the whole Java program state and computing its hash. As these results suggest the tests with more Java states are the ones where the test time increases the most. Also, the difference between the size of Spin states between the counter and the hash projections is constant: the hash projection adds a variable to store the hash of each state, but removes the counter variable. Although the size of the hash proper is 16<ce:hsp sp="0.25"/>B, in our implementation it is stored as a 32<ce:hsp sp="0.25"/>B character array, which explains the total difference of 28<ce:hsp sp="0.25"/>B.</ce:para><ce:para id="p0745" view="all">Furthermore, we included some additional tests that required true cycle detection, which is only possible under the hash projection. First, we tested Formula <ce:cross-ref id="crf0530" refid="eq0015">3</ce:cross-ref> from Section <ce:cross-ref id="crf0535" refid="sec0015">2.1</ce:cross-ref> (<ce:monospace>F3</ce:monospace>) on the FTP server. In addition, we also tested a simple Java program that deals with lists in an infinite loop. The program adds elements to the list and then removes them, and we checked that the list ended up with exactly one element an infinite number of times (<ce:monospace>F13</ce:monospace>).</ce:para><ce:para id="p0750" view="all">To end our experiments, we performed a small comparison between TJT and the LTL extension for JPF, using the hash projection. Although both tools are based on model checking and can test LTL properties, their scopes are different. JPF performs an exhaustive search over the complete space state of the program, while TJT analyzes a range of execution traces. We compared both tools with some examples available with JPF-LTL, summarizing the results in Table <ce:cross-ref id="crf0540" refid="tbl0015">3</ce:cross-ref><ce:float-anchor refid="tbl0015"/>. In this table, the first two columns show the name of the example and the formula being analyzed, "Transitions" are the number of state transitions traversed, and "Time" the total time required to check the formula against the program.</ce:para><ce:para id="p0755" view="all">It is worth noting the disparity in time and space required for the analysis of the second formula with TJT, compared to the other two. This program deals with random number generators, and the property requires cycle detection. Although checking whether or not a single trace violates the property is relatively quick, the first few traces generated and analyzed by TJT did not violate the property. Thus, when a violating trace was generated, the cost of the analysis had accumulated the analysis of the previous traces.</ce:para></ce:section></ce:section><ce:section id="sec0110" view="all"><ce:label>6</ce:label><ce:section-title id="sect0120">Comparison with related work</ce:section-title><ce:para id="p0760" view="all">The most notable tools for analyzing Java programs using some variant of full-state model checking are Bandera (<ce:cross-ref id="crf0545" refid="bib0060">Corbett et al., 2000</ce:cross-ref>) and Java PathFinder (<ce:cross-ref id="crf0550" refid="bib0200">Visser et al., 2003</ce:cross-ref>). Bandera is a model extraction based tool that requires the Java program to be transformed into a model composed by pure Promela plus embedded C code. This model is optimized by applying a data abstraction mechanism that provides an approximation of the execution traces. As Bandera uses Spin as the model checker, it can check LTL on infinite traces and preserve correction results according to the approximation of the traces. Compared with Bandera, TJT only checks a set of traces. However the use of runtime monitoring to avoid model transformation, and the two abstraction methods guarantee the correctness of the results.</ce:para><ce:para id="p0765" view="all">Java PathFinder (<ce:cross-ref id="crf0555" refid="bib0120">Havelund and Pressburger, 2000</ce:cross-ref>) (JPF) is a complete model checker for Java programs that performs a complete coverage of a program, while our testing tool does a partial analysis of the program. In addition, thanks to a matching mechanism, JPF does not revisit the same execution path twice, while TJT analyzes each trace in isolation without checking whether several traces share already visited states. However due to our integration approach, we can still gain some advantages from reusing the well known model checker Spin, instead of building a new one from scratch. Some realistic Java examples of reactive software are not suitable for verification by JPF. For instance, we tried analyzing our elevator problem with JPF, but it ran out of memory after 58 minutes. The verification of LTL with JPF-LTL in JPF is still under development and has a limited visibility of the program elements for writing the formula. At the time of writing, JPF-LTL only considers entry to methods in the propositions, and it requires the user to explicitly declare whether the formula should be evaluated for infinite or finite traces. TJT allows a richer set of propositions to be used in the formulas and, due to the stuttering semantics used by Spin, the user does not need to declare whether the trace is finite or not.</ce:para><ce:para id="p0770" view="all">The specification of LTL properties to analyze programming languages at runtime has been proposed by other authors, which we discuss in the rest of this section. Probably, the most complete overview of the approaches can be found in a paper by Bauer et. al (<ce:cross-ref id="crf0560" refid="bib0030">Bauer et al., 2011</ce:cross-ref>). Bauer et. al consider the runtime verification of LTL and tLTL (timed LTL) with a three-valued semantics (with truth values true, false, inconclusive) suitable to check whether or not a partial observation of a running system meets a property. They generate deterministic monitors to decide the satisfaction (or not satisfaction) of a property as early as possible. They use these three-values as a way to adapt the semantics of LTL to the evaluation of finite traces. The authors write that "the set of monitorable properties does not only encompass the safety and cosafety properties but is strictly larger". However, the general case of liveness properties for infinite traces is not considered. Compared with our work, they develop the foundations to create monitors to support the new semantics of LTL for infinite traces, while our work relies on the already existing algorithms and tools to check BÃ¼chi automata for infinite traces.</ce:para><ce:para id="p0775" view="all">Java PathExplorer, developed by Havelund and RoÅu (<ce:cross-ref id="crf0565" refid="bib0125">Havelund and RoÅu, 2004</ce:cross-ref>), uses the rewriting-logic based model checker Maude to check LTL on finite execution traces of Java programs. The authors provide different semantics for LTL formulas in order to avoid cycle detection. Java PathExplorer also supports the generation of a variant of BÃ¼chi automata for finite traces developed by Giannakopoulou and Havelund (<ce:cross-ref id="crf0570" refid="bib0110">Giannakopoulou and Havelund, 2001</ce:cross-ref>). We share with Java PathExplorer the idea of using the model checker to process the stream of states produced by Java. However, our use of Spin allows us to check infinite execution traces.</ce:para><ce:para id="p0780" view="all">The tool Temporal Rover (<ce:cross-ref id="crf0575" refid="bib0085">Drusinsky, 2000</ce:cross-ref>) can check temporal logic assertions against reactive systems (with non-terminating loops) at runtime. The author considers that both finite and infinite traces are possible. However, only finite traces are evaluated, and a default <ce:italic>fail</ce:italic> value is returned for formulas like â<ce:italic>p</ce:italic> when <ce:italic>p</ce:italic> has not been satisfied at the end of the trace and there is no evidence that the program has terminated. TJT can provide a conclusive verdict when inspecting the infinite trace.</ce:para><ce:para id="p0785" view="all">Bodden (<ce:cross-ref id="crf0580" refid="bib0045">Bodden, 2004</ce:cross-ref>) uses AspectJ to implement a method to evaluate LTL, inserting pieces of Java code to be executed at points where the behavior specified by the formula is relevant and must be evaluated. This method is useful to check only safety properties. d'Amorim and Havelund (<ce:cross-ref id="crf0585" refid="bib0070">d'Amorim and Havelund, 2005</ce:cross-ref>) have developed the tool HAWK for the runtime verification of Java programs, which allows the definition of temporal properties with the logic EAGLE. In addition, the user must supply a method that must be called when the program terminates in order to produce a finite trace. FiLM (Finite LTL runtime Monitor) (<ce:cross-ref id="crf0590" refid="bib0210">Zhang et al., 2009</ce:cross-ref>) also gives a specific semantics to LTL to check both safety and liveness in finite traces. However, in the case of liveness, manual inspection is required when the tool reports a potential liveness violation. All these tools for runtime monitoring of LTL are focused on finite traces. The main difference with TJT is the support of cycle detection due to the way in which the states are abstracted and stored, and the use of BÃ¼chi automata.</ce:para><ce:para id="p0790" view="all">Note that we have not included further experimental comparison of TJT with some of these runtime monitoring tools due to the lack of comparable public examples, or of the tools themselves.</ce:para></ce:section><ce:section id="sec0115" view="all"><ce:label>7</ce:label><ce:section-title id="sect0125">Conclusions and future work</ce:section-title><ce:para id="p0795" view="all">We have presented the foundations of TJT, a tool for checking temporal logic properties on Java programs. This tool is useful for testing functional properties on both sequential and concurrent programs. In particular, we explained how the use of BÃ¼chi automata combined with storing the states from runtime monitoring can be used to check liveness properties in non-terminating executions of reactive programs.</ce:para><ce:para id="p0800" view="all">Our tool chain includes the model checker Spin and JDI, which are integrated in the well known development environment Eclipse. The use of JDI instead of instrumented code makes it possible to detect deadlocks and provides wider access to events in the execution of the program, while being completely transparent.</ce:para><ce:para id="p0805" view="all">Our current work follows several paths. One is to apply static influence analysis to automatically select the variables relevant to the given property, as we proposed in (<ce:cross-ref id="crf0595" refid="bib0075">de la CÃ¡mara et al., 2006</ce:cross-ref>). The second one is to implement methods to produce more schedulling in multithreaded programs for the same initial state. Finally, we plan to take advantage of multicore architectures to speed up the analysis, due to the already decoupled interaction between Spin and JDI modules.</ce:para></ce:section></ce:sections><ce:acknowledgment id="ack0005" view="all"><ce:section-title id="sect0130">Acknowledgements</ce:section-title><ce:para id="p0810" view="all">Work partially supported by projects P11-TIC-07659 (Regional Government of Andalusia), TIN2012-35669 (Spanish Ministry of Economy and Competitiveness) and UMA-806/47.3154-1 (AT4Wireless). We thank Franco Raimondi and Michelle Lombardi fortheir help regarding JPF-LTL.</ce:para></ce:acknowledgment></body><tail view="all"><ce:bibliography id="bibl0005" view="all"><ce:section-title id="sect0135">References</ce:section-title><ce:bibliography-sec id="bibs0005" view="all"><ce:bib-reference id="bib0005"><ce:label>Adalid et al., 2012</ce:label><sb:reference id="sbref0005"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Adalid</ce:surname></sb:author><sb:author><ce:given-name>A.</ce:given-name><ce:surname>SalmerÃ³n</ce:surname></sb:author><sb:author><ce:given-name>M.d.M.</ce:given-name><ce:surname>Gallardo</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Merino</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Testing temporal logic on infinite Java traces</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>MSVVEIS 2012</sb:maintitle></sb:title><sb:date>2012</sb:date></sb:edited-book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0010"><ce:label>Adalid et al., xxxx</ce:label><ce:other-ref id="oref0010"><ce:textref>Adalid, D., SalmerÃ³n, A., Gallardo, M.d.M., Merino, P. TJT: Temporal Java Testing. (http://www.lcc.uma.es/salmeron/tjt/).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0015"><ce:label>Alipour, 2012</ce:label><sb:reference id="sbref0015"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.A.</ce:given-name><ce:surname>Alipour</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model Checking and Delta Debugging for Automated Fault Localization; A Tutorial. Technical Report</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>2012</sb:date></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0020"><ce:label>Artho et al., 2003</ce:label><sb:reference id="sbref0020"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Artho</ce:surname></sb:author><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Drusinksy</ce:surname></sb:author><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Goldberg</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Lowry</ce:surname></sb:author><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Pasareanu</ce:surname></sb:author><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Rosu</ce:surname></sb:author><sb:author><ce:given-name>W.</ce:given-name><ce:surname>Visser</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Experiments with test case generation and runtime analysis.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Proceedings of the Abstract State Machines 10th International Conference on Advances in Theory and Practice</sb:maintitle></sb:title><sb:conference>ASM'03, Berlin, Heidelberg, Springer-Verlag</sb:conference><sb:date>2003</sb:date></sb:edited-book><sb:pages><sb:first-page>87</sb:first-page><sb:last-page>108</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0025"><ce:label>Baiardi et al., 1986</ce:label><sb:reference id="sbref0025"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>F.</ce:given-name><ce:surname>Baiardi</ce:surname></sb:author><sb:author><ce:given-name>N.</ce:given-name><ce:surname>De Francesco</ce:surname></sb:author><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Vaglini</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Development of a debugger for a concurrent language.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on SE-12, Software Engineering</sb:maintitle></sb:title></sb:series><sb:date>1986</sb:date></sb:issue><sb:pages><sb:first-page>547</sb:first-page><sb:last-page>553</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0030"><ce:label>Bauer et al., 2011</ce:label><sb:reference id="sbref0030"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Bauer</ce:surname></sb:author><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Leucker</ce:surname></sb:author><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Schallhart</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Runtime verification for LTL and TLTL</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>ACM Transactions on Software Engineering and Methodology</sb:maintitle></sb:title><sb:volume-nr>20</sb:volume-nr></sb:series><sb:date>2011</sb:date></sb:issue></sb:host><sb:comment>14:1-14:64</sb:comment></sb:reference></ce:bib-reference><ce:bib-reference id="bib0035"><ce:label>Beust and Suleiman, 2007</ce:label><sb:reference id="sbref0035"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Beust</ce:surname></sb:author><sb:author><ce:given-name>H.</ce:given-name><ce:surname>Suleiman</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Java Testing. TestNG and Advanced Concepts</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>2007</sb:date><sb:publisher><sb:name>Addison-Wesley</sb:name><sb:location>Boston, MA</sb:location></sb:publisher></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0040"><ce:label>Beyer et al., 2007</ce:label><sb:reference id="sbref0040"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Beyer</ce:surname></sb:author><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Henzinger</ce:surname></sb:author><sb:author><ce:given-name>R.</ce:given-name><ce:surname>Jhala</ce:surname></sb:author><sb:author><ce:given-name>R.</ce:given-name><ce:surname>Majumdar</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>The software model checker BLAST</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>International Journal on Software Tools for Technology Transfer (STTT)</sb:maintitle></sb:title><sb:volume-nr>9</sb:volume-nr></sb:series><sb:date>2007</sb:date></sb:issue><sb:pages><sb:first-page>505</sb:first-page><sb:last-page>525</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0045"><ce:label>Bodden, 2004</ce:label><sb:reference id="sbref0045"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>E.</ce:given-name><ce:surname>Bodden</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A lightweight LTL runtime verification tool for java.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications</sb:maintitle></sb:title><sb:conference>OOPSLA'04, New York, NY, USA, ACM</sb:conference><sb:date>2004</sb:date></sb:edited-book><sb:pages><sb:first-page>306</sb:first-page><sb:last-page>307</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0050"><ce:label>Clarke et al., 1999</ce:label><sb:reference id="sbref0050"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>J.E.M.</ce:given-name><ce:surname>Clarke</ce:surname></sb:author><sb:author><ce:given-name>O.</ce:given-name><ce:surname>Grumberg</ce:surname></sb:author><sb:author><ce:given-name>D.A.</ce:given-name><ce:surname>Peled</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model Checking.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>1999</sb:date><sb:publisher><sb:name>MIT Press</sb:name><sb:location>Cambridge, MA, USA</sb:location></sb:publisher></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0055"><ce:label>Clarke et al., 2009</ce:label><sb:reference id="sbref0055"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>E.M.</ce:given-name><ce:surname>Clarke</ce:surname></sb:author><sb:author><ce:given-name>E.A.</ce:given-name><ce:surname>Emerson</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Sifakis</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model checking: algorithmic verification and debugging</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Communications of the ACM</sb:maintitle></sb:title><sb:volume-nr>52</sb:volume-nr></sb:series><sb:date>2009</sb:date></sb:issue><sb:pages><sb:first-page>74</sb:first-page><sb:last-page>84</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0060"><ce:label>Corbett et al., 2000</ce:label><sb:reference id="sbref0060"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Corbett</ce:surname></sb:author><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Dwyer</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Hatcliff</ce:surname></sb:author><sb:author><ce:given-name>S.</ce:given-name><ce:surname>Laubach</ce:surname></sb:author><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Pasareanu</ce:surname></sb:author><sb:author><ce:surname>Robby</ce:surname></sb:author><sb:author><ce:given-name>H.</ce:given-name><ce:surname>Zheng</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Bandera: extracting finite-state models from Java source code.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Proceedings of the 2000 International Conference on Software Engineering, 2000</sb:maintitle></sb:title><sb:date>2000</sb:date></sb:edited-book><sb:pages><sb:first-page>439</sb:first-page><sb:last-page>448</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0065"><ce:label>CppUnit framework, xxxx</ce:label><ce:other-ref id="oref0065"><ce:textref>CppUnit framework. (http://sourceforge.net/apps/mediawiki/cppunit/).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0070"><ce:label>d'Amorim and Havelund, 2005</ce:label><sb:reference id="sbref0070"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.</ce:given-name><ce:surname>d'Amorim</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Event-based runtime verification of java programs</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>SIGSOFT Software Engineering Notes</sb:maintitle></sb:title><sb:volume-nr>30</sb:volume-nr></sb:series><sb:date>2005</sb:date></sb:issue><sb:pages><sb:first-page>1</sb:first-page><sb:last-page>7</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0075"><ce:label>de la CÃ¡mara et al., 2006</ce:label><sb:reference id="sbref0075"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>P.</ce:given-name><ce:surname>de la CÃ¡mara</ce:surname></sb:author><sb:author><ce:given-name>M.d.M.</ce:given-name><ce:surname>Gallardo</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Merino</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Abstract Matching for Software Model Checking.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:editors><sb:editor><ce:surname>Antti Valmari</ce:surname></sb:editor></sb:editors><sb:title><sb:maintitle>Model Checking Software: 13th International SPIN Workshop, Vienna, Austria, March 30-April 1, 2006. Proceedings. Lecture Notes in Computer Science</sb:maintitle></sb:title><sb:date>2006</sb:date></sb:edited-book><sb:pages><sb:first-page>182</sb:first-page><sb:last-page>200</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0080"><ce:label>de la CÃ¡mara et al., 2010</ce:label><sb:reference id="sbref0080"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>P.</ce:given-name><ce:surname>de la CÃ¡mara</ce:surname></sb:author><sb:author><ce:given-name>J.R.</ce:given-name><ce:surname>Castro</ce:surname></sb:author><sb:author><ce:given-name>M.d.M.</ce:given-name><ce:surname>Gallardo</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Merino</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Verification support for ARINC-653-based avionics software.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Software Testing, Verification and Reliability</sb:maintitle></sb:title></sb:series><sb:date>2010</sb:date></sb:issue><sb:pages><sb:first-page>267</sb:first-page><sb:last-page>298</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0085"><ce:label>Drusinsky, 2000</ce:label><sb:reference id="sbref0085"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Drusinsky</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>The Temporal Rover and the ATG Rover.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Proceedings of the 7th International SPIN Workshop on SPIN Model Checking and Software Verification</sb:maintitle></sb:title><sb:conference>London, UK, UK, Springer-Verlag</sb:conference><sb:date>2000</sb:date></sb:edited-book><sb:pages><sb:first-page>323</sb:first-page><sb:last-page>330</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0090"><ce:label>Eclipse development environment, xxxx</ce:label><ce:other-ref id="oref0090"><ce:textref>Eclipse development environment. (http://www.eclipse.org/).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0095"><ce:label>Fu et al., 2005</ce:label><sb:reference id="sbref0095"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Fu</ce:surname></sb:author><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Milanova</ce:surname></sb:author><sb:author><ce:given-name>B.G.</ce:given-name><ce:surname>Ryder</ce:surname></sb:author><sb:author><ce:given-name>D.G.</ce:given-name><ce:surname>Wonnacott</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Robustness Testing of Java Server Applications</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Software Engineering</sb:maintitle></sb:title><sb:volume-nr>31</sb:volume-nr></sb:series><sb:date>2005</sb:date></sb:issue><sb:pages><sb:first-page>292</sb:first-page><sb:last-page>311</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0100"><ce:label>Gallardo et al., 2004</ce:label><sb:reference id="sbref0100"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.M.</ce:given-name><ce:surname>Gallardo</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>MartÃ­nez</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Merino</ce:surname></sb:author><sb:author><ce:given-name>E.</ce:given-name><ce:surname>Pimentel</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle><ce:italic>Î±</ce:italic>SPIN: a tool for abstract model checking</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>International Journal on Software Tools for Technology Transfer</sb:maintitle></sb:title><sb:volume-nr>5</sb:volume-nr></sb:series><sb:date>2004</sb:date></sb:issue><sb:pages><sb:first-page>165</sb:first-page><sb:last-page>184</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0105"><ce:label>Gallardo et al., 2009</ce:label><sb:reference id="sbref0105"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.M.</ce:given-name><ce:surname>Gallardo</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Merino</ce:surname></sb:author><sb:author><ce:given-name>D.</ce:given-name><ce:surname>SanÃ¡n</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model checking dynamic memory allocation in operating systems</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Journal of Automated Reasoning</sb:maintitle></sb:title><sb:volume-nr>42</sb:volume-nr></sb:series><sb:date>2009</sb:date></sb:issue><sb:pages><sb:first-page>229</sb:first-page><sb:last-page>264</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0110"><ce:label>Giannakopoulou and Havelund, 2001</ce:label><sb:reference id="sbref0110"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Giannakopoulou</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Automata-based verification of temporal properties on running programs.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Proceedings of the 16th IEEE international conference on Automated software engineering</sb:maintitle></sb:title><sb:conference>ASE'01, Washington, DC, USA, IEEE Computer Society</sb:conference><sb:date>2001</sb:date></sb:edited-book><sb:pages><sb:first-page>412</sb:first-page><sb:last-page>416</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0115"><ce:label>Godefroid, 1997</ce:label><sb:reference id="sbref0115"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Godefroid</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model checking for programming languages using VeriSoft.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</sb:maintitle></sb:title><sb:conference>POPL'97, New York, NY, USA, ACM</sb:conference><sb:date>1997</sb:date></sb:edited-book><sb:pages><sb:first-page>174</sb:first-page><sb:last-page>186</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0120"><ce:label>Havelund and Pressburger, 2000</ce:label><sb:reference id="sbref0120"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Pressburger</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model Checking JAVA Programs using JAVA PathFinder.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>STTT</sb:maintitle></sb:title><sb:volume-nr>2</sb:volume-nr></sb:series><sb:date>2000</sb:date></sb:issue><sb:pages><sb:first-page>366</sb:first-page><sb:last-page>381</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0125"><ce:label>Havelund and RoÅu, 2004</ce:label><sb:reference id="sbref0125"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author><sb:author><ce:given-name>G.</ce:given-name><ce:surname>RoÅu</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>An overview of the runtime verification tool Java pathexplorer</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Formal Methods in System Design</sb:maintitle></sb:title><sb:volume-nr>24</sb:volume-nr></sb:series><sb:date>2004</sb:date></sb:issue><sb:pages><sb:first-page>189</sb:first-page><sb:last-page>215</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0130"><ce:label>Holzmann and Bosnacki, 2007</ce:label><sb:reference id="sbref0130"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>G.J.</ce:given-name><ce:surname>Holzmann</ce:surname></sb:author><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Bosnacki</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>The design of a multicore extension of the spin model checker</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Software Engineering</sb:maintitle></sb:title><sb:volume-nr>33</sb:volume-nr></sb:series><sb:date>2007</sb:date></sb:issue><sb:pages><sb:first-page>659</sb:first-page><sb:last-page>674</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0135"><ce:label>Holzmann, 1995</ce:label><sb:reference id="sbref0135"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>G.J.</ce:given-name><ce:surname>Holzmann</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>An Analysis of Bitstate Hashing. In: Formal Methods in System Design</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>1995</sb:date><sb:publisher><sb:name>Chapman &amp; Hall</sb:name><sb:location>Hingham, MA</sb:location></sb:publisher></sb:book><sb:pages><sb:first-page>301</sb:first-page><sb:last-page>314</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0140"><ce:label>Holzmann, 2003</ce:label><sb:reference id="sbref0140"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>G.J.</ce:given-name><ce:surname>Holzmann</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>The SPIN Model Checker: Primer and Reference Manual</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>2003</sb:date><sb:publisher><sb:name>Addison-Wesley Professional</sb:name><sb:location>Boston, MA</sb:location></sb:publisher></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0145"><ce:label>Java Platform Debugger Architecture, xxxx</ce:label><ce:other-ref id="oref0145"><ce:textref>Java Platform Debugger Architecture. (http://java.sun.com/javase/technologies/core/toolsapis/jpda/).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0150"><ce:label>JUnit testing and framework, xxxx</ce:label><ce:other-ref id="oref0150"><ce:textref>JUnit testing framework. (http://www.junit.org).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0155"><ce:label>Kraft et al., 2010</ce:label><sb:reference id="sbref0155"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Kraft</ce:surname></sb:author><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Wall</ce:surname></sb:author><sb:author><ce:given-name>H.M.</ce:given-name><ce:surname>Kienle</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Trace Recording for Embedded Systems: Lessons Learned from Five Industrial Projects.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:title><sb:maintitle>In: RV</sb:maintitle></sb:title><sb:date>2010</sb:date></sb:book><sb:pages><sb:first-page>315</sb:first-page><sb:last-page>329</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0160"><ce:label>Manna and Pnueli, 1992</ce:label><sb:reference id="sbref0160"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>Z.</ce:given-name><ce:surname>Manna</ce:surname></sb:author><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Pnueli</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>The Temporal Logic of Reactive and Concurrent Systems</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>1992</sb:date><sb:publisher><sb:name>Springer-Verlag New York, Inc.</sb:name><sb:location>New York, NY, USA</sb:location></sb:publisher></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0165"><ce:label>Peled, 2003</ce:label><sb:reference id="sbref0165"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Peled</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model checking and testing combined</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:title><sb:maintitle>In: ICALP</sb:maintitle></sb:title><sb:date>2003</sb:date></sb:book><sb:pages><sb:first-page>47</sb:first-page><sb:last-page>63</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0170"><ce:label>Runeson, 2006</ce:label><sb:reference id="sbref0170"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Runeson</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A survey of unit testing practices</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Software</sb:maintitle></sb:title><sb:volume-nr>23</sb:volume-nr></sb:series><sb:date>2006</sb:date></sb:issue><sb:pages><sb:first-page>22</sb:first-page><sb:last-page>29</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0175"><ce:label>Run-time Monitoring and Checking, (MaC), xxxx</ce:label><ce:other-ref id="oref0175"><ce:textref>Run-time Monitoring and Checking (MaC). (http://rtg.cis.upenn.edu/mac).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0180"><ce:label>Schneier, 1995</ce:label><sb:reference id="sbref0180"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>B.</ce:given-name><ce:surname>Schneier</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Applied Cryptography (2nd ed.): Protocols, Algorithms, and Source Code in C</sb:maintitle></sb:title></sb:contribution><sb:host><sb:book><sb:date>1995</sb:date><sb:publisher><sb:name>John Wiley &amp; Sons, Inc.</sb:name><sb:location>New York, NY, USA</sb:location></sb:publisher></sb:book></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0185"><ce:label>Sorotokin, xxxx</ce:label><ce:other-ref id="oref0185"><ce:textref>Sorotokin, P. FTPD server v0.6. (http://peter.sorotokin.com/ftpd).</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0190"><ce:label>Stoller, 2002</ce:label><sb:reference id="sbref0190"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>S.D.</ce:given-name><ce:surname>Stoller</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model-Checking Multi-Threaded Distributed Java programs</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>International Journal on Software Tools for Technology Transfer</sb:maintitle></sb:title><sb:volume-nr>4</sb:volume-nr></sb:series><sb:date>2002</sb:date></sb:issue><sb:pages><sb:first-page>71</sb:first-page><sb:last-page>91</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0195"><ce:label>Vardi and Wolper, 1986</ce:label><sb:reference id="sbref0195"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.Y.</ce:given-name><ce:surname>Vardi</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Wolper</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Automata-theoretic techniques for modal logics of programs</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Journal of Computer and System Sciences</sb:maintitle></sb:title><sb:volume-nr>32</sb:volume-nr></sb:series><sb:date>1986</sb:date></sb:issue><sb:pages><sb:first-page>183</sb:first-page><sb:last-page>221</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0200"><ce:label>Visser et al., 2003</ce:label><sb:reference id="sbref0200"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>W.</ce:given-name><ce:surname>Visser</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Havelund</ce:surname></sb:author><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Brat</ce:surname></sb:author><sb:author><ce:given-name>S.</ce:given-name><ce:surname>Park</ce:surname></sb:author><sb:author><ce:given-name>F.</ce:given-name><ce:surname>Lerda</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Model checking programs</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Automated Software Engineering</sb:maintitle></sb:title><sb:volume-nr>10</sb:volume-nr></sb:series><sb:date>2003</sb:date></sb:issue><sb:pages><sb:first-page>203</sb:first-page><sb:last-page>232</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0205"><ce:label>Wolper et al., 1993</ce:label><sb:reference id="sbref0205"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Wolper</ce:surname></sb:author><sb:author><ce:given-name>P.</ce:given-name><ce:surname>Wolper</ce:surname></sb:author><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Leroy</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Reliable hashing without collision detection.</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>5th International Conference on Computer Aided Verification</sb:maintitle></sb:title><sb:conference>Springer-Verlag</sb:conference><sb:date>1993</sb:date></sb:edited-book><sb:pages><sb:first-page>59</sb:first-page><sb:last-page>70</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0210"><ce:label>Zhang et al., 2009</ce:label><sb:reference id="sbref0210"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>F.</ce:given-name><ce:surname>Zhang</ce:surname></sb:author><sb:author><ce:given-name>Z.</ce:given-name><ce:surname>Qi</ce:surname></sb:author><sb:author><ce:given-name>H.</ce:given-name><ce:surname>Guan</ce:surname></sb:author><sb:author><ce:given-name>X.</ce:given-name><ce:surname>Liu</ce:surname></sb:author><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Yang</ce:surname></sb:author><sb:author><ce:given-name>Z.</ce:given-name><ce:surname>Zhang</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>FiLM: a runtime monitoring tool for distributed systems</sb:maintitle></sb:title></sb:contribution><sb:host><sb:edited-book><sb:title><sb:maintitle>Third IEEE International Conference on Secure Software Integration and Reliability Improvement, 2009. SSIRI 2009</sb:maintitle></sb:title><sb:date>2009</sb:date></sb:edited-book><sb:pages><sb:first-page>40</sb:first-page><sb:last-page>46</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference></ce:bibliography-sec></ce:bibliography><ce:biography id="vt0005" view="all"><ce:simple-para id="spar1100" view="all"><ce:bold>DamiÃ¡n Adalid</ce:bold> is a software engineer at the University of MÃ¡laga's Software Engineering Group. His research interest include the development of tools for software correctness analysis, by applying testing and model checking technologies. Adalid has a MS in telematics and telecommunication networks from the University of MÃ¡laga.</ce:simple-para></ce:biography><ce:biography id="vt0010" view="all"><ce:simple-para id="spar2100" view="all"><ce:bold>Alberto SalmerÃ³n</ce:bold> is a PhD candidate at the University of Malaga's Software Engineering Group. His research interests include model-driven engineering and formal methods applied to communications software. SalmerÃ³n has an MS in computer science from the University of MÃ¡laga.</ce:simple-para></ce:biography><ce:biography id="vt0015" view="all"><ce:simple-para id="spar3100" view="all"><ce:bold>Dr. MarÃ­a del Mar Gallardo</ce:bold> is an associate professor at the University of Malaga (Spain). Her research interests involve the development and use of formal methods and testing and model checking technologies to improve the quality of software. She has participated in several Spanish research projects related with this theme.</ce:simple-para></ce:biography><ce:biography id="vt0020" view="all"><ce:simple-para id="spar4100" view="all"><ce:bold>Dr. Pedro Merino</ce:bold> is an associate professor at University of Malaga. His research interests are foundations, tools, and applications of formal and rigorous methods for critical systems, particularly communications software and development techniques for Internet services on mobile networks. Pedro Merino was the chair of the ERCIM Working Group on Formal Methods for Industrial Critical Systems, and member of the Executive Committee of ERCIM, one of the larger European research consortiums in ICT.</ce:simple-para></ce:biography></tail></article></xocs:serial-item></xocs:doc>
